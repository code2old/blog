---
title: 汇编语言-寄存器（内存访问）
data: 2020-08-01 20:20:00
updated: 2020-08-01 20:20:00
tags:
  - 汇编
categories:  
  - 汇编语言学习
---

### 第三章 寄存器（内存访问）

#### 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

#### DS和[address]

8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：

```
mov bx, 1000H
mov ds, bx
mov al, [0]
```

上面三条指令将10000H(1000:0)中的数据读到al中。

`mov al [0]`中“[...]”表示一个内存单元，"[...]"中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。

8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。

<!-- more -->

#### 字的传送

因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。

#### mov、add、sub指令

mov指令可以有以下几种形式：

```
mov 寄存器, 数据        # mov ax,  8
mov 寄存器, 寄存器      # mov ax,  bx
mov 寄存器, 内存单元    # mov ax,  [0]
mov 内存单元, 寄存器    # mov [0], ax
mov 段寄存器, 寄存器    # mov ds,  ax
mov 寄存器, 段寄存器    # mov ax,  ds
```

#### 数据段

对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：

```assembly
mov ax, 123BH
mov ds, ax          ;将123BH送入DS中，作为数据段的段地址
mov al, 0           ;用al存放累加结果
add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中
add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中
add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中
```

#### 栈

研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。

#### CPU提供的栈机制

当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。

8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。

8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。

执行push ax时，分以下两步完成：

* SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
* 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

执行pop ax时，分以下两步完成：

* 将SS:SP指向的内存单元送入ax中
* SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

#### 栈顶超界问题

8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。

#### push、pop指令

push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：

```
push 寄存器/段寄存器/内存单元     ;可以将一个寄存器/段寄存器/内存单元中的数据入栈
pop 寄存器/段寄存器/内存单元      ;出栈，用一个寄存器/段寄存器/内存单元收出栈的数据
```
指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得

push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。

push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。

push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

#### 栈段

8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段

#### 段的描述

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。

* 用一个段存放数据，则将它定义为“数据段”
* 用一个段存放代码，则将它定义为“代码段”
* 用一个段存放栈，则将它定义为“栈段”

对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问

对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令

对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用

#### 小结

* 字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中
* 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中
* [address]表示一个偏移地址为address的内存单元
* 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应
* mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令

* 8086CPU提供了栈操作机制，方案如下：
    * 在SS、SP中存放栈顶的段地址和偏移地址
    * 提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元
* push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据
* pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2
* 任意时刻，SS:SP指向栈顶元素
* 8086CPU只记录栈顶，栈空间大小需要我们自己管理
* 用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反
* push、pop实质上是一种内存传送指令