---
title: 汇编语言-转移指令的原理
data: 2020-08-12 22:44:00
updated: 2020-08-15 21:44:00
tags:
  - 汇编
categories: 
  - 汇编语言学习
---

### 第九章 转移指令的原理

可以修改IP，或同事修改CS和IP的指令统称为转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处的代码的指令。

8086 CPU的转移行为有以下几类：

* 只修改IP时，称为段内转移，比如：`jmp ax`
* 同时修改CS和IP时，称为段间转移，比如：`jmp 1000:0`

由于转移指令对IP修改范围不同，段内转移又分为：短转移和近转移

* 短转移IP的修改范围为-128~127.
* 近转移IP的修改范围为-32768~32767.

8086 CPU的转移指令分为以下几类：

* 无条件转移指令（如：jmp）
* 条件转移指令
* 循环指令（如：loop）
* 过程
* 中断

#### 操作符offset

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。例如：

```
assume cs:code
code segment
start:
    mov ax, offset start;   ;相当于mov ax, 0

s:
    mov ax, offset s        ;相当于mov ax, 3
code ends
end start
```

`mov ax, offset start`相当于指令`mov ax, 0`，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；`mov ax, offset s`相当于`mov ax, 3`，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令的长度为3字节，则s的偏移地址为3

#### jmp指令

jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP

jmp指令要给出两种信息：

* 转移的目的地址
* 转移的举例（段间转移、段内短转移、段内近转移）

不同的给出目的地址的方法，和不同的转移位置，对应不同格式的jmp指令。

#### 依据位移进行转移的jmp指令

```
jmp short 标号 ;(转移标号处执行指令) 
```

这种格式的jmp指令实现的是段内短转移，它对IP的修改范围在-128~127，也就是说，它向前转移时可以最多越过128字节，向后转移最多越过127字节。jmp指令中的short符号说明指令进行的是短转移。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。

`jmp short 标号`指令对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的标号计算出来的。

实际上，指令`jmp short 标号`的功能为：`(IP)=(IP)+8位位移`

* 8位位移 = 标号处的地址-jmp指令后的第一个字节的地址
* short指明此处的位移为8位位移
* 8位位移的范围为-128~127，用补码表示
* 8位位移由编译程序在编译时算出

还有一种指令与`jmp short 标号`类似：`jmp near ptr标号`，它实现的是段内近转移，只不过是16位的位移长度

#### 转移的目的地址在指令中的jmp指令

`jmp far ptr 标号`实现的是段间转移，又称为远转移，功能如下：

* (CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址
* far ptr指令用标号的段地址和偏移地址修改CS:IP

#### 转移地址在寄存器中的jmp指令

指令格式：jmp 16位寄存器
功能：(IP)=(16位寄存器)

#### 转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式：

* jmp word ptr 内存单元地址(段内转移)；功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址

例如：

```
mov ax, 0123H
mov ds:[0], ax
jmp word ptr ds:[0]
;或者
mov ax, 0123H
mov [bx], ax
jmp word ptr [bx]
```

执行后：(IP)=0123H

* jmp dword ptr 内存单元地址(段间转移)；功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址
* (CS)=(内存单元+2)；(IP)=(内存单元地址)

内存单元地址可用寻址方式的任一格式给出，例如：

```
mov ax, 0123H
mov ds:[0], ax
mov word ptr ds:[2], 0
jmp dword ptr ds:[0]
;或者
mov ax, 0123H
mov [bx], ax
mov word ptr [bx+2], 0
jmp dword ptr [bx]
```

执行后，(CS)=0, (IP)=123H，CS:IP指向0000:0123

#### jczx指令

jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127

指令格式：jcxz 标号 （如果(cx)=0，转移到标号处执行）；
操作：当(cx)=0时，(IP)=(IP)+8位位移。

* 8位位移=标号处的地址-jcxz指令后的第一个字节的地址；
* 8位位移的范围为-128~127，用补码表示；
* 8位位移由编译程序在编译时算出

当(cx)!=0时，什么也不做（程序向下执行）

`jcxz 标号` 功能相当于 `if((cx)==0) jmp short 标号`;

#### loop指令

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对应IP的修改范围都为-128~127

指令格式：loop 标号（(cx)=(cx)-1,如果(cx)!=0，转移到标号处执行）；
操作：(cx)=(cx-1)；如果(cx)!=0，(IP)=(IP)+8位位移。

* 8位位移=标号处的地址-loop指令后的第一个字节的地址；
* 8位位移的范围为-128~127，用补码表示；
* 8位位移由编译程序在编译时算出

当(cx)!=0时，什么也不做（程序向下执行）

`jcxz 标号` 功能相当于 `(cx)--; if((cx)!=0) jmp short 标号`;

#### 根据位移进行转移的意义

```
jmp short 标号
jmp near ptr 标号
jcxz 标号
loop 标号
```

它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，方便了程序段在内存中的浮动装配。

#### 编译器对转移位移超界的检测

根据位移进行转移的指令，转移范围受到转移位移的限制。如果程序转移范围超界的问题，编译时，编译器将报错。
