{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1595256238145},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1595256238145},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1595256238145},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1595256238145},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1595256238145},{"_id":"themes/next/_config.yml","hash":"8d27fd99da5d67a854506bc6fdf82dd24033960a","modified":1596554963548},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1595256238145},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1595256238145},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1595256238145},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1595256238149},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1595256238145},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1595256238145},{"_id":"source/_posts/about.md","hash":"5dd809925122639c0584ae277ea6be963461362a","modified":1596465149599},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1595174797500},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1595256238145},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1595256238145},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1595256238145},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1595256238145},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1595256238145},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1595256238145},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1595256238145},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1595256238145},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1595256238145},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1595256238145},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1595256238145},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1595256238145},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1595256238145},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1595256238145},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1595256238145},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1595256238145},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1595256238145},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1595256238145},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1595256238145},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1595256238145},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1595256238145},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1595256238145},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1595256238145},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1595256238145},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1595256238145},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1595256238145},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1595256238145},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1595256238145},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1595256238145},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1595256238145},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1595256238145},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1595256238145},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1595256238145},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1595256238145},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1595256238145},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1595256238149},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1595256238145},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1595256238149},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1595256238149},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1595256238149},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1595256238149},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1595256238149},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1595256238149},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1595256238149},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1595256238149},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1595256238149},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1595256238149},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1595256238149},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1595256238149},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1595256238149},{"_id":"source/_posts/about/index.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1596464865854},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1595256238145},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1595256238145},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1595256238145},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1595256238145},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1595256238145},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1595256238149},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1595256238149},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1595256238149},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1595256238149},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1595256238149},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1595256238149},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1595256238149},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1595256238149},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1595256238149},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1595256238149},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1595256238149},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1595256238149},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1595256238149},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1595256238149},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1595256238149},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1595256238149},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1595256238149},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1595256238149},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1595256238149},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1595256238149},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1595256238149},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1595256238149},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1595256238149},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1595256238149},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1595256238149},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1595256238149},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1595256238149},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1595256238149},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1595256238149},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1595256238149},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1595256238149},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1595256238149},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1595256238149},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1595256238149},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1595256238149},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1595256238149},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1595256238149},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1595256238153},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1595256238153},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1595256238153},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1595256238153},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1595256238153},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1595256238153},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1595256238153},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1595256238153},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1595256238153},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1595256238153},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1595256238153},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1595256238153},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1595256238153},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1595256238157},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1595256238153},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1595256238153},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1595256238153},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1595256238149},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1595256238149},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1595256238149},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1595256238149},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1595256238149},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1595256238149},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1595256238149},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1595256238149},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1595256238149},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1595256238153},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1595256238153},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1595256238153},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1595256238153},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1595256238157},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1595256238157},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1595256238153},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1595256238157},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1595256238153},{"_id":"public/archives/index.html","hash":"1439d3c2bd66e67670a422a71ecea74a971b5dc4","modified":1596554968968},{"_id":"public/archives/2017/index.html","hash":"c7b7f38fc377f7b19e6a1e6ee3ea499326c48ca3","modified":1596464955375},{"_id":"public/archives/2017/05/index.html","hash":"dd047f3f2d7a40e3760a97a622c46b9829139fa5","modified":1596464955375},{"_id":"public/archives/2020/index.html","hash":"5f1aaf9d29d42c34a2a98d27dcd60f5ef0a8c0f1","modified":1596554968968},{"_id":"public/archives/2020/07/index.html","hash":"af780a08de47d18ee7882e0048d8b4054f50cfc0","modified":1596465369444},{"_id":"public/archives/2020/08/index.html","hash":"52664d9215243394cc21b98423d39976cc2ffa45","modified":1596554968968},{"_id":"public/categories/web前端/index.html","hash":"72726d7aa86f4e968843cf12684820b6e7b14ecf","modified":1596464955375},{"_id":"public/tags/jQuery/index.html","hash":"5f2897fb01edea053394ff3a6ebb79749daabfd6","modified":1596464955375},{"_id":"public/tags/表格/index.html","hash":"1a8a1e4e6aa211fa8a8f3e4774ed0bbfc8291397","modified":1596464955375},{"_id":"public/tags/表单验证/index.html","hash":"48e49fb542485efc690539ff8c5b0f99a63aaa47","modified":1596464955375},{"_id":"public/index.html","hash":"e7ca64d13028f17e5464cc7b66fb113de2c79279","modified":1596554968968},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1596464900680},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1596464900680},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1596464900680},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1596464900680},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1596464900680},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1596464900680},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1596464900680},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1596464900680},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1596464900680},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1596464900680},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1596464900680},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1596464900680},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1596464900680},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1596464900680},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1596464900680},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1596464900680},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1596464900680},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1596464900680},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1596464900680},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1596464900680},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1596464900680},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1596464900680},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1596464900680},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1596464900680},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1596464900680},{"_id":"public/css/main.css","hash":"b9fc2848d61c1e8e164cb78669e008ba4047760f","modified":1596464900680},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1596464900680},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1596464900680},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1596464900680},{"_id":"source/about/index.md","hash":"674539ee9ec38015021570c834305d9fec461569","modified":1596465630113},{"_id":"public/about/index.html","hash":"d356470f2ec99df95cd2f352068be310c4770036","modified":1596554968968},{"_id":"source/_posts/test2.md","hash":"96c595741e1f45cebbac3eed7598ba74f5d460c1","modified":1596465193790},{"_id":"source/categories/index.md","hash":"8f3ad02d53b10b520042a734839215dd5eef1974","modified":1596465174938},{"_id":"source/tags/index.md","hash":"098fd857e1a8965bb7afa448922a2de012463e45","modified":1596465119699},{"_id":"public/tags/index.html","hash":"4c510d71e9ce687fef2c0b9a40aed9f11be6838d","modified":1596554968968},{"_id":"public/categories/index.html","hash":"df8826a325534e61aa0907eb1a6bab066a2cf141","modified":1596554968968},{"_id":"public/categories/Testing/index.html","hash":"bcc4555b499b792af307c68586a9c449f9b4bcc1","modified":1596465369444},{"_id":"public/tags/Testing/index.html","hash":"e9d0552b8e2fbfdf5b82be96f750f607ec5f23a6","modified":1596465369444},{"_id":"public/tags/Another-Tag/index.html","hash":"1b2201e60c2a3bcc5f9960fea0c65023ffe40084","modified":1596465369444},{"_id":"source/_posts/1-basic.md","hash":"d3e0bdbf69b44f33e68e38d9ea05cc208b51122b","modified":1596549564980},{"_id":"source/_posts/2-register(CPU).md","hash":"12206f60e2e7b5c8d05aba327f55366c192ea1dc","modified":1596549558656},{"_id":"source/_posts/3-register(Memory).md","hash":"dcd099f15d87465d41df220a4de86a8075c7b99b","modified":1596549553406},{"_id":"source/_posts/4-first-program.md","hash":"f03717cc4711e60c5938f21946e83ebc3307f4b6","modified":1596549548094},{"_id":"source/_posts/5-[bx]andloop.md","hash":"4a5f6ec21232df84484248bdbacae037ddfd3689","modified":1596549541564},{"_id":"public/tags/汇编/index.html","hash":"eaac8a2a30df6148ef3db48b352325ea877d3ae4","modified":1596554968968},{"_id":"public/tags/编程语言/index.html","hash":"97ce23d2966456e54ca506eb7bd109e394d492fe","modified":1596466004380},{"_id":"public/categories/编程语言/index.html","hash":"aaae66956f7d3ec17cee53596d2aa2a485f3cf8b","modified":1596466004380},{"_id":"public/categories/汇编/index.html","hash":"ecee8e0b03f40b0b5d47c63b43ae8e4e4c5aa3b0","modified":1596466598198},{"_id":"public/2020/08/03/5-[bx]andloop/index.html","hash":"ce7231767a1ecae126ebdc56762d1811da92f5b9","modified":1596466598198},{"_id":"public/2020/08/03/1-basic/index.html","hash":"adc5cda3458463846cc2a20957fbb78bb04b623e","modified":1596466598198},{"_id":"public/2020/08/03/2-register(CPU)/index.html","hash":"6528dfd27294d5925cdcdaa8379e31ca72b14b9a","modified":1596466598198},{"_id":"public/2020/08/03/3-register(Memory)/index.html","hash":"06da9826c0b9815c6c5197f478e4787800583072","modified":1596466598198},{"_id":"public/2020/08/03/4-first-program/index.html","hash":"3cebc82c9cf80f9312c5d0acd5b54b661b0ff6de","modified":1596466598198},{"_id":"source/_posts/linux-nc.md","hash":"b3b850ceadc3f4b4d08bd60065639bb0ec2d33ff","modified":1596554742801},{"_id":"public/2020/08/04/5-[bx]andloop/index.html","hash":"53c0c79aa819325a3349f0c6a709ce8a0aa1bfe1","modified":1596554968968},{"_id":"public/categories/Linux命令详解/index.html","hash":"096023b24f2b30f8cba4f2ba6c9d9833884b8a81","modified":1596554968968},{"_id":"public/categories/汇编语言学习/index.html","hash":"e8c34b225d7d7fac00e1fbbd500a7654aeb31ae8","modified":1596554968968},{"_id":"public/tags/Linux/index.html","hash":"11eb4326252c1b81acf281486dbf2f5e82a76f34","modified":1596554968968},{"_id":"public/2020/08/04/linux-nc/index.html","hash":"5c8bb6907684ceff155fb7985632fcbdd0449197","modified":1596554968968},{"_id":"public/2020/08/04/1-basic/index.html","hash":"30fda34de2d69c44332f7ee84957dad09721d04c","modified":1596554968968},{"_id":"public/2020/08/04/2-register(CPU)/index.html","hash":"9793c2764e2a454a2da8d6a84188e620aa1801cc","modified":1596554968968},{"_id":"public/2020/08/04/3-register(Memory)/index.html","hash":"2c003f494db5f79c48917a42b86389c33e400841","modified":1596554968968},{"_id":"public/2020/08/04/4-first-program/index.html","hash":"11a5c78d5080ab5c611b98328c6dd25d4122d285","modified":1596554968968}],"Category":[{"name":"web前端","_id":"ckdelzdef0002zyfw3gpyfp5i"},{"name":"Testing","_id":"ckdem5nb200070ufwc5zlhzga"},{"name":"汇编","_id":"ckdeml9sh00053ofw5pt4dack"},{"name":"编程语言","_id":"ckdemlgbc00093ofw1o2n2fj3"},{"name":"Linux命令详解","_id":"ckdg3ihsu0001g8fwfls826ty"},{"name":"汇编语言学习","_id":"ckdg3ihta0005g8fwarb7apqi"}],"Data":[],"Page":[{"title":"About me","comments":0,"_content":"\n博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。\n\nGithub: @code2old\n\nEmail: gcb_93@163.com\n","source":"about/index.md","raw":"---\ntitle: About me\ncomments: false\n---\n\n博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。\n\nGithub: @code2old\n\nEmail: gcb_93@163.com\n","date":"2020-08-03T14:40:30.110Z","updated":"2020-08-03T14:40:30.113Z","path":"about/index.html","_id":"ckdem0e1f000008fwg2nx2o9w","layout":"page","content":"<p>博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。</p>\n<p>Github: @code2old</p>\n<p>Email: <a href=\"mailto:gcb_93@163.com\">gcb_93@163.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。</p>\n<p>Github: @code2old</p>\n<p>Email: <a href=\"mailto:gcb_93@163.com\">gcb_93@163.com</a></p>\n"},{"title":"tags","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ncomments: false\n---","date":"2020-08-03T14:31:59.695Z","updated":"2020-08-03T14:31:59.699Z","path":"tags/index.html","_id":"ckdem40g900000ufwgp7rg9cn","layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ncomments: false\n---","date":"2020-08-03T14:32:54.935Z","updated":"2020-08-03T14:32:54.938Z","path":"categories/index.html","_id":"ckdem57jp00050ufwd3hv5cp0","layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"汇编语言-基础知识","_content":"\n### 第一章 基础知识\n\n#### 1.1 机器语言\n\n机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n#### 1.2 汇编语言的产生\n\n汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。\n```\n操作：寄存器BX的内容送到AX中\n机器指令：1000100111011000\n汇编指令：mov ax, bx\n```\n将汇编指令转换成机器指令的翻译程序就被称为编译器。\n\n#### 1.3 汇编语言的组成\n\n汇编语言由以下3类指令组成：\n* 汇编指令：机器码的助记符，有对应的机器码\n* 伪指令：没有对应的机器码，由编译器执行，计算机并不执行\n* 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。\n汇编语言的核心是机器指令，它决定了汇编语言的特性\n\n#### 1.4 存储器\n\nCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。\n\n#### 1.5 指令和数据\n\n指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。\n\n#### 1.6 存储单元\n\n存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。\n\n#### 1.7 CPU对存储器的读写\n\nCPU要想进行数据的读写，必须和外部器件进行3类信息交换：\n* 存储单元的地址（地址信息）\n* 器件的选择，读或写的命令（控制信息）\n* 读或写的书写（数据信息）\n计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线\n\n#### 1.8 地址总线\n\nCPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址\n\n#### 1.9 数据总线\n\nCPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。\n\n#### 1.10 控制总线\n\nCPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。\n\n#### 1.11 内存地址空间概述\n\n##### 1.11.1 主板\n\n##### 1.11.2 接口卡\n\nCPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作\n\n#### 1.12 各类存储器芯片\n\n存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：\n* 随机存储器\n* 装有BIOS（Basic Input/Output System）的ROM\n* 接口卡上的RAM\n\n#### 1.13 内存地址空间\n\n所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：\n\n```\n00000 |————————————————————|\n      |   主存储器地址空间  |\n      |      (RAM)         |\n9FFFF |____________________|\nA0000 |                    |\n      |    显存地址空间     |\nBFFFF |____________________|\nC0000 |                    |\n      |   各类ROM地址空间   | \nFFFFF |____________________|   \n```\n\n#### 小结\n\n* 汇编指令是机器指令的助记符，同机器指令一一对应\n* 每一种CPU都有自己的汇编指令集\n* CPU直接使用的信息存放在存储器中\n* 在存储中指令和数据没有任何区别，都是二进制信息\n* 存储单元从0开始顺序编号\n* 一个存储单元可以存储8个bit，即8位二进制数\n* 1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB\n* 每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：\n    * 地址总线的宽度决定了CPU的寻址能力\n    * 数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量\n    * 控制总线的宽度决定了CPU对系统中其它器件的控制能力\n\n对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n","source":"_posts/1-basic.md","raw":"---\ntitle: 汇编语言-基础知识\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第一章 基础知识\n\n#### 1.1 机器语言\n\n机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n#### 1.2 汇编语言的产生\n\n汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。\n```\n操作：寄存器BX的内容送到AX中\n机器指令：1000100111011000\n汇编指令：mov ax, bx\n```\n将汇编指令转换成机器指令的翻译程序就被称为编译器。\n\n#### 1.3 汇编语言的组成\n\n汇编语言由以下3类指令组成：\n* 汇编指令：机器码的助记符，有对应的机器码\n* 伪指令：没有对应的机器码，由编译器执行，计算机并不执行\n* 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。\n汇编语言的核心是机器指令，它决定了汇编语言的特性\n\n#### 1.4 存储器\n\nCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。\n\n#### 1.5 指令和数据\n\n指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。\n\n#### 1.6 存储单元\n\n存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。\n\n#### 1.7 CPU对存储器的读写\n\nCPU要想进行数据的读写，必须和外部器件进行3类信息交换：\n* 存储单元的地址（地址信息）\n* 器件的选择，读或写的命令（控制信息）\n* 读或写的书写（数据信息）\n计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线\n\n#### 1.8 地址总线\n\nCPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址\n\n#### 1.9 数据总线\n\nCPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。\n\n#### 1.10 控制总线\n\nCPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。\n\n#### 1.11 内存地址空间概述\n\n##### 1.11.1 主板\n\n##### 1.11.2 接口卡\n\nCPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作\n\n#### 1.12 各类存储器芯片\n\n存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：\n* 随机存储器\n* 装有BIOS（Basic Input/Output System）的ROM\n* 接口卡上的RAM\n\n#### 1.13 内存地址空间\n\n所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：\n\n```\n00000 |————————————————————|\n      |   主存储器地址空间  |\n      |      (RAM)         |\n9FFFF |____________________|\nA0000 |                    |\n      |    显存地址空间     |\nBFFFF |____________________|\nC0000 |                    |\n      |   各类ROM地址空间   | \nFFFFF |____________________|   \n```\n\n#### 小结\n\n* 汇编指令是机器指令的助记符，同机器指令一一对应\n* 每一种CPU都有自己的汇编指令集\n* CPU直接使用的信息存放在存储器中\n* 在存储中指令和数据没有任何区别，都是二进制信息\n* 存储单元从0开始顺序编号\n* 一个存储单元可以存储8个bit，即8位二进制数\n* 1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB\n* 每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：\n    * 地址总线的宽度决定了CPU的寻址能力\n    * 数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量\n    * 控制总线的宽度决定了CPU对系统中其它器件的控制能力\n\n对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n","slug":"1-basic","published":1,"date":"2020-08-04T13:59:24.975Z","updated":"2020-08-04T13:59:24.980Z","_id":"ckdemilws00003ofw0yew7de4","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第一章-基础知识\"><a href=\"#第一章-基础知识\" class=\"headerlink\" title=\"第一章 基础知识\"></a>第一章 基础知识</h3><h4 id=\"1-1-机器语言\"><a href=\"#1-1-机器语言\" class=\"headerlink\" title=\"1.1 机器语言\"></a>1.1 机器语言</h4><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>\n<h4 id=\"1-2-汇编语言的产生\"><a href=\"#1-2-汇编语言的产生\" class=\"headerlink\" title=\"1.2 汇编语言的产生\"></a>1.2 汇编语言的产生</h4><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作：寄存器BX的内容送到AX中</span><br><span class=\"line\">机器指令：1000100111011000</span><br><span class=\"line\">汇编指令：mov ax, bx</span><br></pre></td></tr></table></figure>\n<p>将汇编指令转换成机器指令的翻译程序就被称为编译器。</p>\n<h4 id=\"1-3-汇编语言的组成\"><a href=\"#1-3-汇编语言的组成\" class=\"headerlink\" title=\"1.3 汇编语言的组成\"></a>1.3 汇编语言的组成</h4><p>汇编语言由以下3类指令组成：</p>\n<ul>\n<li>汇编指令：机器码的助记符，有对应的机器码</li>\n<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>\n<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。<br>汇编语言的核心是机器指令，它决定了汇编语言的特性</li>\n</ul>\n<h4 id=\"1-4-存储器\"><a href=\"#1-4-存储器\" class=\"headerlink\" title=\"1.4 存储器\"></a>1.4 存储器</h4><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。</p>\n<h4 id=\"1-5-指令和数据\"><a href=\"#1-5-指令和数据\" class=\"headerlink\" title=\"1.5 指令和数据\"></a>1.5 指令和数据</h4><p>指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。</p>\n<h4 id=\"1-6-存储单元\"><a href=\"#1-6-存储单元\" class=\"headerlink\" title=\"1.6 存储单元\"></a>1.6 存储单元</h4><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。</p>\n<h4 id=\"1-7-CPU对存储器的读写\"><a href=\"#1-7-CPU对存储器的读写\" class=\"headerlink\" title=\"1.7 CPU对存储器的读写\"></a>1.7 CPU对存储器的读写</h4><p>CPU要想进行数据的读写，必须和外部器件进行3类信息交换：</p>\n<ul>\n<li>存储单元的地址（地址信息）</li>\n<li>器件的选择，读或写的命令（控制信息）</li>\n<li>读或写的书写（数据信息）<br>计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线</li>\n</ul>\n<h4 id=\"1-8-地址总线\"><a href=\"#1-8-地址总线\" class=\"headerlink\" title=\"1.8 地址总线\"></a>1.8 地址总线</h4><p>CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址</p>\n<h4 id=\"1-9-数据总线\"><a href=\"#1-9-数据总线\" class=\"headerlink\" title=\"1.9 数据总线\"></a>1.9 数据总线</h4><p>CPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。</p>\n<h4 id=\"1-10-控制总线\"><a href=\"#1-10-控制总线\" class=\"headerlink\" title=\"1.10 控制总线\"></a>1.10 控制总线</h4><p>CPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。</p>\n<h4 id=\"1-11-内存地址空间概述\"><a href=\"#1-11-内存地址空间概述\" class=\"headerlink\" title=\"1.11 内存地址空间概述\"></a>1.11 内存地址空间概述</h4><h5 id=\"1-11-1-主板\"><a href=\"#1-11-1-主板\" class=\"headerlink\" title=\"1.11.1 主板\"></a>1.11.1 主板</h5><h5 id=\"1-11-2-接口卡\"><a href=\"#1-11-2-接口卡\" class=\"headerlink\" title=\"1.11.2 接口卡\"></a>1.11.2 接口卡</h5><p>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</p>\n<h4 id=\"1-12-各类存储器芯片\"><a href=\"#1-12-各类存储器芯片\" class=\"headerlink\" title=\"1.12 各类存储器芯片\"></a>1.12 各类存储器芯片</h4><p>存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：</p>\n<ul>\n<li>随机存储器</li>\n<li>装有BIOS（Basic Input/Output System）的ROM</li>\n<li>接口卡上的RAM</li>\n</ul>\n<h4 id=\"1-13-内存地址空间\"><a href=\"#1-13-内存地址空间\" class=\"headerlink\" title=\"1.13 内存地址空间\"></a>1.13 内存地址空间</h4><p>所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 |————————————————————|</span><br><span class=\"line\">      |   主存储器地址空间  |</span><br><span class=\"line\">      |      (RAM)         |</span><br><span class=\"line\">9FFFF |____________________|</span><br><span class=\"line\">A0000 |                    |</span><br><span class=\"line\">      |    显存地址空间     |</span><br><span class=\"line\">BFFFF |____________________|</span><br><span class=\"line\">C0000 |                    |</span><br><span class=\"line\">      |   各类ROM地址空间   | </span><br><span class=\"line\">FFFFF |____________________|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>\n<li>每一种CPU都有自己的汇编指令集</li>\n<li>CPU直接使用的信息存放在存储器中</li>\n<li>在存储中指令和数据没有任何区别，都是二进制信息</li>\n<li>存储单元从0开始顺序编号</li>\n<li>一个存储单元可以存储8个bit，即8位二进制数</li>\n<li>1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB</li>\n<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n</ul>\n<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第一章-基础知识\"><a href=\"#第一章-基础知识\" class=\"headerlink\" title=\"第一章 基础知识\"></a>第一章 基础知识</h3><h4 id=\"1-1-机器语言\"><a href=\"#1-1-机器语言\" class=\"headerlink\" title=\"1.1 机器语言\"></a>1.1 机器语言</h4><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>\n<h4 id=\"1-2-汇编语言的产生\"><a href=\"#1-2-汇编语言的产生\" class=\"headerlink\" title=\"1.2 汇编语言的产生\"></a>1.2 汇编语言的产生</h4><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作：寄存器BX的内容送到AX中</span><br><span class=\"line\">机器指令：1000100111011000</span><br><span class=\"line\">汇编指令：mov ax, bx</span><br></pre></td></tr></table></figure>\n<p>将汇编指令转换成机器指令的翻译程序就被称为编译器。</p>\n<h4 id=\"1-3-汇编语言的组成\"><a href=\"#1-3-汇编语言的组成\" class=\"headerlink\" title=\"1.3 汇编语言的组成\"></a>1.3 汇编语言的组成</h4><p>汇编语言由以下3类指令组成：</p>\n<ul>\n<li>汇编指令：机器码的助记符，有对应的机器码</li>\n<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>\n<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。<br>汇编语言的核心是机器指令，它决定了汇编语言的特性</li>\n</ul>\n<h4 id=\"1-4-存储器\"><a href=\"#1-4-存储器\" class=\"headerlink\" title=\"1.4 存储器\"></a>1.4 存储器</h4><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。</p>\n<h4 id=\"1-5-指令和数据\"><a href=\"#1-5-指令和数据\" class=\"headerlink\" title=\"1.5 指令和数据\"></a>1.5 指令和数据</h4><p>指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。</p>\n<h4 id=\"1-6-存储单元\"><a href=\"#1-6-存储单元\" class=\"headerlink\" title=\"1.6 存储单元\"></a>1.6 存储单元</h4><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。</p>\n<h4 id=\"1-7-CPU对存储器的读写\"><a href=\"#1-7-CPU对存储器的读写\" class=\"headerlink\" title=\"1.7 CPU对存储器的读写\"></a>1.7 CPU对存储器的读写</h4><p>CPU要想进行数据的读写，必须和外部器件进行3类信息交换：</p>\n<ul>\n<li>存储单元的地址（地址信息）</li>\n<li>器件的选择，读或写的命令（控制信息）</li>\n<li>读或写的书写（数据信息）<br>计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线</li>\n</ul>\n<h4 id=\"1-8-地址总线\"><a href=\"#1-8-地址总线\" class=\"headerlink\" title=\"1.8 地址总线\"></a>1.8 地址总线</h4><p>CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址</p>\n<h4 id=\"1-9-数据总线\"><a href=\"#1-9-数据总线\" class=\"headerlink\" title=\"1.9 数据总线\"></a>1.9 数据总线</h4><p>CPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。</p>\n<h4 id=\"1-10-控制总线\"><a href=\"#1-10-控制总线\" class=\"headerlink\" title=\"1.10 控制总线\"></a>1.10 控制总线</h4><p>CPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。</p>\n<h4 id=\"1-11-内存地址空间概述\"><a href=\"#1-11-内存地址空间概述\" class=\"headerlink\" title=\"1.11 内存地址空间概述\"></a>1.11 内存地址空间概述</h4><h5 id=\"1-11-1-主板\"><a href=\"#1-11-1-主板\" class=\"headerlink\" title=\"1.11.1 主板\"></a>1.11.1 主板</h5><h5 id=\"1-11-2-接口卡\"><a href=\"#1-11-2-接口卡\" class=\"headerlink\" title=\"1.11.2 接口卡\"></a>1.11.2 接口卡</h5><p>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</p>\n<h4 id=\"1-12-各类存储器芯片\"><a href=\"#1-12-各类存储器芯片\" class=\"headerlink\" title=\"1.12 各类存储器芯片\"></a>1.12 各类存储器芯片</h4><p>存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：</p>\n<ul>\n<li>随机存储器</li>\n<li>装有BIOS（Basic Input/Output System）的ROM</li>\n<li>接口卡上的RAM</li>\n</ul>\n<h4 id=\"1-13-内存地址空间\"><a href=\"#1-13-内存地址空间\" class=\"headerlink\" title=\"1.13 内存地址空间\"></a>1.13 内存地址空间</h4><p>所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 |————————————————————|</span><br><span class=\"line\">      |   主存储器地址空间  |</span><br><span class=\"line\">      |      (RAM)         |</span><br><span class=\"line\">9FFFF |____________________|</span><br><span class=\"line\">A0000 |                    |</span><br><span class=\"line\">      |    显存地址空间     |</span><br><span class=\"line\">BFFFF |____________________|</span><br><span class=\"line\">C0000 |                    |</span><br><span class=\"line\">      |   各类ROM地址空间   | </span><br><span class=\"line\">FFFFF |____________________|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>\n<li>每一种CPU都有自己的汇编指令集</li>\n<li>CPU直接使用的信息存放在存储器中</li>\n<li>在存储中指令和数据没有任何区别，都是二进制信息</li>\n<li>存储单元从0开始顺序编号</li>\n<li>一个存储单元可以存储8个bit，即8位二进制数</li>\n<li>1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB</li>\n<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n</ul>\n<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>\n"},{"title":"汇编语言-寄存器（CPU工作原理）","_content":"\n### 第二章 寄存器（CPU工作原理）\n\n内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。\n\n汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。\n\n8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。\n\n#### 2.1 通用寄存器\n\n8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：\n\n* AX可分为AH和AL\n* BX可分为BH和BL\n* CX可分为CH和CL\n* DX可分为DH和DL\n\n以AX为例，8086CPU的16位寄存器逻辑结构如下：\n\n```\n|—————————————————————————————————AX——————————————————————————————————|\n| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n|———————————————AH————————————————————|—————————————AL————————————————|\n| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n\n```\n\n#### 2.2 字在存储器中的存储\n\n出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：\n\n* 字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中\n* 字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节\n\n#### 2.3 几条汇编指令\n\n汇编指令举例：\n\n|汇编指令   |控制CPU完成的操作     |用高级语言的语法描述|\n|:---------|:-------------------------------|:-------|\n|mov ax, 18|将18送入寄存器AX                 |AX=18   |\n|mov ah, 78|将78送入寄存器AH                 |AH=18   |\n|add ax,  8|将寄存器AX中的数值加上8           |AX=AX+8 |\n|mov ax, bx|将寄存器BX中的数据送入寄存器AX    |AX=BX   |\n|add ax, bx|将AX和BX中的数值相加，结果存在AX中|AX=AX+BX|\n|||\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。\n\n#### 2.4 物理地址\n\nCPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。\n\n#### 2.5 16位结构的CPU\n\n16位结构描述了CPU下面的几个结构特性：\n\n* 运算器一次最多可以处理16位数据\n* 寄存器最大位宽为16位\n* 寄存器和运算器之间的通路为16位\n\n也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。\n\n#### 2.6 8086CPU给出物理地址的方法\n\n8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。\n\n8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n当8086CPU要读写内存时：\n\n* CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址\n* 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件\n* 地址加法器通过内部总线将20位物理地址送入输入输出控制电路\n* 输入输出控制电路将20位物理地址送入地址总线\n* 20位物理地址被地址总线传送到存储器\n\n地址加法器采用**物理地址=段地址x16+偏移地址**的方法用段地址和偏移地址合成物理地址\n\n#### 2.7 “段地址x16+偏移地址=物理地址”的本质含义\n\n“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。\n\n#### 2.8 段的概念\n\n内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。\n\n#### 2.9 段寄存器\n\n8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。\n\n#### 2.10 CS和IP\n\nCS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。\n\n8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n8086CPU的工作过程简要描述如下：\n\n* 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n* IP=IP+读取指令的长度，从而指向下一条指令\n* 执行指令，转到步骤1，重复这个过程\n\n在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。\n\n在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。\n\n#### 2.11 修改CS、IP的指令\n\n8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。\n\n若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：\n\n```\njmp 2AE3:3 #执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令\njmp 2:0B16 #执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令\n```\n\njmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP\n\n若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：\n\n```\njmp ax, 指令执行前：ax=1000H，CS=2000H，IP=0003H\n        指令执行后：ax=1000H，CS=2000H，IP=1000H\njmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H\n        指令执行后：ax=0B16H，CS=2000H，IP=0B16H\n```\n\n指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令\n\n#### 2.12 代码段\n\n将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。\n\n要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。\n\n#### 小结\n\n* 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址\n* CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n* 8086CPU的工作过程\n    * 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\n    * IP指向下一条指令；\n    * 执行指令。（转到步骤（1），重复这个过程）\n* 8086CPU提供转移指令修改CS、IP的内容","source":"_posts/2-register(CPU).md","raw":"---\ntitle: 汇编语言-寄存器（CPU工作原理）\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第二章 寄存器（CPU工作原理）\n\n内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。\n\n汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。\n\n8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。\n\n#### 2.1 通用寄存器\n\n8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：\n\n* AX可分为AH和AL\n* BX可分为BH和BL\n* CX可分为CH和CL\n* DX可分为DH和DL\n\n以AX为例，8086CPU的16位寄存器逻辑结构如下：\n\n```\n|—————————————————————————————————AX——————————————————————————————————|\n| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n|———————————————AH————————————————————|—————————————AL————————————————|\n| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n\n```\n\n#### 2.2 字在存储器中的存储\n\n出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：\n\n* 字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中\n* 字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节\n\n#### 2.3 几条汇编指令\n\n汇编指令举例：\n\n|汇编指令   |控制CPU完成的操作     |用高级语言的语法描述|\n|:---------|:-------------------------------|:-------|\n|mov ax, 18|将18送入寄存器AX                 |AX=18   |\n|mov ah, 78|将78送入寄存器AH                 |AH=18   |\n|add ax,  8|将寄存器AX中的数值加上8           |AX=AX+8 |\n|mov ax, bx|将寄存器BX中的数据送入寄存器AX    |AX=BX   |\n|add ax, bx|将AX和BX中的数值相加，结果存在AX中|AX=AX+BX|\n|||\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。\n\n#### 2.4 物理地址\n\nCPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。\n\n#### 2.5 16位结构的CPU\n\n16位结构描述了CPU下面的几个结构特性：\n\n* 运算器一次最多可以处理16位数据\n* 寄存器最大位宽为16位\n* 寄存器和运算器之间的通路为16位\n\n也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。\n\n#### 2.6 8086CPU给出物理地址的方法\n\n8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。\n\n8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n当8086CPU要读写内存时：\n\n* CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址\n* 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件\n* 地址加法器通过内部总线将20位物理地址送入输入输出控制电路\n* 输入输出控制电路将20位物理地址送入地址总线\n* 20位物理地址被地址总线传送到存储器\n\n地址加法器采用**物理地址=段地址x16+偏移地址**的方法用段地址和偏移地址合成物理地址\n\n#### 2.7 “段地址x16+偏移地址=物理地址”的本质含义\n\n“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。\n\n#### 2.8 段的概念\n\n内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。\n\n#### 2.9 段寄存器\n\n8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。\n\n#### 2.10 CS和IP\n\nCS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。\n\n8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n8086CPU的工作过程简要描述如下：\n\n* 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n* IP=IP+读取指令的长度，从而指向下一条指令\n* 执行指令，转到步骤1，重复这个过程\n\n在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。\n\n在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。\n\n#### 2.11 修改CS、IP的指令\n\n8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。\n\n若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：\n\n```\njmp 2AE3:3 #执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令\njmp 2:0B16 #执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令\n```\n\njmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP\n\n若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：\n\n```\njmp ax, 指令执行前：ax=1000H，CS=2000H，IP=0003H\n        指令执行后：ax=1000H，CS=2000H，IP=1000H\njmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H\n        指令执行后：ax=0B16H，CS=2000H，IP=0B16H\n```\n\n指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令\n\n#### 2.12 代码段\n\n将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。\n\n要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。\n\n#### 小结\n\n* 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址\n* CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n* 8086CPU的工作过程\n    * 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\n    * IP指向下一条指令；\n    * 执行指令。（转到步骤（1），重复这个过程）\n* 8086CPU提供转移指令修改CS、IP的内容","slug":"2-register(CPU)","published":1,"date":"2020-08-04T13:59:18.651Z","updated":"2020-08-04T13:59:18.656Z","_id":"ckdemilx100013ofwetfy5peg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第二章-寄存器（CPU工作原理）\"><a href=\"#第二章-寄存器（CPU工作原理）\" class=\"headerlink\" title=\"第二章 寄存器（CPU工作原理）\"></a>第二章 寄存器（CPU工作原理）</h3><p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。</p>\n<p>汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。</p>\n<p>8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>\n<h4 id=\"2-1-通用寄存器\"><a href=\"#2-1-通用寄存器\" class=\"headerlink\" title=\"2.1 通用寄存器\"></a>2.1 通用寄存器</h4><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：</p>\n<ul>\n<li>AX可分为AH和AL</li>\n<li>BX可分为BH和BL</li>\n<li>CX可分为CH和CL</li>\n<li>DX可分为DH和DL</li>\n</ul>\n<p>以AX为例，8086CPU的16位寄存器逻辑结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—————————————————————————————————AX——————————————————————————————————|</span><br><span class=\"line\">| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br><span class=\"line\">|———————————————AH————————————————————|—————————————AL————————————————|</span><br><span class=\"line\">| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-字在存储器中的存储\"><a href=\"#2-2-字在存储器中的存储\" class=\"headerlink\" title=\"2.2 字在存储器中的存储\"></a>2.2 字在存储器中的存储</h4><p>出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：</p>\n<ul>\n<li>字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中</li>\n<li>字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节</li>\n</ul>\n<h4 id=\"2-3-几条汇编指令\"><a href=\"#2-3-几条汇编指令\" class=\"headerlink\" title=\"2.3 几条汇编指令\"></a>2.3 几条汇编指令</h4><p>汇编指令举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">汇编指令</th>\n<th align=\"left\">控制CPU完成的操作</th>\n<th align=\"left\">用高级语言的语法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mov ax, 18</td>\n<td align=\"left\">将18送入寄存器AX</td>\n<td align=\"left\">AX=18</td>\n</tr>\n<tr>\n<td align=\"left\">mov ah, 78</td>\n<td align=\"left\">将78送入寄存器AH</td>\n<td align=\"left\">AH=18</td>\n</tr>\n<tr>\n<td align=\"left\">add ax,  8</td>\n<td align=\"left\">将寄存器AX中的数值加上8</td>\n<td align=\"left\">AX=AX+8</td>\n</tr>\n<tr>\n<td align=\"left\">mov ax, bx</td>\n<td align=\"left\">将寄存器BX中的数据送入寄存器AX</td>\n<td align=\"left\">AX=BX</td>\n</tr>\n<tr>\n<td align=\"left\">add ax, bx</td>\n<td align=\"left\">将AX和BX中的数值相加，结果存在AX中</td>\n<td align=\"left\">AX=AX+BX</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p>\n<h4 id=\"2-4-物理地址\"><a href=\"#2-4-物理地址\" class=\"headerlink\" title=\"2.4 物理地址\"></a>2.4 物理地址</h4><p>CPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。</p>\n<h4 id=\"2-5-16位结构的CPU\"><a href=\"#2-5-16位结构的CPU\" class=\"headerlink\" title=\"2.5 16位结构的CPU\"></a>2.5 16位结构的CPU</h4><p>16位结构描述了CPU下面的几个结构特性：</p>\n<ul>\n<li>运算器一次最多可以处理16位数据</li>\n<li>寄存器最大位宽为16位</li>\n<li>寄存器和运算器之间的通路为16位</li>\n</ul>\n<p>也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。</p>\n<h4 id=\"2-6-8086CPU给出物理地址的方法\"><a href=\"#2-6-8086CPU给出物理地址的方法\" class=\"headerlink\" title=\"2.6 8086CPU给出物理地址的方法\"></a>2.6 8086CPU给出物理地址的方法</h4><p>8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。</p>\n<p>8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n<p>当8086CPU要读写内存时：</p>\n<ul>\n<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址</li>\n<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>\n<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>\n<li>输入输出控制电路将20位物理地址送入地址总线</li>\n<li>20位物理地址被地址总线传送到存储器</li>\n</ul>\n<p>地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p>\n<h4 id=\"2-7-“段地址x16-偏移地址-物理地址”的本质含义\"><a href=\"#2-7-“段地址x16-偏移地址-物理地址”的本质含义\" class=\"headerlink\" title=\"2.7 “段地址x16+偏移地址=物理地址”的本质含义\"></a>2.7 “段地址x16+偏移地址=物理地址”的本质含义</h4><p>“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。</p>\n<h4 id=\"2-8-段的概念\"><a href=\"#2-8-段的概念\" class=\"headerlink\" title=\"2.8 段的概念\"></a>2.8 段的概念</h4><p>内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。</p>\n<h4 id=\"2-9-段寄存器\"><a href=\"#2-9-段寄存器\" class=\"headerlink\" title=\"2.9 段寄存器\"></a>2.9 段寄存器</h4><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p>\n<h4 id=\"2-10-CS和IP\"><a href=\"#2-10-CS和IP\" class=\"headerlink\" title=\"2.10 CS和IP\"></a>2.10 CS和IP</h4><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。</p>\n<p>8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n<p>8086CPU的工作过程简要描述如下：</p>\n<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>\n<li>IP=IP+读取指令的长度，从而指向下一条指令</li>\n<li>执行指令，转到步骤1，重复这个过程</li>\n</ul>\n<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。</p>\n<p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。</p>\n<h4 id=\"2-11-修改CS、IP的指令\"><a href=\"#2-11-修改CS、IP的指令\" class=\"headerlink\" title=\"2.11 修改CS、IP的指令\"></a>2.11 修改CS、IP的指令</h4><p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。</p>\n<p>若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2AE3:3 #执行后：CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H处读取指令</span><br><span class=\"line\">jmp 2:0B16 #执行后：CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H处读取指令</span><br></pre></td></tr></table></figure>\n\n<p>jmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p>\n<p>若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp ax, 指令执行前：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;1000H</span><br><span class=\"line\">jmp bx，指令执行前：bx&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0B16H</span><br></pre></td></tr></table></figure>\n\n<p>指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令</p>\n<h4 id=\"2-12-代码段\"><a href=\"#2-12-代码段\" class=\"headerlink\" title=\"2.12 代码段\"></a>2.12 代码段</h4><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。</p>\n<p>要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li>\n<li>CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li>\n<li>8086CPU的工作过程<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>\n<li>IP指向下一条指令；</li>\n<li>执行指令。（转到步骤（1），重复这个过程）</li>\n</ul>\n</li>\n<li>8086CPU提供转移指令修改CS、IP的内容</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第二章-寄存器（CPU工作原理）\"><a href=\"#第二章-寄存器（CPU工作原理）\" class=\"headerlink\" title=\"第二章 寄存器（CPU工作原理）\"></a>第二章 寄存器（CPU工作原理）</h3><p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。</p>\n<p>汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。</p>\n<p>8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>\n<h4 id=\"2-1-通用寄存器\"><a href=\"#2-1-通用寄存器\" class=\"headerlink\" title=\"2.1 通用寄存器\"></a>2.1 通用寄存器</h4><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：</p>\n<ul>\n<li>AX可分为AH和AL</li>\n<li>BX可分为BH和BL</li>\n<li>CX可分为CH和CL</li>\n<li>DX可分为DH和DL</li>\n</ul>\n<p>以AX为例，8086CPU的16位寄存器逻辑结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—————————————————————————————————AX——————————————————————————————————|</span><br><span class=\"line\">| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br><span class=\"line\">|———————————————AH————————————————————|—————————————AL————————————————|</span><br><span class=\"line\">| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-字在存储器中的存储\"><a href=\"#2-2-字在存储器中的存储\" class=\"headerlink\" title=\"2.2 字在存储器中的存储\"></a>2.2 字在存储器中的存储</h4><p>出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：</p>\n<ul>\n<li>字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中</li>\n<li>字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节</li>\n</ul>\n<h4 id=\"2-3-几条汇编指令\"><a href=\"#2-3-几条汇编指令\" class=\"headerlink\" title=\"2.3 几条汇编指令\"></a>2.3 几条汇编指令</h4><p>汇编指令举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">汇编指令</th>\n<th align=\"left\">控制CPU完成的操作</th>\n<th align=\"left\">用高级语言的语法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mov ax, 18</td>\n<td align=\"left\">将18送入寄存器AX</td>\n<td align=\"left\">AX=18</td>\n</tr>\n<tr>\n<td align=\"left\">mov ah, 78</td>\n<td align=\"left\">将78送入寄存器AH</td>\n<td align=\"left\">AH=18</td>\n</tr>\n<tr>\n<td align=\"left\">add ax,  8</td>\n<td align=\"left\">将寄存器AX中的数值加上8</td>\n<td align=\"left\">AX=AX+8</td>\n</tr>\n<tr>\n<td align=\"left\">mov ax, bx</td>\n<td align=\"left\">将寄存器BX中的数据送入寄存器AX</td>\n<td align=\"left\">AX=BX</td>\n</tr>\n<tr>\n<td align=\"left\">add ax, bx</td>\n<td align=\"left\">将AX和BX中的数值相加，结果存在AX中</td>\n<td align=\"left\">AX=AX+BX</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p>\n<h4 id=\"2-4-物理地址\"><a href=\"#2-4-物理地址\" class=\"headerlink\" title=\"2.4 物理地址\"></a>2.4 物理地址</h4><p>CPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。</p>\n<h4 id=\"2-5-16位结构的CPU\"><a href=\"#2-5-16位结构的CPU\" class=\"headerlink\" title=\"2.5 16位结构的CPU\"></a>2.5 16位结构的CPU</h4><p>16位结构描述了CPU下面的几个结构特性：</p>\n<ul>\n<li>运算器一次最多可以处理16位数据</li>\n<li>寄存器最大位宽为16位</li>\n<li>寄存器和运算器之间的通路为16位</li>\n</ul>\n<p>也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。</p>\n<h4 id=\"2-6-8086CPU给出物理地址的方法\"><a href=\"#2-6-8086CPU给出物理地址的方法\" class=\"headerlink\" title=\"2.6 8086CPU给出物理地址的方法\"></a>2.6 8086CPU给出物理地址的方法</h4><p>8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。</p>\n<p>8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n<p>当8086CPU要读写内存时：</p>\n<ul>\n<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址</li>\n<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>\n<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>\n<li>输入输出控制电路将20位物理地址送入地址总线</li>\n<li>20位物理地址被地址总线传送到存储器</li>\n</ul>\n<p>地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p>\n<h4 id=\"2-7-“段地址x16-偏移地址-物理地址”的本质含义\"><a href=\"#2-7-“段地址x16-偏移地址-物理地址”的本质含义\" class=\"headerlink\" title=\"2.7 “段地址x16+偏移地址=物理地址”的本质含义\"></a>2.7 “段地址x16+偏移地址=物理地址”的本质含义</h4><p>“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。</p>\n<h4 id=\"2-8-段的概念\"><a href=\"#2-8-段的概念\" class=\"headerlink\" title=\"2.8 段的概念\"></a>2.8 段的概念</h4><p>内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。</p>\n<h4 id=\"2-9-段寄存器\"><a href=\"#2-9-段寄存器\" class=\"headerlink\" title=\"2.9 段寄存器\"></a>2.9 段寄存器</h4><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p>\n<h4 id=\"2-10-CS和IP\"><a href=\"#2-10-CS和IP\" class=\"headerlink\" title=\"2.10 CS和IP\"></a>2.10 CS和IP</h4><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。</p>\n<p>8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n<p>8086CPU的工作过程简要描述如下：</p>\n<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>\n<li>IP=IP+读取指令的长度，从而指向下一条指令</li>\n<li>执行指令，转到步骤1，重复这个过程</li>\n</ul>\n<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。</p>\n<p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。</p>\n<h4 id=\"2-11-修改CS、IP的指令\"><a href=\"#2-11-修改CS、IP的指令\" class=\"headerlink\" title=\"2.11 修改CS、IP的指令\"></a>2.11 修改CS、IP的指令</h4><p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。</p>\n<p>若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2AE3:3 #执行后：CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H处读取指令</span><br><span class=\"line\">jmp 2:0B16 #执行后：CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H处读取指令</span><br></pre></td></tr></table></figure>\n\n<p>jmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p>\n<p>若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp ax, 指令执行前：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;1000H</span><br><span class=\"line\">jmp bx，指令执行前：bx&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0B16H</span><br></pre></td></tr></table></figure>\n\n<p>指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令</p>\n<h4 id=\"2-12-代码段\"><a href=\"#2-12-代码段\" class=\"headerlink\" title=\"2.12 代码段\"></a>2.12 代码段</h4><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。</p>\n<p>要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li>\n<li>CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li>\n<li>8086CPU的工作过程<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>\n<li>IP指向下一条指令；</li>\n<li>执行指令。（转到步骤（1），重复这个过程）</li>\n</ul>\n</li>\n<li>8086CPU提供转移指令修改CS、IP的内容</li>\n</ul>\n"},{"title":"汇编语言-寄存器（内存访问）","_content":"\n### 第三章 寄存器（内存访问）\n\n#### 3.1 内存中字的存储\n\nCPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n\n字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n#### 3.2 DS和[address]\n\n8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：\n\n```\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n上面三条指令将10000H(1000:0)中的数据读到al中。\n\n`mov al [0]`中“[...]”表示一个内存单元，\"[...]\"中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。\n\n8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。\n\n#### 3.3 字的传送\n\n因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。\n\n#### 3.4 mov、add、sub指令\n\nmov指令可以有以下几种形式：\n\n```\nmov 寄存器, 数据        # mov ax,  8\nmov 寄存器, 寄存器      # mov ax,  bx\nmov 寄存器, 内存单元    # mov ax,  [0]\nmov 内存单元, 寄存器    # mov [0], ax\nmov 段寄存器, 寄存器    # mov ds,  ax\nmov 寄存器, 段寄存器    # mov ax,  ds\n```\n\n#### 3.5 数据段\n\n对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：\n\n```assembly\nmov ax, 123BH\nmov ds, ax          ;将123BH送入DS中，作为数据段的段地址\nmov al, 0           ;用al存放累加结果\nadd al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中\nadd al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中\nadd al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中\n```\n\n#### 3.6 栈\n\n研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。\n\n#### 3.7 CPU提供的栈机制\n\n当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。\n\n8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。\n\n8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。\n\n执行push ax时，分以下两步完成：\n\n* SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n* 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\n执行popax时，分以下两步完成：\n\n* 将SS:SP指向的内存单元送入ax中\n* SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n#### 3.8 栈顶超界问题\n\n8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。\n\n我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。\n\n#### 3.9 push、pop指令\n\npush和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：\n\n```\npush 寄存器/段寄存器/内存单元     ;可以将一个寄存器/段寄存器/内存单元中的数据入栈\npop 寄存器/段寄存器/内存单元      ;出栈，用一个寄存器/段寄存器/内存单元收出栈的数据\n```\n指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得\n\npush、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n\npush和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。\n\npush，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。\n\n#### 3.10 栈段\n\n8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段\n\n#### 段的描述\n\n我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。\n\n* 用一个段存放数据，则将它定义为“数据段”\n* 用一个段存放代码，则将它定义为“代码段”\n* 用一个段存放栈，则将它定义为“栈段”\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问\n\n对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用\n\n\n\n\n#### 小结\n\n* 字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n* 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中\n* [address]表示一个偏移地址为address的内存单元\n* 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应\n* mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令\n\n* 8086CPU提供了栈操作机制，方案如下：\n    * 在SS、SP中存放栈顶的段地址和偏移地址\n    * 提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元\n* push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据\n* pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2\n* 任意时刻，SS:SP指向栈顶元素\n* 8086CPU只记录栈顶，栈空间大小需要我们自己管理\n* 用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反\n* push、pop实质上是一种内存传送指令","source":"_posts/3-register(Memory).md","raw":"---\ntitle: 汇编语言-寄存器（内存访问）\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第三章 寄存器（内存访问）\n\n#### 3.1 内存中字的存储\n\nCPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n\n字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n#### 3.2 DS和[address]\n\n8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：\n\n```\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n上面三条指令将10000H(1000:0)中的数据读到al中。\n\n`mov al [0]`中“[...]”表示一个内存单元，\"[...]\"中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。\n\n8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。\n\n#### 3.3 字的传送\n\n因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。\n\n#### 3.4 mov、add、sub指令\n\nmov指令可以有以下几种形式：\n\n```\nmov 寄存器, 数据        # mov ax,  8\nmov 寄存器, 寄存器      # mov ax,  bx\nmov 寄存器, 内存单元    # mov ax,  [0]\nmov 内存单元, 寄存器    # mov [0], ax\nmov 段寄存器, 寄存器    # mov ds,  ax\nmov 寄存器, 段寄存器    # mov ax,  ds\n```\n\n#### 3.5 数据段\n\n对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：\n\n```assembly\nmov ax, 123BH\nmov ds, ax          ;将123BH送入DS中，作为数据段的段地址\nmov al, 0           ;用al存放累加结果\nadd al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中\nadd al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中\nadd al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中\n```\n\n#### 3.6 栈\n\n研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。\n\n#### 3.7 CPU提供的栈机制\n\n当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。\n\n8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。\n\n8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。\n\n执行push ax时，分以下两步完成：\n\n* SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n* 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\n执行popax时，分以下两步完成：\n\n* 将SS:SP指向的内存单元送入ax中\n* SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n#### 3.8 栈顶超界问题\n\n8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。\n\n我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。\n\n#### 3.9 push、pop指令\n\npush和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：\n\n```\npush 寄存器/段寄存器/内存单元     ;可以将一个寄存器/段寄存器/内存单元中的数据入栈\npop 寄存器/段寄存器/内存单元      ;出栈，用一个寄存器/段寄存器/内存单元收出栈的数据\n```\n指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得\n\npush、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n\npush和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。\n\npush，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。\n\n#### 3.10 栈段\n\n8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段\n\n#### 段的描述\n\n我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。\n\n* 用一个段存放数据，则将它定义为“数据段”\n* 用一个段存放代码，则将它定义为“代码段”\n* 用一个段存放栈，则将它定义为“栈段”\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问\n\n对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用\n\n\n\n\n#### 小结\n\n* 字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n* 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中\n* [address]表示一个偏移地址为address的内存单元\n* 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应\n* mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令\n\n* 8086CPU提供了栈操作机制，方案如下：\n    * 在SS、SP中存放栈顶的段地址和偏移地址\n    * 提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元\n* push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据\n* pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2\n* 任意时刻，SS:SP指向栈顶元素\n* 8086CPU只记录栈顶，栈空间大小需要我们自己管理\n* 用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反\n* push、pop实质上是一种内存传送指令","slug":"3-register(Memory)","published":1,"date":"2020-08-04T13:59:13.403Z","updated":"2020-08-04T13:59:13.406Z","_id":"ckdemilxs00023ofwahpae8u8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第三章-寄存器（内存访问）\"><a href=\"#第三章-寄存器（内存访问）\" class=\"headerlink\" title=\"第三章 寄存器（内存访问）\"></a>第三章 寄存器（内存访问）</h3><h4 id=\"3-1-内存中字的存储\"><a href=\"#3-1-内存中字的存储\" class=\"headerlink\" title=\"3.1 内存中字的存储\"></a>3.1 内存中字的存储</h4><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>\n<p>字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>\n<h4 id=\"3-2-DS和-address\"><a href=\"#3-2-DS和-address\" class=\"headerlink\" title=\"3.2 DS和[address]\"></a>3.2 DS和[address]</h4><p>8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx, 1000H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov al, [0]</span><br></pre></td></tr></table></figure>\n\n<p>上面三条指令将10000H(1000:0)中的数据读到al中。</p>\n<p><code>mov al [0]</code>中“[…]”表示一个内存单元，”[…]”中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。</p>\n<p>8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。</p>\n<h4 id=\"3-3-字的传送\"><a href=\"#3-3-字的传送\" class=\"headerlink\" title=\"3.3 字的传送\"></a>3.3 字的传送</h4><p>因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。</p>\n<h4 id=\"3-4-mov、add、sub指令\"><a href=\"#3-4-mov、add、sub指令\" class=\"headerlink\" title=\"3.4 mov、add、sub指令\"></a>3.4 mov、add、sub指令</h4><p>mov指令可以有以下几种形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov 寄存器, 数据        # mov ax,  8</span><br><span class=\"line\">mov 寄存器, 寄存器      # mov ax,  bx</span><br><span class=\"line\">mov 寄存器, 内存单元    # mov ax,  [0]</span><br><span class=\"line\">mov 内存单元, 寄存器    # mov [0], ax</span><br><span class=\"line\">mov 段寄存器, 寄存器    # mov ds,  ax</span><br><span class=\"line\">mov 寄存器, 段寄存器    # mov ax,  ds</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-数据段\"><a href=\"#3-5-数据段\" class=\"headerlink\" title=\"3.5 数据段\"></a>3.5 数据段</h4><p>对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 123BH</span><br><span class=\"line\">mov ds, ax          ;将123BH送入DS中，作为数据段的段地址</span><br><span class=\"line\">mov al, 0           ;用al存放累加结果</span><br><span class=\"line\">add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中</span><br><span class=\"line\">add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中</span><br><span class=\"line\">add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-栈\"><a href=\"#3-6-栈\" class=\"headerlink\" title=\"3.6 栈\"></a>3.6 栈</h4><p>研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。</p>\n<h4 id=\"3-7-CPU提供的栈机制\"><a href=\"#3-7-CPU提供的栈机制\" class=\"headerlink\" title=\"3.7 CPU提供的栈机制\"></a>3.7 CPU提供的栈机制</h4><p>当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。</p>\n<p>8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>\n<p>8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>\n<p>执行push ax时，分以下两步完成：</p>\n<ul>\n<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>\n<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>\n</ul>\n<p>执行popax时，分以下两步完成：</p>\n<ul>\n<li>将SS:SP指向的内存单元送入ax中</li>\n<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>\n</ul>\n<h4 id=\"3-8-栈顶超界问题\"><a href=\"#3-8-栈顶超界问题\" class=\"headerlink\" title=\"3.8 栈顶超界问题\"></a>3.8 栈顶超界问题</h4><p>8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。</p>\n<p>我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。</p>\n<h4 id=\"3-9-push、pop指令\"><a href=\"#3-9-push、pop指令\" class=\"headerlink\" title=\"3.9 push、pop指令\"></a>3.9 push、pop指令</h4><p>push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 寄存器&#x2F;段寄存器&#x2F;内存单元     ;可以将一个寄存器&#x2F;段寄存器&#x2F;内存单元中的数据入栈</span><br><span class=\"line\">pop 寄存器&#x2F;段寄存器&#x2F;内存单元      ;出栈，用一个寄存器&#x2F;段寄存器&#x2F;内存单元收出栈的数据</span><br></pre></td></tr></table></figure>\n<p>指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p>\n<p>push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。</p>\n<p>push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。</p>\n<p>push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</p>\n<h4 id=\"3-10-栈段\"><a href=\"#3-10-栈段\" class=\"headerlink\" title=\"3.10 栈段\"></a>3.10 栈段</h4><p>8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段</p>\n<h4 id=\"段的描述\"><a href=\"#段的描述\" class=\"headerlink\" title=\"段的描述\"></a>段的描述</h4><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。</p>\n<ul>\n<li>用一个段存放数据，则将它定义为“数据段”</li>\n<li>用一个段存放代码，则将它定义为“代码段”</li>\n<li>用一个段存放栈，则将它定义为“栈段”</li>\n</ul>\n<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问</p>\n<p>对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>\n<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li><p>字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>\n</li>\n<li><p>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</p>\n</li>\n<li><p>[address]表示一个偏移地址为address的内存单元</p>\n</li>\n<li><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应</p>\n</li>\n<li><p>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p>\n</li>\n<li><p>8086CPU提供了栈操作机制，方案如下：</p>\n<ul>\n<li>在SS、SP中存放栈顶的段地址和偏移地址</li>\n<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>\n</ul>\n</li>\n<li><p>push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据</p>\n</li>\n<li><p>pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2</p>\n</li>\n<li><p>任意时刻，SS:SP指向栈顶元素</p>\n</li>\n<li><p>8086CPU只记录栈顶，栈空间大小需要我们自己管理</p>\n</li>\n<li><p>用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反</p>\n</li>\n<li><p>push、pop实质上是一种内存传送指令</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第三章-寄存器（内存访问）\"><a href=\"#第三章-寄存器（内存访问）\" class=\"headerlink\" title=\"第三章 寄存器（内存访问）\"></a>第三章 寄存器（内存访问）</h3><h4 id=\"3-1-内存中字的存储\"><a href=\"#3-1-内存中字的存储\" class=\"headerlink\" title=\"3.1 内存中字的存储\"></a>3.1 内存中字的存储</h4><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>\n<p>字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>\n<h4 id=\"3-2-DS和-address\"><a href=\"#3-2-DS和-address\" class=\"headerlink\" title=\"3.2 DS和[address]\"></a>3.2 DS和[address]</h4><p>8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx, 1000H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov al, [0]</span><br></pre></td></tr></table></figure>\n\n<p>上面三条指令将10000H(1000:0)中的数据读到al中。</p>\n<p><code>mov al [0]</code>中“[…]”表示一个内存单元，”[…]”中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。</p>\n<p>8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。</p>\n<h4 id=\"3-3-字的传送\"><a href=\"#3-3-字的传送\" class=\"headerlink\" title=\"3.3 字的传送\"></a>3.3 字的传送</h4><p>因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。</p>\n<h4 id=\"3-4-mov、add、sub指令\"><a href=\"#3-4-mov、add、sub指令\" class=\"headerlink\" title=\"3.4 mov、add、sub指令\"></a>3.4 mov、add、sub指令</h4><p>mov指令可以有以下几种形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov 寄存器, 数据        # mov ax,  8</span><br><span class=\"line\">mov 寄存器, 寄存器      # mov ax,  bx</span><br><span class=\"line\">mov 寄存器, 内存单元    # mov ax,  [0]</span><br><span class=\"line\">mov 内存单元, 寄存器    # mov [0], ax</span><br><span class=\"line\">mov 段寄存器, 寄存器    # mov ds,  ax</span><br><span class=\"line\">mov 寄存器, 段寄存器    # mov ax,  ds</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-数据段\"><a href=\"#3-5-数据段\" class=\"headerlink\" title=\"3.5 数据段\"></a>3.5 数据段</h4><p>对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 123BH</span><br><span class=\"line\">mov ds, ax          ;将123BH送入DS中，作为数据段的段地址</span><br><span class=\"line\">mov al, 0           ;用al存放累加结果</span><br><span class=\"line\">add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中</span><br><span class=\"line\">add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中</span><br><span class=\"line\">add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-栈\"><a href=\"#3-6-栈\" class=\"headerlink\" title=\"3.6 栈\"></a>3.6 栈</h4><p>研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。</p>\n<h4 id=\"3-7-CPU提供的栈机制\"><a href=\"#3-7-CPU提供的栈机制\" class=\"headerlink\" title=\"3.7 CPU提供的栈机制\"></a>3.7 CPU提供的栈机制</h4><p>当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。</p>\n<p>8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>\n<p>8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>\n<p>执行push ax时，分以下两步完成：</p>\n<ul>\n<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>\n<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>\n</ul>\n<p>执行popax时，分以下两步完成：</p>\n<ul>\n<li>将SS:SP指向的内存单元送入ax中</li>\n<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>\n</ul>\n<h4 id=\"3-8-栈顶超界问题\"><a href=\"#3-8-栈顶超界问题\" class=\"headerlink\" title=\"3.8 栈顶超界问题\"></a>3.8 栈顶超界问题</h4><p>8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。</p>\n<p>我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。</p>\n<h4 id=\"3-9-push、pop指令\"><a href=\"#3-9-push、pop指令\" class=\"headerlink\" title=\"3.9 push、pop指令\"></a>3.9 push、pop指令</h4><p>push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 寄存器&#x2F;段寄存器&#x2F;内存单元     ;可以将一个寄存器&#x2F;段寄存器&#x2F;内存单元中的数据入栈</span><br><span class=\"line\">pop 寄存器&#x2F;段寄存器&#x2F;内存单元      ;出栈，用一个寄存器&#x2F;段寄存器&#x2F;内存单元收出栈的数据</span><br></pre></td></tr></table></figure>\n<p>指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p>\n<p>push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。</p>\n<p>push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。</p>\n<p>push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</p>\n<h4 id=\"3-10-栈段\"><a href=\"#3-10-栈段\" class=\"headerlink\" title=\"3.10 栈段\"></a>3.10 栈段</h4><p>8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段</p>\n<h4 id=\"段的描述\"><a href=\"#段的描述\" class=\"headerlink\" title=\"段的描述\"></a>段的描述</h4><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。</p>\n<ul>\n<li>用一个段存放数据，则将它定义为“数据段”</li>\n<li>用一个段存放代码，则将它定义为“代码段”</li>\n<li>用一个段存放栈，则将它定义为“栈段”</li>\n</ul>\n<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问</p>\n<p>对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>\n<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li><p>字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>\n</li>\n<li><p>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</p>\n</li>\n<li><p>[address]表示一个偏移地址为address的内存单元</p>\n</li>\n<li><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应</p>\n</li>\n<li><p>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p>\n</li>\n<li><p>8086CPU提供了栈操作机制，方案如下：</p>\n<ul>\n<li>在SS、SP中存放栈顶的段地址和偏移地址</li>\n<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>\n</ul>\n</li>\n<li><p>push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据</p>\n</li>\n<li><p>pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2</p>\n</li>\n<li><p>任意时刻，SS:SP指向栈顶元素</p>\n</li>\n<li><p>8086CPU只记录栈顶，栈空间大小需要我们自己管理</p>\n</li>\n<li><p>用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反</p>\n</li>\n<li><p>push、pop实质上是一种内存传送指令</p>\n</li>\n</ul>\n"},{"title":"汇编语言-第一个程序","_content":"\n### 第四章 第1个程序\n\n#### 4.1 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行的简要过程如下：\n\n* 第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件\n* 第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容\n    * 程序和数据\n    * 相关的描述信息\n* 第三步 执行可执行文件中的程序\n\n#### 4.2 源程序\n\n程序4.1\n\n```\nassume cs:codesg\n\ncodesg segment\n\nstart: mov ax, 0123H\n       mov bx, 0456H\n       add ax, bx\n       add ax, ax\n\n       mov ax, 4c00H\n       int 21H\n\ncodesg ends\n\nend\n```\n\n在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。\n\n（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：\n\n```\n# 其中XXX为段名\nXXX segment     ; 定义一个段，段名为XXX，这个段从此开始\nXXX ends        ; 名称为XXX的段到此结束\n```\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码\n\n（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 \n\n（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。\n\n| 目的 | 相关指令 | 指令性质 | 指令执行者 |\n| ------ | ------ | ------ | ------ |\n| 通知编译器一个段结束 | 段名ends | 伪指令 | 编译时，由编译器执行 |\n| 通知编译器程序结束   | end      | 伪指令 | 编译时，由编译器执行|\n| 程序返回            | mov ax, 4c00H int 21H | 汇编指令 | 执行时，由CPU执行|\n\n\n\n\n","source":"_posts/4-first-program.md","raw":"---\ntitle: 汇编语言-第一个程序\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第四章 第1个程序\n\n#### 4.1 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行的简要过程如下：\n\n* 第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件\n* 第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容\n    * 程序和数据\n    * 相关的描述信息\n* 第三步 执行可执行文件中的程序\n\n#### 4.2 源程序\n\n程序4.1\n\n```\nassume cs:codesg\n\ncodesg segment\n\nstart: mov ax, 0123H\n       mov bx, 0456H\n       add ax, bx\n       add ax, ax\n\n       mov ax, 4c00H\n       int 21H\n\ncodesg ends\n\nend\n```\n\n在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。\n\n（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：\n\n```\n# 其中XXX为段名\nXXX segment     ; 定义一个段，段名为XXX，这个段从此开始\nXXX ends        ; 名称为XXX的段到此结束\n```\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码\n\n（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 \n\n（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。\n\n| 目的 | 相关指令 | 指令性质 | 指令执行者 |\n| ------ | ------ | ------ | ------ |\n| 通知编译器一个段结束 | 段名ends | 伪指令 | 编译时，由编译器执行 |\n| 通知编译器程序结束   | end      | 伪指令 | 编译时，由编译器执行|\n| 程序返回            | mov ax, 4c00H int 21H | 汇编指令 | 执行时，由CPU执行|\n\n\n\n\n","slug":"4-first-program","published":1,"date":"2020-08-04T13:59:08.087Z","updated":"2020-08-04T13:59:08.094Z","_id":"ckdemily100033ofw08b73pv0","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第四章-第1个程序\"><a href=\"#第四章-第1个程序\" class=\"headerlink\" title=\"第四章 第1个程序\"></a>第四章 第1个程序</h3><h4 id=\"4-1-一个源程序从写出到执行的过程\"><a href=\"#4-1-一个源程序从写出到执行的过程\" class=\"headerlink\" title=\"4.1 一个源程序从写出到执行的过程\"></a>4.1 一个源程序从写出到执行的过程</h4><p>一个汇编语言程序从写出到最终执行的简要过程如下：</p>\n<ul>\n<li>第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件</li>\n<li>第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容<ul>\n<li>程序和数据</li>\n<li>相关的描述信息</li>\n</ul>\n</li>\n<li>第三步 执行可执行文件中的程序</li>\n</ul>\n<h4 id=\"4-2-源程序\"><a href=\"#4-2-源程序\" class=\"headerlink\" title=\"4.2 源程序\"></a>4.2 源程序</h4><p>程序4.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">start: mov ax, 0123H</span><br><span class=\"line\">       mov bx, 0456H</span><br><span class=\"line\">       add ax, bx</span><br><span class=\"line\">       add ax, ax</span><br><span class=\"line\"></span><br><span class=\"line\">       mov ax, 4c00H</span><br><span class=\"line\">       int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。</p>\n<p>（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中XXX为段名</span><br><span class=\"line\">XXX segment     ; 定义一个段，段名为XXX，这个段从此开始</span><br><span class=\"line\">XXX ends        ; 名称为XXX的段到此结束</span><br></pre></td></tr></table></figure>\n\n<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中</p>\n<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</p>\n<p>（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 </p>\n<p>（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p>\n<table>\n<thead>\n<tr>\n<th>目的</th>\n<th>相关指令</th>\n<th>指令性质</th>\n<th>指令执行者</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知编译器一个段结束</td>\n<td>段名ends</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>通知编译器程序结束</td>\n<td>end</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>程序返回</td>\n<td>mov ax, 4c00H int 21H</td>\n<td>汇编指令</td>\n<td>执行时，由CPU执行</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第四章-第1个程序\"><a href=\"#第四章-第1个程序\" class=\"headerlink\" title=\"第四章 第1个程序\"></a>第四章 第1个程序</h3><h4 id=\"4-1-一个源程序从写出到执行的过程\"><a href=\"#4-1-一个源程序从写出到执行的过程\" class=\"headerlink\" title=\"4.1 一个源程序从写出到执行的过程\"></a>4.1 一个源程序从写出到执行的过程</h4><p>一个汇编语言程序从写出到最终执行的简要过程如下：</p>\n<ul>\n<li>第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件</li>\n<li>第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容<ul>\n<li>程序和数据</li>\n<li>相关的描述信息</li>\n</ul>\n</li>\n<li>第三步 执行可执行文件中的程序</li>\n</ul>\n<h4 id=\"4-2-源程序\"><a href=\"#4-2-源程序\" class=\"headerlink\" title=\"4.2 源程序\"></a>4.2 源程序</h4><p>程序4.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">start: mov ax, 0123H</span><br><span class=\"line\">       mov bx, 0456H</span><br><span class=\"line\">       add ax, bx</span><br><span class=\"line\">       add ax, ax</span><br><span class=\"line\"></span><br><span class=\"line\">       mov ax, 4c00H</span><br><span class=\"line\">       int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。</p>\n<p>（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中XXX为段名</span><br><span class=\"line\">XXX segment     ; 定义一个段，段名为XXX，这个段从此开始</span><br><span class=\"line\">XXX ends        ; 名称为XXX的段到此结束</span><br></pre></td></tr></table></figure>\n\n<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中</p>\n<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</p>\n<p>（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 </p>\n<p>（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p>\n<table>\n<thead>\n<tr>\n<th>目的</th>\n<th>相关指令</th>\n<th>指令性质</th>\n<th>指令执行者</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知编译器一个段结束</td>\n<td>段名ends</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>通知编译器程序结束</td>\n<td>end</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>程序返回</td>\n<td>mov ax, 4c00H int 21H</td>\n<td>汇编指令</td>\n<td>执行时，由CPU执行</td>\n</tr>\n</tbody></table>\n"},{"title":"汇编语言","_content":"\n### 第五章 [bx]和loop指令\n\n","source":"_posts/5-[bx]andloop.md","raw":"---\ntitle: 汇编语言\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第五章 [bx]和loop指令\n\n","slug":"5-[bx]andloop","published":1,"date":"2020-08-04T13:59:01.559Z","updated":"2020-08-04T13:59:01.564Z","_id":"ckdemilyu00043ofw2co40s2g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第五章-bx-和loop指令\"><a href=\"#第五章-bx-和loop指令\" class=\"headerlink\" title=\"第五章 [bx]和loop指令\"></a>第五章 [bx]和loop指令</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第五章-bx-和loop指令\"><a href=\"#第五章-bx-和loop指令\" class=\"headerlink\" title=\"第五章 [bx]和loop指令\"></a>第五章 [bx]和loop指令</h3>"},{"title":"Linux-nc命令详解","_content":"\n### Linux命令详解-netcat\n\nnetcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。\n\n#### 常用netcat命令示例\n\n##### 1. 端口扫描\n\nnetcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞\n\n```shell\n$nc -z -v -n 192.168.63.35 21-25\n```\n这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。\n-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换\n-v 表示详细输出\n-n 表示netcat不使用DNS反向查询IP地址的域名\n\n##### 2. 文件传输\n\nLinux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。\n\n```shell\n# A--->B\n$ nc -l 8000 < file.txt            # 机器A，server端\n$ nc -n 192.168.63.35 > file.txt   # 机器B，client端\n```\n\n以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。\n\n也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。\n\n```shell\n# A<---B\n$ nc -l 8000 > file.txt             # 机器A，server端\n$ nc 192.168.63.35 8000 < file.txt  # 机器B，client端\n```\n\n##### 3. 目录传输\n\n发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。\n\n```shell\n# A--->B\n$ tar -cvf - dirname | nc -l 8000           # 机器A，server端\n$ nc -n 192.168.63.35 8000 | tar -xvf -     # 机器B，client端\n```\n\n在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。\n\n如果想要节省带宽，可以通过压缩工具压缩后再进行发送\n\n```shell\n$ tar -cvf - dirname | bzip2 -z | nc -l 8000         # 机器A，server端\n$ nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   # 机器B，client端\n```\n\n使用tar归档和bzip2压缩和解压\n\n##### 4. 网络加密传输\n\n在发送数据之前，可以使用mcrypt工具保证数据安全\n\n```shell\n$ nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb > file.txt    # 客户端\n$ mcrypt --flush --bare -F -q -m ecb < file.txt | nc -l 8000   #服务端\n```\n\n以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。\n\n（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）\n\n##### 5. 视频流\n\n个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法\n\n```shell\n$ cat video.mp4 | nc -l 8000\n$ nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -\n```\n\n以上命令netcat从socket中读取数据并重定向到mplayer中\n\n##### 6. 克隆一个设备\n\n如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下\n\n```shell\n$ dd if=/dev/sda | nc -l 8000            # server端\n$ nc -n 192.168.63.35 | dd of=/dev/sda   # client端\n```\n\ndd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。\n\n\n","source":"_posts/linux-nc.md","raw":"---\ntitle: Linux-nc命令详解\ntags:\n  - Linux\ncategories: \n  - Linux命令详解\n---\n\n### Linux命令详解-netcat\n\nnetcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。\n\n#### 常用netcat命令示例\n\n##### 1. 端口扫描\n\nnetcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞\n\n```shell\n$nc -z -v -n 192.168.63.35 21-25\n```\n这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。\n-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换\n-v 表示详细输出\n-n 表示netcat不使用DNS反向查询IP地址的域名\n\n##### 2. 文件传输\n\nLinux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。\n\n```shell\n# A--->B\n$ nc -l 8000 < file.txt            # 机器A，server端\n$ nc -n 192.168.63.35 > file.txt   # 机器B，client端\n```\n\n以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。\n\n也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。\n\n```shell\n# A<---B\n$ nc -l 8000 > file.txt             # 机器A，server端\n$ nc 192.168.63.35 8000 < file.txt  # 机器B，client端\n```\n\n##### 3. 目录传输\n\n发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。\n\n```shell\n# A--->B\n$ tar -cvf - dirname | nc -l 8000           # 机器A，server端\n$ nc -n 192.168.63.35 8000 | tar -xvf -     # 机器B，client端\n```\n\n在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。\n\n如果想要节省带宽，可以通过压缩工具压缩后再进行发送\n\n```shell\n$ tar -cvf - dirname | bzip2 -z | nc -l 8000         # 机器A，server端\n$ nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   # 机器B，client端\n```\n\n使用tar归档和bzip2压缩和解压\n\n##### 4. 网络加密传输\n\n在发送数据之前，可以使用mcrypt工具保证数据安全\n\n```shell\n$ nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb > file.txt    # 客户端\n$ mcrypt --flush --bare -F -q -m ecb < file.txt | nc -l 8000   #服务端\n```\n\n以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。\n\n（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）\n\n##### 5. 视频流\n\n个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法\n\n```shell\n$ cat video.mp4 | nc -l 8000\n$ nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -\n```\n\n以上命令netcat从socket中读取数据并重定向到mplayer中\n\n##### 6. 克隆一个设备\n\n如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下\n\n```shell\n$ dd if=/dev/sda | nc -l 8000            # server端\n$ nc -n 192.168.63.35 | dd of=/dev/sda   # client端\n```\n\ndd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。\n\n\n","slug":"linux-nc","published":1,"date":"2020-08-04T15:25:42.796Z","updated":"2020-08-04T15:25:42.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdg3ihsj0000g8fwbbqvfcmy","content":"<h3 id=\"Linux命令详解-netcat\"><a href=\"#Linux命令详解-netcat\" class=\"headerlink\" title=\"Linux命令详解-netcat\"></a>Linux命令详解-netcat</h3><p>netcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。</p>\n<h4 id=\"常用netcat命令示例\"><a href=\"#常用netcat命令示例\" class=\"headerlink\" title=\"常用netcat命令示例\"></a>常用netcat命令示例</h4><h5 id=\"1-端口扫描\"><a href=\"#1-端口扫描\" class=\"headerlink\" title=\"1. 端口扫描\"></a>1. 端口扫描</h5><p>netcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">nc -z -v -n 192.168.63.35 21-25</span></span><br></pre></td></tr></table></figure>\n<p>这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。<br>-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换<br>-v 表示详细输出<br>-n 表示netcat不使用DNS反向查询IP地址的域名</p>\n<h5 id=\"2-文件传输\"><a href=\"#2-文件传输\" class=\"headerlink\" title=\"2. 文件传输\"></a>2. 文件传输</h5><p>Linux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &lt; file.txt            <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 &gt; file.txt   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。</p>\n<p>也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A&lt;---B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &gt; file.txt             <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 &lt; file.txt  <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-目录传输\"><a href=\"#3-目录传输\" class=\"headerlink\" title=\"3. 目录传输\"></a>3. 目录传输</h5><p>发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | nc -l 8000           <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | tar -xvf -     <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。</p>\n<p>如果想要节省带宽，可以通过压缩工具压缩后再进行发送</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | bzip2 -z | nc -l 8000         <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用tar归档和bzip2压缩和解压</p>\n<h5 id=\"4-网络加密传输\"><a href=\"#4-网络加密传输\" class=\"headerlink\" title=\"4. 网络加密传输\"></a>4. 网络加密传输</h5><p>在发送数据之前，可以使用mcrypt工具保证数据安全</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb &gt; file.txt    <span class=\"comment\"># 客户端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mcrypt --flush --bare -F -q -m ecb &lt; file.txt | nc -l 8000   <span class=\"comment\">#服务端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。</p>\n<p>（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）</p>\n<h5 id=\"5-视频流\"><a href=\"#5-视频流\" class=\"headerlink\" title=\"5. 视频流\"></a>5. 视频流</h5><p>个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat video.mp4 | nc -l 8000</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令netcat从socket中读取数据并重定向到mplayer中</p>\n<h5 id=\"6-克隆一个设备\"><a href=\"#6-克隆一个设备\" class=\"headerlink\" title=\"6. 克隆一个设备\"></a>6. 克隆一个设备</h5><p>如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/sda | nc -l 8000            <span class=\"comment\"># server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 | dd of=/dev/sda   <span class=\"comment\"># client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>dd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Linux命令详解-netcat\"><a href=\"#Linux命令详解-netcat\" class=\"headerlink\" title=\"Linux命令详解-netcat\"></a>Linux命令详解-netcat</h3><p>netcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。</p>\n<h4 id=\"常用netcat命令示例\"><a href=\"#常用netcat命令示例\" class=\"headerlink\" title=\"常用netcat命令示例\"></a>常用netcat命令示例</h4><h5 id=\"1-端口扫描\"><a href=\"#1-端口扫描\" class=\"headerlink\" title=\"1. 端口扫描\"></a>1. 端口扫描</h5><p>netcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">nc -z -v -n 192.168.63.35 21-25</span></span><br></pre></td></tr></table></figure>\n<p>这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。<br>-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换<br>-v 表示详细输出<br>-n 表示netcat不使用DNS反向查询IP地址的域名</p>\n<h5 id=\"2-文件传输\"><a href=\"#2-文件传输\" class=\"headerlink\" title=\"2. 文件传输\"></a>2. 文件传输</h5><p>Linux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &lt; file.txt            <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 &gt; file.txt   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。</p>\n<p>也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A&lt;---B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &gt; file.txt             <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 &lt; file.txt  <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-目录传输\"><a href=\"#3-目录传输\" class=\"headerlink\" title=\"3. 目录传输\"></a>3. 目录传输</h5><p>发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | nc -l 8000           <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | tar -xvf -     <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。</p>\n<p>如果想要节省带宽，可以通过压缩工具压缩后再进行发送</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | bzip2 -z | nc -l 8000         <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用tar归档和bzip2压缩和解压</p>\n<h5 id=\"4-网络加密传输\"><a href=\"#4-网络加密传输\" class=\"headerlink\" title=\"4. 网络加密传输\"></a>4. 网络加密传输</h5><p>在发送数据之前，可以使用mcrypt工具保证数据安全</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb &gt; file.txt    <span class=\"comment\"># 客户端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mcrypt --flush --bare -F -q -m ecb &lt; file.txt | nc -l 8000   <span class=\"comment\">#服务端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。</p>\n<p>（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）</p>\n<h5 id=\"5-视频流\"><a href=\"#5-视频流\" class=\"headerlink\" title=\"5. 视频流\"></a>5. 视频流</h5><p>个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat video.mp4 | nc -l 8000</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令netcat从socket中读取数据并重定向到mplayer中</p>\n<h5 id=\"6-克隆一个设备\"><a href=\"#6-克隆一个设备\" class=\"headerlink\" title=\"6. 克隆一个设备\"></a>6. 克隆一个设备</h5><p>如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/sda | nc -l 8000            <span class=\"comment\"># server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 | dd of=/dev/sda   <span class=\"comment\"># client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>dd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckdg3ihsj0000g8fwbbqvfcmy","category_id":"ckdg3ihsu0001g8fwfls826ty","_id":"ckdg3ihsy0004g8fwek3843r1"},{"post_id":"ckdemilyu00043ofw2co40s2g","category_id":"ckdg3ihta0005g8fwarb7apqi","_id":"ckdg3ihtd0007g8fw1ukc3gfm"},{"post_id":"ckdemilx100013ofwetfy5peg","category_id":"ckdg3ihta0005g8fwarb7apqi","_id":"ckdg3ihtd0009g8fw4hvl234b"},{"post_id":"ckdemilws00003ofw0yew7de4","category_id":"ckdg3ihta0005g8fwarb7apqi","_id":"ckdg3ihtd000ag8fwce3s4uk6"},{"post_id":"ckdemilxs00023ofwahpae8u8","category_id":"ckdg3ihta0005g8fwarb7apqi","_id":"ckdg3ihtd000bg8fwf2zuh76h"},{"post_id":"ckdemily100033ofw08b73pv0","category_id":"ckdg3ihta0005g8fwarb7apqi","_id":"ckdg3ihte000cg8fwdqtm9cm3"}],"PostTag":[{"post_id":"ckdemilws00003ofw0yew7de4","tag_id":"ckdeml9sh00063ofw9rgfaf9u","_id":"ckdeml9si00073ofw6rztde3u"},{"post_id":"ckdemilxs00023ofwahpae8u8","tag_id":"ckdeml9sh00063ofw9rgfaf9u","_id":"ckdemmhgr000d3ofwhyqf77fr"},{"post_id":"ckdemily100033ofw08b73pv0","tag_id":"ckdeml9sh00063ofw9rgfaf9u","_id":"ckdemmvkx000g3ofwhhnudck6"},{"post_id":"ckdemilx100013ofwetfy5peg","tag_id":"ckdeml9sh00063ofw9rgfaf9u","_id":"ckdemoede00004jfwcqsg4mvp"},{"post_id":"ckdemilyu00043ofw2co40s2g","tag_id":"ckdeml9sh00063ofw9rgfaf9u","_id":"ckdempbhg00034jfw7fo262lr"},{"post_id":"ckdg3ihsj0000g8fwbbqvfcmy","tag_id":"ckdg3ihsw0002g8fwcg4pfrsw","_id":"ckdg3ihsy0003g8fw5gvi93p8"}],"Tag":[{"name":"jQuery","_id":"ckdelzdeg0003zyfw4g8zfwuy"},{"name":"表格","_id":"ckdelzdeh0004zyfw2r3c8xxm"},{"name":"表单验证","_id":"ckdelzdeh0006zyfwcidkfry6"},{"name":"Testing","_id":"ckdem4p7i00010ufw8aff1jwf"},{"name":"Another Tag","_id":"ckdem4p7j00020ufw5k68clos"},{"name":"汇编","_id":"ckdeml9sh00063ofw9rgfaf9u"},{"name":"编程语言","_id":"ckdemllai000b3ofwfg8j1g7k"},{"name":"Linux","_id":"ckdg3ihsw0002g8fwcg4pfrsw"}]}}