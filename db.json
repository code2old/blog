{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1595256238145},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1595256238145},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1595256238145},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1595256238145},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1595256238145},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1595256238145},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1595256238145},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1595256238145},{"_id":"themes/next/_config.yml","hash":"8d27fd99da5d67a854506bc6fdf82dd24033960a","modified":1597074598162},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1595256238145},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1595256238145},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1595256238149},{"_id":"source/_posts/linux-nc.md","hash":"878d209d5b8133126643e16c72964fb36e1e4933","modified":1597156452424},{"_id":"source/about/index.md","hash":"674539ee9ec38015021570c834305d9fec461569","modified":1596465630113},{"_id":"source/categories/index.md","hash":"8f3ad02d53b10b520042a734839215dd5eef1974","modified":1596465174938},{"_id":"source/tags/index.md","hash":"098fd857e1a8965bb7afa448922a2de012463e45","modified":1596465119699},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1595256238145},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1595256238145},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1595256238145},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1595256238145},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1595256238145},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1595256238145},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1595256238145},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1595256238145},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1595256238145},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1595256238145},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1595256238145},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1595256238145},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1595256238145},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1595256238145},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1595256238145},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1595256238145},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1595256238145},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1595256238145},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1595256238145},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1595256238145},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1595256238145},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1595256238145},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1595256238145},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1595256238145},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1595256238145},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1595256238145},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1595256238145},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1595256238145},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1595256238145},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1595256238145},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1595256238145},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1595256238145},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1595256238145},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1595256238145},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1595256238145},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1595256238145},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1595256238149},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1595256238149},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1595256238149},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1595256238149},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1595256238149},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1595256238149},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1595256238149},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1595256238149},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1595256238149},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1595256238149},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1595256238149},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1595256238149},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1595256238149},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1595256238149},{"_id":"source/_posts/assembly/1-basic.md","hash":"bf99a3c6413dd81a7638b9682cf26511d8355743","modified":1597503985450},{"_id":"source/_posts/assembly/2-register(CPU).md","hash":"f35f2d0f7d182d6ff164d8b31e5866f2996ed2e8","modified":1597503979649},{"_id":"source/_posts/assembly/3-register(Memory).md","hash":"6bbe9f13e36dda9359cbed1a2d3b3a17e0ff2ea8","modified":1597503979695},{"_id":"source/_posts/assembly/4-first-program.md","hash":"915b8348d8b24d6d9ca32f4afdc20db2b20adbc6","modified":1597503979763},{"_id":"source/_posts/assembly/5-[bx]-and-loop.md","hash":"e754530f405a0db7e59c7ce40e003ae622cc82eb","modified":1597503979839},{"_id":"source/_posts/assembly/6-multi-segment.md","hash":"50aa9b3abd96a192017039685382d5e32ab94d71","modified":1597503979888},{"_id":"source/_posts/assembly/7-address-locate.md","hash":"0ebed15eac6bbd574d35b911caede768ded9a139","modified":1597503979931},{"_id":"source/_posts/assembly/9-jmp.md","hash":"e99b49b6d43e667a0a85fbbfabff62b17ec27cb1","modified":1597503980027},{"_id":"source/_posts/assembly/8-two-question-about-data-handle.md","hash":"bf30860c43ba8345a0e0ee1288b7703e99198a35","modified":1597503979984},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1595256238145},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1595256238145},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1595256238145},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1595256238145},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1595256238145},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1595256238145},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1595256238145},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1595256238149},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1595256238149},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1595256238149},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1595256238149},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1595256238149},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1595256238149},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1595256238149},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1595256238149},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1595256238149},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1595256238149},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1595256238149},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1595256238149},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1595256238149},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1595256238149},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1595256238149},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1595256238149},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1595256238149},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1595256238149},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1595256238149},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1595256238149},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1595256238149},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1595256238149},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1595256238149},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1595256238149},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1595256238149},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1595256238149},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1595256238149},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1595256238149},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1595256238149},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1595256238149},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1595256238149},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1595256238149},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1595256238149},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1595256238149},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1595256238149},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1595256238149},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1595256238149},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1595256238153},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1595256238153},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1595256238153},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1595256238153},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1595256238153},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1595256238153},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1595256238153},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1595256238153},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1595256238153},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1595256238153},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1595256238153},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1595256238153},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1595256238153},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1595256238153},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1595256238153},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1595256238153},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1595256238153},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1595256238157},{"_id":"source/_posts/assembly/images/app-encoding.ascii.png","hash":"6e84fc4805b52cd10070d03d9f7378f82333419d","modified":1597153833386},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1595256238149},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1595256238149},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1595256238149},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1595256238149},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1595256238149},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1595256238149},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1595256238149},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1595256238149},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1595256238149},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1595256238149},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1595256238149},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1595256238149},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1595256238149},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1595256238149},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1595256238149},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1595256238149},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1595256238149},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1595256238149},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1595256238149},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1595256238149},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1595256238153},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1595256238153},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1595256238153},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1595256238153},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1595256238153},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1595256238157},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1595256238157},{"_id":"source/_posts/assembly/images/assembly_2_6.png","hash":"cd4a2eb6d9fa9ebcb47aa0f473740d5027fee749","modified":1594913650888},{"_id":"source/_posts/assembly/images/assembly_2_10.png","hash":"d47022c312c334079db8ee04b471e6d537c91745","modified":1595052468507},{"_id":"source/_posts/assembly/images/assembly_8_2.png","hash":"88d6386df835f2157df4ba6efbe3c1efbd42ac3c","modified":1597241739446},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1595256238153},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1595256238153},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1595256238157},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1595256238157},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1595256238149},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1595256238153},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1595256238153},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1595256238153},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1595256238153},{"_id":"public/categories/index.html","hash":"1ce676d575259532a0700375a119313f8c52f0b6","modified":1597678337313},{"_id":"public/about/index.html","hash":"6b012750669bead7d2c5c515d53f9b9aebd21033","modified":1597678337313},{"_id":"public/tags/index.html","hash":"a47c209d1b5119d65069d142cb62210d19e5aac5","modified":1597678337313},{"_id":"public/archives/index.html","hash":"63f8b2e3489a9416d84459a16153600b4cde2b42","modified":1597678337313},{"_id":"public/archives/2020/index.html","hash":"12cbec7d964d04cfcb56cfb54ca9318431c4ea88","modified":1597678337313},{"_id":"public/archives/2020/08/index.html","hash":"7275f4a42632a8ec2be54a6c7de334fed889ef87","modified":1597678337313},{"_id":"public/tags/Linux/index.html","hash":"4332b6a4c6a551b42020a4ba48631cbafdb50c40","modified":1597678337313},{"_id":"public/tags/汇编/index.html","hash":"24091d6c6c1ebf224219ca40a81b7fa9f7bf874b","modified":1597678337313},{"_id":"public/categories/Linux命令详解/index.html","hash":"d61564d6b1b644ccfb15508bee21edbdc7f59e7c","modified":1597678337313},{"_id":"public/categories/汇编语言学习/index.html","hash":"d53b308857a15f4a9cbf399eaf5213419c43bba5","modified":1597678337313},{"_id":"public/assembly/1-basic/index.html","hash":"c18162cc25e3fe3f413500afe3c29745c7c5d7d9","modified":1597678337313},{"_id":"public/assembly/9-jmp/index.html","hash":"7168fc180aaa4e49444a96c1e4765f4b298d97ed","modified":1597678337313},{"_id":"public/assembly/8-two-question-about-data-handle/index.html","hash":"b2e5654bcce4d465fb94a02956d4a8df74e664cb","modified":1597678337313},{"_id":"public/assembly/7-address-locate/index.html","hash":"5b74db0151f6a2ce6944b619a41275488e807aa2","modified":1597678337313},{"_id":"public/assembly/6-multi-segment/index.html","hash":"b7ba55a1d1fb53095674397e09e5ea8148a10b83","modified":1597678337313},{"_id":"public/assembly/5-[bx]-and-loop/index.html","hash":"01b1006a6a9fbb2be785a9e99a6d1f3fce952321","modified":1597678337313},{"_id":"public/assembly/4-first-program/index.html","hash":"140ea4c66b54e5260ddb2a5013e321d9d144bfbc","modified":1597678337313},{"_id":"public/assembly/3-register(Memory)/index.html","hash":"c90c8fc8f7ebe8d884edf83b1d0942360a835d8f","modified":1597678337313},{"_id":"public/assembly/2-register(CPU)/index.html","hash":"490e8787f03a022e4d8d496d3efbf315ead652aa","modified":1597678337313},{"_id":"public/linux-nc/index.html","hash":"504c5f3c6491d8db6b07521ba94a5f421efdda12","modified":1597504135568},{"_id":"public/index.html","hash":"0bbbf4119f5cb1c2ba66b1bcacc5b6d95ccbe944","modified":1597678337313},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1597504135568},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1597504135568},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1597504135568},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1597504135568},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1597504135568},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1597504135568},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1597504135568},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1597504135568},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1597504135568},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1597504135568},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1597504135568},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1597504135568},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1597504135568},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1597504135568},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1597504135568},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1597504135568},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1597504135568},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1597504135568},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1597504135568},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1597504135568},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1597504135568},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1597504135568},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1597504135568},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1597504135568},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1597504135568},{"_id":"public/css/main.css","hash":"63db0c49935adf462d33606d29b8cc1da92c5a0f","modified":1597504135568},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1597504135568},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1597504135568},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1597504135568},{"_id":"source/_posts/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1597504429380},{"_id":"source/_posts/assembly/10-call-and-ret.md","hash":"4403688694faf2a5afdb22d37b714357fb140e67","modified":1597678330862},{"_id":"source/_posts/linux/linux-nc.md","hash":"878d209d5b8133126643e16c72964fb36e1e4933","modified":1597504445661},{"_id":"public/index/index.html","hash":"8793772a242c2bcbdcf2fbd337e86396f6a4cfc3","modified":1597678337313},{"_id":"public/assembly/10-call-and-ret/index.html","hash":"b2a5ca73bc61c4f3e9296eb10f0391929f721d5e","modified":1597678337313},{"_id":"public/linux/linux-nc/index.html","hash":"774eb16fafce32460b43f2fff033e8ae7cfecb53","modified":1597678337313},{"_id":"public/page/2/index.html","hash":"7d93e226c79258be02fe3b824207c135e969442c","modified":1597678337313}],"Category":[{"name":"Linux命令详解","_id":"ckdvsps6s0003q1fw3m02asa4"},{"name":"汇编语言学习","_id":"ckdvsps8i000aq1fway2jdbno"}],"Data":[],"Page":[{"title":"categories","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ncomments: false\n---","date":"2020-08-03T14:32:54.935Z","updated":"2020-08-03T14:32:54.938Z","path":"categories/index.html","layout":"page","_id":"ckdvsps6p0001q1fw3hcv5841","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About me","comments":0,"_content":"\n博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。\n\nGithub: @code2old\n\nEmail: gcb_93@163.com\n","source":"about/index.md","raw":"---\ntitle: About me\ncomments: false\n---\n\n博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。\n\nGithub: @code2old\n\nEmail: gcb_93@163.com\n","date":"2020-08-03T14:40:30.110Z","updated":"2020-08-03T14:40:30.113Z","path":"about/index.html","layout":"page","_id":"ckdvsps6r0002q1fwcwda7y6y","content":"<p>博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。</p>\n<p>Github: @code2old</p>\n<p>Email: <a href=\"mailto:gcb_93@163.com\">gcb_93@163.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>博客主要记录个人学习的过程，文章难免出错，所有的文章都存在修改的可能性，其中如有任何错误或者关于技术问题的讨论，欢迎留言或邮件与我交流。</p>\n<p>Github: @code2old</p>\n<p>Email: <a href=\"mailto:gcb_93@163.com\">gcb_93@163.com</a></p>\n"},{"title":"tags","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ncomments: false\n---","date":"2020-08-03T14:31:59.695Z","updated":"2020-08-03T14:31:59.699Z","path":"tags/index.html","layout":"page","_id":"ckdvsps7w0007q1fw2bkecx78","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"汇编语言-基础知识","data":"2020-08-01T12:00:00.000Z","updated":"2020-08-01T12:00:00.000Z","_content":"\n### 第一章 基础知识\n\n#### 机器语言\n\n机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n#### 汇编语言的产生\n\n汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。\n```\n操作：寄存器BX的内容送到AX中\n机器指令：1000100111011000\n汇编指令：mov ax, bx\n```\n将汇编指令转换成机器指令的翻译程序就被称为编译器。\n\n#### 汇编语言的组成\n\n汇编语言由以下3类指令组成：\n* 汇编指令：机器码的助记符，有对应的机器码\n* 伪指令：没有对应的机器码，由编译器执行，计算机并不执行\n* 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。\n汇编语言的核心是机器指令，它决定了汇编语言的特性\n\n<!-- more -->\n\n#### 存储器\n\nCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。\n\n#### 指令和数据\n\n指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。\n\n#### 存储单元\n\n存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。\n\n#### CPU对存储器的读写\n\nCPU要想进行数据的读写，必须和外部器件进行3类信息交换：\n* 存储单元的地址（地址信息）\n* 器件的选择，读或写的命令（控制信息）\n* 读或写的书写（数据信息）\n计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线\n\n#### 地址总线\n\nCPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址\n\n#### 数据总线\n\nCPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。\n\n#### 控制总线\n\nCPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。\n\n#### 内存地址空间概述\n\n##### 主板\n\n##### 接口卡\n\nCPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作\n\n#### 各类存储器芯片\n\n存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：\n* 随机存储器\n* 装有BIOS（Basic Input/Output System）的ROM\n* 接口卡上的RAM\n\n#### 内存地址空间\n\n所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：\n\n```\n00000 |————————————————————|\n      |   主存储器地址空间  |\n      |      (RAM)         |\n9FFFF |____________________|\nA0000 |                    |\n      |    显存地址空间     |\nBFFFF |____________________|\nC0000 |                    |\n      |   各类ROM地址空间   | \nFFFFF |____________________|   \n```\n\n#### 小结\n\n* 汇编指令是机器指令的助记符，同机器指令一一对应\n* 每一种CPU都有自己的汇编指令集\n* CPU直接使用的信息存放在存储器中\n* 在存储中指令和数据没有任何区别，都是二进制信息\n* 存储单元从0开始顺序编号\n* 一个存储单元可以存储8个bit，即8位二进制数\n* 1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB\n* 每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：\n    * 地址总线的宽度决定了CPU的寻址能力\n    * 数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量\n    * 控制总线的宽度决定了CPU对系统中其它器件的控制能力\n\n对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n","source":"_posts/assembly/1-basic.md","raw":"---\ntitle: 汇编语言-基础知识\ndata: 2020-08-01 20:00:00\nupdated: 2020-08-01 20:00:00\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第一章 基础知识\n\n#### 机器语言\n\n机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n#### 汇编语言的产生\n\n汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。\n```\n操作：寄存器BX的内容送到AX中\n机器指令：1000100111011000\n汇编指令：mov ax, bx\n```\n将汇编指令转换成机器指令的翻译程序就被称为编译器。\n\n#### 汇编语言的组成\n\n汇编语言由以下3类指令组成：\n* 汇编指令：机器码的助记符，有对应的机器码\n* 伪指令：没有对应的机器码，由编译器执行，计算机并不执行\n* 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。\n汇编语言的核心是机器指令，它决定了汇编语言的特性\n\n<!-- more -->\n\n#### 存储器\n\nCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。\n\n#### 指令和数据\n\n指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。\n\n#### 存储单元\n\n存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。\n\n#### CPU对存储器的读写\n\nCPU要想进行数据的读写，必须和外部器件进行3类信息交换：\n* 存储单元的地址（地址信息）\n* 器件的选择，读或写的命令（控制信息）\n* 读或写的书写（数据信息）\n计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线\n\n#### 地址总线\n\nCPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址\n\n#### 数据总线\n\nCPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。\n\n#### 控制总线\n\nCPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。\n\n#### 内存地址空间概述\n\n##### 主板\n\n##### 接口卡\n\nCPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作\n\n#### 各类存储器芯片\n\n存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：\n* 随机存储器\n* 装有BIOS（Basic Input/Output System）的ROM\n* 接口卡上的RAM\n\n#### 内存地址空间\n\n所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：\n\n```\n00000 |————————————————————|\n      |   主存储器地址空间  |\n      |      (RAM)         |\n9FFFF |____________________|\nA0000 |                    |\n      |    显存地址空间     |\nBFFFF |____________________|\nC0000 |                    |\n      |   各类ROM地址空间   | \nFFFFF |____________________|   \n```\n\n#### 小结\n\n* 汇编指令是机器指令的助记符，同机器指令一一对应\n* 每一种CPU都有自己的汇编指令集\n* CPU直接使用的信息存放在存储器中\n* 在存储中指令和数据没有任何区别，都是二进制信息\n* 存储单元从0开始顺序编号\n* 一个存储单元可以存储8个bit，即8位二进制数\n* 1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB\n* 每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：\n    * 地址总线的宽度决定了CPU的寻址能力\n    * 数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量\n    * 控制总线的宽度决定了CPU对系统中其它器件的控制能力\n\n对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n","slug":"assembly/1-basic","published":1,"date":"2020-08-15T15:06:26.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8g0008q1fw0v994c76","content":"<h3 id=\"第一章-基础知识\"><a href=\"#第一章-基础知识\" class=\"headerlink\" title=\"第一章 基础知识\"></a>第一章 基础知识</h3><h4 id=\"机器语言\"><a href=\"#机器语言\" class=\"headerlink\" title=\"机器语言\"></a>机器语言</h4><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>\n<h4 id=\"汇编语言的产生\"><a href=\"#汇编语言的产生\" class=\"headerlink\" title=\"汇编语言的产生\"></a>汇编语言的产生</h4><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作：寄存器BX的内容送到AX中</span><br><span class=\"line\">机器指令：1000100111011000</span><br><span class=\"line\">汇编指令：mov ax, bx</span><br></pre></td></tr></table></figure>\n<p>将汇编指令转换成机器指令的翻译程序就被称为编译器。</p>\n<h4 id=\"汇编语言的组成\"><a href=\"#汇编语言的组成\" class=\"headerlink\" title=\"汇编语言的组成\"></a>汇编语言的组成</h4><p>汇编语言由以下3类指令组成：</p>\n<ul>\n<li>汇编指令：机器码的助记符，有对应的机器码</li>\n<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>\n<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。<br>汇编语言的核心是机器指令，它决定了汇编语言的特性</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h4><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。</p>\n<h4 id=\"指令和数据\"><a href=\"#指令和数据\" class=\"headerlink\" title=\"指令和数据\"></a>指令和数据</h4><p>指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。</p>\n<h4 id=\"存储单元\"><a href=\"#存储单元\" class=\"headerlink\" title=\"存储单元\"></a>存储单元</h4><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。</p>\n<h4 id=\"CPU对存储器的读写\"><a href=\"#CPU对存储器的读写\" class=\"headerlink\" title=\"CPU对存储器的读写\"></a>CPU对存储器的读写</h4><p>CPU要想进行数据的读写，必须和外部器件进行3类信息交换：</p>\n<ul>\n<li>存储单元的地址（地址信息）</li>\n<li>器件的选择，读或写的命令（控制信息）</li>\n<li>读或写的书写（数据信息）<br>计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线</li>\n</ul>\n<h4 id=\"地址总线\"><a href=\"#地址总线\" class=\"headerlink\" title=\"地址总线\"></a>地址总线</h4><p>CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址</p>\n<h4 id=\"数据总线\"><a href=\"#数据总线\" class=\"headerlink\" title=\"数据总线\"></a>数据总线</h4><p>CPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。</p>\n<h4 id=\"控制总线\"><a href=\"#控制总线\" class=\"headerlink\" title=\"控制总线\"></a>控制总线</h4><p>CPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。</p>\n<h4 id=\"内存地址空间概述\"><a href=\"#内存地址空间概述\" class=\"headerlink\" title=\"内存地址空间概述\"></a>内存地址空间概述</h4><h5 id=\"主板\"><a href=\"#主板\" class=\"headerlink\" title=\"主板\"></a>主板</h5><h5 id=\"接口卡\"><a href=\"#接口卡\" class=\"headerlink\" title=\"接口卡\"></a>接口卡</h5><p>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</p>\n<h4 id=\"各类存储器芯片\"><a href=\"#各类存储器芯片\" class=\"headerlink\" title=\"各类存储器芯片\"></a>各类存储器芯片</h4><p>存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：</p>\n<ul>\n<li>随机存储器</li>\n<li>装有BIOS（Basic Input/Output System）的ROM</li>\n<li>接口卡上的RAM</li>\n</ul>\n<h4 id=\"内存地址空间\"><a href=\"#内存地址空间\" class=\"headerlink\" title=\"内存地址空间\"></a>内存地址空间</h4><p>所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 |————————————————————|</span><br><span class=\"line\">      |   主存储器地址空间  |</span><br><span class=\"line\">      |      (RAM)         |</span><br><span class=\"line\">9FFFF |____________________|</span><br><span class=\"line\">A0000 |                    |</span><br><span class=\"line\">      |    显存地址空间     |</span><br><span class=\"line\">BFFFF |____________________|</span><br><span class=\"line\">C0000 |                    |</span><br><span class=\"line\">      |   各类ROM地址空间   | </span><br><span class=\"line\">FFFFF |____________________|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>\n<li>每一种CPU都有自己的汇编指令集</li>\n<li>CPU直接使用的信息存放在存储器中</li>\n<li>在存储中指令和数据没有任何区别，都是二进制信息</li>\n<li>存储单元从0开始顺序编号</li>\n<li>一个存储单元可以存储8个bit，即8位二进制数</li>\n<li>1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB</li>\n<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n</ul>\n<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"第一章-基础知识\"><a href=\"#第一章-基础知识\" class=\"headerlink\" title=\"第一章 基础知识\"></a>第一章 基础知识</h3><h4 id=\"机器语言\"><a href=\"#机器语言\" class=\"headerlink\" title=\"机器语言\"></a>机器语言</h4><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>\n<h4 id=\"汇编语言的产生\"><a href=\"#汇编语言的产生\" class=\"headerlink\" title=\"汇编语言的产生\"></a>汇编语言的产生</h4><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作：寄存器BX的内容送到AX中</span><br><span class=\"line\">机器指令：1000100111011000</span><br><span class=\"line\">汇编指令：mov ax, bx</span><br></pre></td></tr></table></figure>\n<p>将汇编指令转换成机器指令的翻译程序就被称为编译器。</p>\n<h4 id=\"汇编语言的组成\"><a href=\"#汇编语言的组成\" class=\"headerlink\" title=\"汇编语言的组成\"></a>汇编语言的组成</h4><p>汇编语言由以下3类指令组成：</p>\n<ul>\n<li>汇编指令：机器码的助记符，有对应的机器码</li>\n<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>\n<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。<br>汇编语言的核心是机器指令，它决定了汇编语言的特性</li>\n</ul>","more":"<h4 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h4><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。</p>\n<h4 id=\"指令和数据\"><a href=\"#指令和数据\" class=\"headerlink\" title=\"指令和数据\"></a>指令和数据</h4><p>指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。</p>\n<h4 id=\"存储单元\"><a href=\"#存储单元\" class=\"headerlink\" title=\"存储单元\"></a>存储单元</h4><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。</p>\n<h4 id=\"CPU对存储器的读写\"><a href=\"#CPU对存储器的读写\" class=\"headerlink\" title=\"CPU对存储器的读写\"></a>CPU对存储器的读写</h4><p>CPU要想进行数据的读写，必须和外部器件进行3类信息交换：</p>\n<ul>\n<li>存储单元的地址（地址信息）</li>\n<li>器件的选择，读或写的命令（控制信息）</li>\n<li>读或写的书写（数据信息）<br>计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线</li>\n</ul>\n<h4 id=\"地址总线\"><a href=\"#地址总线\" class=\"headerlink\" title=\"地址总线\"></a>地址总线</h4><p>CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址</p>\n<h4 id=\"数据总线\"><a href=\"#数据总线\" class=\"headerlink\" title=\"数据总线\"></a>数据总线</h4><p>CPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。</p>\n<h4 id=\"控制总线\"><a href=\"#控制总线\" class=\"headerlink\" title=\"控制总线\"></a>控制总线</h4><p>CPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。</p>\n<h4 id=\"内存地址空间概述\"><a href=\"#内存地址空间概述\" class=\"headerlink\" title=\"内存地址空间概述\"></a>内存地址空间概述</h4><h5 id=\"主板\"><a href=\"#主板\" class=\"headerlink\" title=\"主板\"></a>主板</h5><h5 id=\"接口卡\"><a href=\"#接口卡\" class=\"headerlink\" title=\"接口卡\"></a>接口卡</h5><p>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</p>\n<h4 id=\"各类存储器芯片\"><a href=\"#各类存储器芯片\" class=\"headerlink\" title=\"各类存储器芯片\"></a>各类存储器芯片</h4><p>存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：</p>\n<ul>\n<li>随机存储器</li>\n<li>装有BIOS（Basic Input/Output System）的ROM</li>\n<li>接口卡上的RAM</li>\n</ul>\n<h4 id=\"内存地址空间\"><a href=\"#内存地址空间\" class=\"headerlink\" title=\"内存地址空间\"></a>内存地址空间</h4><p>所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 |————————————————————|</span><br><span class=\"line\">      |   主存储器地址空间  |</span><br><span class=\"line\">      |      (RAM)         |</span><br><span class=\"line\">9FFFF |____________________|</span><br><span class=\"line\">A0000 |                    |</span><br><span class=\"line\">      |    显存地址空间     |</span><br><span class=\"line\">BFFFF |____________________|</span><br><span class=\"line\">C0000 |                    |</span><br><span class=\"line\">      |   各类ROM地址空间   | </span><br><span class=\"line\">FFFFF |____________________|</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>\n<li>每一种CPU都有自己的汇编指令集</li>\n<li>CPU直接使用的信息存放在存储器中</li>\n<li>在存储中指令和数据没有任何区别，都是二进制信息</li>\n<li>存储单元从0开始顺序编号</li>\n<li>一个存储单元可以存储8个bit，即8位二进制数</li>\n<li>1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB</li>\n<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：<ul>\n<li>地址总线的宽度决定了CPU的寻址能力</li>\n<li>数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量</li>\n<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>\n</ul>\n</li>\n</ul>\n<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>"},{"title":"汇编语言-寄存器（CPU工作原理）","data":"2020-08-01T12:10:00.000Z","updated":"2020-08-01T12:10:00.000Z","_content":"\n### 第二章 寄存器（CPU工作原理）\n\n内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。\n\n汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。\n\n8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。\n\n#### 通用寄存器\n\n8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：\n\n* AX可分为AH和AL\n* BX可分为BH和BL\n* CX可分为CH和CL\n* DX可分为DH和DL\n\n以AX为例，8086CPU的16位寄存器逻辑结构如下：\n\n```\n|—————————————————————————————————AX——————————————————————————————————|\n| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n|———————————————AH————————————————————|—————————————AL————————————————|\n| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n\n```\n\n<!-- more -->\n\n#### 字在存储器中的存储\n\n出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：\n\n* 字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中\n* 字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节\n\n#### 几条汇编指令\n\n汇编指令举例：\n\n|汇编指令   |控制CPU完成的操作     |用高级语言的语法描述|\n|:---------|:-------------------------------|:-------|\n|mov ax, 18|将18送入寄存器AX                 |AX=18   |\n|mov ah, 78|将78送入寄存器AH                 |AH=18   |\n|add ax,  8|将寄存器AX中的数值加上8           |AX=AX+8 |\n|mov ax, bx|将寄存器BX中的数据送入寄存器AX    |AX=BX   |\n|add ax, bx|将AX和BX中的数值相加，结果存在AX中|AX=AX+BX|\n|||\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。\n\n#### 物理地址\n\nCPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。\n\n#### 16位结构的CPU\n\n16位结构描述了CPU下面的几个结构特性：\n\n* 运算器一次最多可以处理16位数据\n* 寄存器最大位宽为16位\n* 寄存器和运算器之间的通路为16位\n\n也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。\n\n#### 8086CPU给出物理地址的方法\n\n8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。\n\n8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n当8086CPU要读写内存时：\n\n* CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址\n* 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件\n* 地址加法器通过内部总线将20位物理地址送入输入输出控制电路\n* 输入输出控制电路将20位物理地址送入地址总线\n* 20位物理地址被地址总线传送到存储器\n\n地址加法器采用**物理地址=段地址x16+偏移地址**的方法用段地址和偏移地址合成物理地址\n\n#### “段地址x16+偏移地址=物理地址”的本质含义\n\n“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。\n\n#### 段的概念\n\n内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。\n\n#### 段寄存器\n\n8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。\n\n#### CS和IP\n\nCS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。\n\n8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n8086CPU的工作过程简要描述如下：\n\n* 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n* IP=IP+读取指令的长度，从而指向下一条指令\n* 执行指令，转到步骤1，重复这个过程\n\n在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。\n\n在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。\n\n#### 修改CS、IP的指令\n\n8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。\n\n若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：\n\n```\njmp 2AE3:3 #执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令\njmp 2:0B16 #执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令\n```\n\njmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP\n\n若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：\n\n```\njmp ax, 指令执行前：ax=1000H，CS=2000H，IP=0003H\n        指令执行后：ax=1000H，CS=2000H，IP=1000H\njmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H\n        指令执行后：ax=0B16H，CS=2000H，IP=0B16H\n```\n\n指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令\n\n#### 代码段\n\n将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。\n\n要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。\n\n#### 小结\n\n* 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址\n* CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n* 8086CPU的工作过程\n    * 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\n    * IP指向下一条指令；\n    * 执行指令。（转到步骤（1），重复这个过程）\n* 8086CPU提供转移指令修改CS、IP的内容","source":"_posts/assembly/2-register(CPU).md","raw":"---\ntitle: 汇编语言-寄存器（CPU工作原理）\ndata: 2020-08-01 20:10:00\nupdated: 2020-08-01 20:10:00\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第二章 寄存器（CPU工作原理）\n\n内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。\n\n汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。\n\n8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。\n\n#### 通用寄存器\n\n8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：\n\n* AX可分为AH和AL\n* BX可分为BH和BL\n* CX可分为CH和CL\n* DX可分为DH和DL\n\n以AX为例，8086CPU的16位寄存器逻辑结构如下：\n\n```\n|—————————————————————————————————AX——————————————————————————————————|\n| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n|———————————————AH————————————————————|—————————————AL————————————————|\n| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|\n\n```\n\n<!-- more -->\n\n#### 字在存储器中的存储\n\n出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：\n\n* 字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中\n* 字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节\n\n#### 几条汇编指令\n\n汇编指令举例：\n\n|汇编指令   |控制CPU完成的操作     |用高级语言的语法描述|\n|:---------|:-------------------------------|:-------|\n|mov ax, 18|将18送入寄存器AX                 |AX=18   |\n|mov ah, 78|将78送入寄存器AH                 |AH=18   |\n|add ax,  8|将寄存器AX中的数值加上8           |AX=AX+8 |\n|mov ax, bx|将寄存器BX中的数据送入寄存器AX    |AX=BX   |\n|add ax, bx|将AX和BX中的数值相加，结果存在AX中|AX=AX+BX|\n|||\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。\n\n#### 物理地址\n\nCPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。\n\n#### 16位结构的CPU\n\n16位结构描述了CPU下面的几个结构特性：\n\n* 运算器一次最多可以处理16位数据\n* 寄存器最大位宽为16位\n* 寄存器和运算器之间的通路为16位\n\n也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。\n\n#### 8086CPU给出物理地址的方法\n\n8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。\n\n8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n当8086CPU要读写内存时：\n\n* CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址\n* 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件\n* 地址加法器通过内部总线将20位物理地址送入输入输出控制电路\n* 输入输出控制电路将20位物理地址送入地址总线\n* 20位物理地址被地址总线传送到存储器\n\n地址加法器采用**物理地址=段地址x16+偏移地址**的方法用段地址和偏移地址合成物理地址\n\n#### “段地址x16+偏移地址=物理地址”的本质含义\n\n“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。\n\n#### 段的概念\n\n内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。\n\n#### 段寄存器\n\n8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。\n\n#### CS和IP\n\nCS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。\n\n8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n8086CPU的工作过程简要描述如下：\n\n* 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n* IP=IP+读取指令的长度，从而指向下一条指令\n* 执行指令，转到步骤1，重复这个过程\n\n在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。\n\n在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。\n\n#### 修改CS、IP的指令\n\n8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。\n\n若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：\n\n```\njmp 2AE3:3 #执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令\njmp 2:0B16 #执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令\n```\n\njmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP\n\n若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：\n\n```\njmp ax, 指令执行前：ax=1000H，CS=2000H，IP=0003H\n        指令执行后：ax=1000H，CS=2000H，IP=1000H\njmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H\n        指令执行后：ax=0B16H，CS=2000H，IP=0B16H\n```\n\n指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令\n\n#### 代码段\n\n将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。\n\n要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。\n\n#### 小结\n\n* 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址\n* CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n* 8086CPU的工作过程\n    * 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\n    * IP指向下一条指令；\n    * 执行指令。（转到步骤（1），重复这个过程）\n* 8086CPU提供转移指令修改CS、IP的内容","slug":"assembly/2-register(CPU)","published":1,"date":"2020-08-15T15:06:20.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8h0009q1fw6o7cfskf","content":"<h3 id=\"第二章-寄存器（CPU工作原理）\"><a href=\"#第二章-寄存器（CPU工作原理）\" class=\"headerlink\" title=\"第二章 寄存器（CPU工作原理）\"></a>第二章 寄存器（CPU工作原理）</h3><p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。</p>\n<p>汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。</p>\n<p>8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>\n<h4 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h4><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：</p>\n<ul>\n<li>AX可分为AH和AL</li>\n<li>BX可分为BH和BL</li>\n<li>CX可分为CH和CL</li>\n<li>DX可分为DH和DL</li>\n</ul>\n<p>以AX为例，8086CPU的16位寄存器逻辑结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—————————————————————————————————AX——————————————————————————————————|</span><br><span class=\"line\">| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br><span class=\"line\">|———————————————AH————————————————————|—————————————AL————————————————|</span><br><span class=\"line\">| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"字在存储器中的存储\"><a href=\"#字在存储器中的存储\" class=\"headerlink\" title=\"字在存储器中的存储\"></a>字在存储器中的存储</h4><p>出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：</p>\n<ul>\n<li>字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中</li>\n<li>字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节</li>\n</ul>\n<h4 id=\"几条汇编指令\"><a href=\"#几条汇编指令\" class=\"headerlink\" title=\"几条汇编指令\"></a>几条汇编指令</h4><p>汇编指令举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">汇编指令</th>\n<th align=\"left\">控制CPU完成的操作</th>\n<th align=\"left\">用高级语言的语法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mov ax, 18</td>\n<td align=\"left\">将18送入寄存器AX</td>\n<td align=\"left\">AX=18</td>\n</tr>\n<tr>\n<td align=\"left\">mov ah, 78</td>\n<td align=\"left\">将78送入寄存器AH</td>\n<td align=\"left\">AH=18</td>\n</tr>\n<tr>\n<td align=\"left\">add ax,  8</td>\n<td align=\"left\">将寄存器AX中的数值加上8</td>\n<td align=\"left\">AX=AX+8</td>\n</tr>\n<tr>\n<td align=\"left\">mov ax, bx</td>\n<td align=\"left\">将寄存器BX中的数据送入寄存器AX</td>\n<td align=\"left\">AX=BX</td>\n</tr>\n<tr>\n<td align=\"left\">add ax, bx</td>\n<td align=\"left\">将AX和BX中的数值相加，结果存在AX中</td>\n<td align=\"left\">AX=AX+BX</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p>\n<h4 id=\"物理地址\"><a href=\"#物理地址\" class=\"headerlink\" title=\"物理地址\"></a>物理地址</h4><p>CPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。</p>\n<h4 id=\"16位结构的CPU\"><a href=\"#16位结构的CPU\" class=\"headerlink\" title=\"16位结构的CPU\"></a>16位结构的CPU</h4><p>16位结构描述了CPU下面的几个结构特性：</p>\n<ul>\n<li>运算器一次最多可以处理16位数据</li>\n<li>寄存器最大位宽为16位</li>\n<li>寄存器和运算器之间的通路为16位</li>\n</ul>\n<p>也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。</p>\n<h4 id=\"8086CPU给出物理地址的方法\"><a href=\"#8086CPU给出物理地址的方法\" class=\"headerlink\" title=\"8086CPU给出物理地址的方法\"></a>8086CPU给出物理地址的方法</h4><p>8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。</p>\n<p>8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n<p>当8086CPU要读写内存时：</p>\n<ul>\n<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址</li>\n<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>\n<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>\n<li>输入输出控制电路将20位物理地址送入地址总线</li>\n<li>20位物理地址被地址总线传送到存储器</li>\n</ul>\n<p>地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p>\n<h4 id=\"“段地址x16-偏移地址-物理地址”的本质含义\"><a href=\"#“段地址x16-偏移地址-物理地址”的本质含义\" class=\"headerlink\" title=\"“段地址x16+偏移地址=物理地址”的本质含义\"></a>“段地址x16+偏移地址=物理地址”的本质含义</h4><p>“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。</p>\n<h4 id=\"段的概念\"><a href=\"#段的概念\" class=\"headerlink\" title=\"段的概念\"></a>段的概念</h4><p>内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。</p>\n<h4 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h4><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p>\n<h4 id=\"CS和IP\"><a href=\"#CS和IP\" class=\"headerlink\" title=\"CS和IP\"></a>CS和IP</h4><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。</p>\n<p>8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n<p>8086CPU的工作过程简要描述如下：</p>\n<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>\n<li>IP=IP+读取指令的长度，从而指向下一条指令</li>\n<li>执行指令，转到步骤1，重复这个过程</li>\n</ul>\n<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。</p>\n<p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。</p>\n<h4 id=\"修改CS、IP的指令\"><a href=\"#修改CS、IP的指令\" class=\"headerlink\" title=\"修改CS、IP的指令\"></a>修改CS、IP的指令</h4><p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。</p>\n<p>若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2AE3:3 #执行后：CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H处读取指令</span><br><span class=\"line\">jmp 2:0B16 #执行后：CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H处读取指令</span><br></pre></td></tr></table></figure>\n\n<p>jmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p>\n<p>若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp ax, 指令执行前：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;1000H</span><br><span class=\"line\">jmp bx，指令执行前：bx&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0B16H</span><br></pre></td></tr></table></figure>\n\n<p>指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令</p>\n<h4 id=\"代码段\"><a href=\"#代码段\" class=\"headerlink\" title=\"代码段\"></a>代码段</h4><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。</p>\n<p>要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li>\n<li>CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li>\n<li>8086CPU的工作过程<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>\n<li>IP指向下一条指令；</li>\n<li>执行指令。（转到步骤（1），重复这个过程）</li>\n</ul>\n</li>\n<li>8086CPU提供转移指令修改CS、IP的内容</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"第二章-寄存器（CPU工作原理）\"><a href=\"#第二章-寄存器（CPU工作原理）\" class=\"headerlink\" title=\"第二章 寄存器（CPU工作原理）\"></a>第二章 寄存器（CPU工作原理）</h3><p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。</p>\n<p>汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。</p>\n<p>8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>\n<h4 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h4><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：</p>\n<ul>\n<li>AX可分为AH和AL</li>\n<li>BX可分为BH和BL</li>\n<li>CX可分为CH和CL</li>\n<li>DX可分为DH和DL</li>\n</ul>\n<p>以AX为例，8086CPU的16位寄存器逻辑结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—————————————————————————————————AX——————————————————————————————————|</span><br><span class=\"line\">| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br><span class=\"line\">|———————————————AH————————————————————|—————————————AL————————————————|</span><br><span class=\"line\">| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class=\"line\">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"字在存储器中的存储\"><a href=\"#字在存储器中的存储\" class=\"headerlink\" title=\"字在存储器中的存储\"></a>字在存储器中的存储</h4><p>出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：</p>\n<ul>\n<li>字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中</li>\n<li>字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节</li>\n</ul>\n<h4 id=\"几条汇编指令\"><a href=\"#几条汇编指令\" class=\"headerlink\" title=\"几条汇编指令\"></a>几条汇编指令</h4><p>汇编指令举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">汇编指令</th>\n<th align=\"left\">控制CPU完成的操作</th>\n<th align=\"left\">用高级语言的语法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mov ax, 18</td>\n<td align=\"left\">将18送入寄存器AX</td>\n<td align=\"left\">AX=18</td>\n</tr>\n<tr>\n<td align=\"left\">mov ah, 78</td>\n<td align=\"left\">将78送入寄存器AH</td>\n<td align=\"left\">AH=18</td>\n</tr>\n<tr>\n<td align=\"left\">add ax,  8</td>\n<td align=\"left\">将寄存器AX中的数值加上8</td>\n<td align=\"left\">AX=AX+8</td>\n</tr>\n<tr>\n<td align=\"left\">mov ax, bx</td>\n<td align=\"left\">将寄存器BX中的数据送入寄存器AX</td>\n<td align=\"left\">AX=BX</td>\n</tr>\n<tr>\n<td align=\"left\">add ax, bx</td>\n<td align=\"left\">将AX和BX中的数值相加，结果存在AX中</td>\n<td align=\"left\">AX=AX+BX</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p>\n<h4 id=\"物理地址\"><a href=\"#物理地址\" class=\"headerlink\" title=\"物理地址\"></a>物理地址</h4><p>CPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。</p>\n<h4 id=\"16位结构的CPU\"><a href=\"#16位结构的CPU\" class=\"headerlink\" title=\"16位结构的CPU\"></a>16位结构的CPU</h4><p>16位结构描述了CPU下面的几个结构特性：</p>\n<ul>\n<li>运算器一次最多可以处理16位数据</li>\n<li>寄存器最大位宽为16位</li>\n<li>寄存器和运算器之间的通路为16位</li>\n</ul>\n<p>也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。</p>\n<h4 id=\"8086CPU给出物理地址的方法\"><a href=\"#8086CPU给出物理地址的方法\" class=\"headerlink\" title=\"8086CPU给出物理地址的方法\"></a>8086CPU给出物理地址的方法</h4><p>8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。</p>\n<p>8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)\n</div>\n\n<p>当8086CPU要读写内存时：</p>\n<ul>\n<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址</li>\n<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>\n<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>\n<li>输入输出控制电路将20位物理地址送入地址总线</li>\n<li>20位物理地址被地址总线传送到存储器</li>\n</ul>\n<p>地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p>\n<h4 id=\"“段地址x16-偏移地址-物理地址”的本质含义\"><a href=\"#“段地址x16-偏移地址-物理地址”的本质含义\" class=\"headerlink\" title=\"“段地址x16+偏移地址=物理地址”的本质含义\"></a>“段地址x16+偏移地址=物理地址”的本质含义</h4><p>“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。</p>\n<h4 id=\"段的概念\"><a href=\"#段的概念\" class=\"headerlink\" title=\"段的概念\"></a>段的概念</h4><p>内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。</p>\n<h4 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h4><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p>\n<h4 id=\"CS和IP\"><a href=\"#CS和IP\" class=\"headerlink\" title=\"CS和IP\"></a>CS和IP</h4><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。</p>\n<p>8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行</p>\n<div align=center>\n![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)\n</div>\n\n<p>8086CPU的工作过程简要描述如下：</p>\n<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>\n<li>IP=IP+读取指令的长度，从而指向下一条指令</li>\n<li>执行指令，转到步骤1，重复这个过程</li>\n</ul>\n<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。</p>\n<p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。</p>\n<h4 id=\"修改CS、IP的指令\"><a href=\"#修改CS、IP的指令\" class=\"headerlink\" title=\"修改CS、IP的指令\"></a>修改CS、IP的指令</h4><p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。</p>\n<p>若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2AE3:3 #执行后：CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H处读取指令</span><br><span class=\"line\">jmp 2:0B16 #执行后：CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H处读取指令</span><br></pre></td></tr></table></figure>\n\n<p>jmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p>\n<p>若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp ax, 指令执行前：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;1000H</span><br><span class=\"line\">jmp bx，指令执行前：bx&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class=\"line\">        指令执行后：ax&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0B16H</span><br></pre></td></tr></table></figure>\n\n<p>指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令</p>\n<h4 id=\"代码段\"><a href=\"#代码段\" class=\"headerlink\" title=\"代码段\"></a>代码段</h4><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。</p>\n<p>要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li>\n<li>CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li>\n<li>8086CPU的工作过程<ul>\n<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>\n<li>IP指向下一条指令；</li>\n<li>执行指令。（转到步骤（1），重复这个过程）</li>\n</ul>\n</li>\n<li>8086CPU提供转移指令修改CS、IP的内容</li>\n</ul>"},{"title":"汇编语言-寄存器（内存访问）","data":"2020-08-01T12:20:00.000Z","updated":"2020-08-01T12:20:00.000Z","_content":"\n### 第三章 寄存器（内存访问）\n\n#### 内存中字的存储\n\nCPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n\n字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n#### DS和[address]\n\n8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：\n\n```\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n上面三条指令将10000H(1000:0)中的数据读到al中。\n\n`mov al [0]`中“[...]”表示一个内存单元，\"[...]\"中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。\n\n8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。\n\n<!-- more -->\n\n#### 字的传送\n\n因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。\n\n#### mov、add、sub指令\n\nmov指令可以有以下几种形式：\n\n```\nmov 寄存器, 数据        # mov ax,  8\nmov 寄存器, 寄存器      # mov ax,  bx\nmov 寄存器, 内存单元    # mov ax,  [0]\nmov 内存单元, 寄存器    # mov [0], ax\nmov 段寄存器, 寄存器    # mov ds,  ax\nmov 寄存器, 段寄存器    # mov ax,  ds\n```\n\n#### 数据段\n\n对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：\n\n```assembly\nmov ax, 123BH\nmov ds, ax          ;将123BH送入DS中，作为数据段的段地址\nmov al, 0           ;用al存放累加结果\nadd al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中\nadd al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中\nadd al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中\n```\n\n#### 栈\n\n研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。\n\n#### CPU提供的栈机制\n\n当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。\n\n8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。\n\n8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。\n\n执行push ax时，分以下两步完成：\n\n* SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n* 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\n执行pop ax时，分以下两步完成：\n\n* 将SS:SP指向的内存单元送入ax中\n* SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n#### 栈顶超界问题\n\n8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。\n\n我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。\n\n#### push、pop指令\n\npush和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：\n\n```\npush 寄存器/段寄存器/内存单元     ;可以将一个寄存器/段寄存器/内存单元中的数据入栈\npop 寄存器/段寄存器/内存单元      ;出栈，用一个寄存器/段寄存器/内存单元收出栈的数据\n```\n指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得\n\npush、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n\npush和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。\n\npush，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。\n\n#### 栈段\n\n8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段\n\n#### 段的描述\n\n我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。\n\n* 用一个段存放数据，则将它定义为“数据段”\n* 用一个段存放代码，则将它定义为“代码段”\n* 用一个段存放栈，则将它定义为“栈段”\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问\n\n对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用\n\n#### 小结\n\n* 字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n* 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中\n* [address]表示一个偏移地址为address的内存单元\n* 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应\n* mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令\n\n* 8086CPU提供了栈操作机制，方案如下：\n    * 在SS、SP中存放栈顶的段地址和偏移地址\n    * 提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元\n* push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据\n* pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2\n* 任意时刻，SS:SP指向栈顶元素\n* 8086CPU只记录栈顶，栈空间大小需要我们自己管理\n* 用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反\n* push、pop实质上是一种内存传送指令","source":"_posts/assembly/3-register(Memory).md","raw":"---\ntitle: 汇编语言-寄存器（内存访问）\ndata: 2020-08-01 20:20:00\nupdated: 2020-08-01 20:20:00\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第三章 寄存器（内存访问）\n\n#### 内存中字的存储\n\nCPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n\n字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n#### DS和[address]\n\n8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：\n\n```\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n上面三条指令将10000H(1000:0)中的数据读到al中。\n\n`mov al [0]`中“[...]”表示一个内存单元，\"[...]\"中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。\n\n8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。\n\n<!-- more -->\n\n#### 字的传送\n\n因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。\n\n#### mov、add、sub指令\n\nmov指令可以有以下几种形式：\n\n```\nmov 寄存器, 数据        # mov ax,  8\nmov 寄存器, 寄存器      # mov ax,  bx\nmov 寄存器, 内存单元    # mov ax,  [0]\nmov 内存单元, 寄存器    # mov [0], ax\nmov 段寄存器, 寄存器    # mov ds,  ax\nmov 寄存器, 段寄存器    # mov ax,  ds\n```\n\n#### 数据段\n\n对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：\n\n```assembly\nmov ax, 123BH\nmov ds, ax          ;将123BH送入DS中，作为数据段的段地址\nmov al, 0           ;用al存放累加结果\nadd al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中\nadd al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中\nadd al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中\n```\n\n#### 栈\n\n研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。\n\n#### CPU提供的栈机制\n\n当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。\n\n8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。\n\n8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。\n\n执行push ax时，分以下两步完成：\n\n* SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n* 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\n执行pop ax时，分以下两步完成：\n\n* 将SS:SP指向的内存单元送入ax中\n* SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n#### 栈顶超界问题\n\n8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。\n\n我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。\n\n#### push、pop指令\n\npush和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：\n\n```\npush 寄存器/段寄存器/内存单元     ;可以将一个寄存器/段寄存器/内存单元中的数据入栈\npop 寄存器/段寄存器/内存单元      ;出栈，用一个寄存器/段寄存器/内存单元收出栈的数据\n```\n指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得\n\npush、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。\n\npush和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。\n\npush，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。\n\n#### 栈段\n\n8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N<=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段\n\n#### 段的描述\n\n我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。\n\n* 用一个段存放数据，则将它定义为“数据段”\n* 用一个段存放代码，则将它定义为“代码段”\n* 用一个段存放栈，则将它定义为“栈段”\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问\n\n对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用\n\n#### 小结\n\n* 字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n* 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中\n* [address]表示一个偏移地址为address的内存单元\n* 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应\n* mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令\n\n* 8086CPU提供了栈操作机制，方案如下：\n    * 在SS、SP中存放栈顶的段地址和偏移地址\n    * 提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元\n* push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据\n* pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2\n* 任意时刻，SS:SP指向栈顶元素\n* 8086CPU只记录栈顶，栈空间大小需要我们自己管理\n* 用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反\n* push、pop实质上是一种内存传送指令","slug":"assembly/3-register(Memory)","published":1,"date":"2020-08-15T15:06:20.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8i000cq1fwei5lb1vb","content":"<h3 id=\"第三章-寄存器（内存访问）\"><a href=\"#第三章-寄存器（内存访问）\" class=\"headerlink\" title=\"第三章 寄存器（内存访问）\"></a>第三章 寄存器（内存访问）</h3><h4 id=\"内存中字的存储\"><a href=\"#内存中字的存储\" class=\"headerlink\" title=\"内存中字的存储\"></a>内存中字的存储</h4><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>\n<p>字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>\n<h4 id=\"DS和-address\"><a href=\"#DS和-address\" class=\"headerlink\" title=\"DS和[address]\"></a>DS和[address]</h4><p>8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx, 1000H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov al, [0]</span><br></pre></td></tr></table></figure>\n\n<p>上面三条指令将10000H(1000:0)中的数据读到al中。</p>\n<p><code>mov al [0]</code>中“[…]”表示一个内存单元，”[…]”中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。</p>\n<p>8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"字的传送\"><a href=\"#字的传送\" class=\"headerlink\" title=\"字的传送\"></a>字的传送</h4><p>因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。</p>\n<h4 id=\"mov、add、sub指令\"><a href=\"#mov、add、sub指令\" class=\"headerlink\" title=\"mov、add、sub指令\"></a>mov、add、sub指令</h4><p>mov指令可以有以下几种形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov 寄存器, 数据        # mov ax,  8</span><br><span class=\"line\">mov 寄存器, 寄存器      # mov ax,  bx</span><br><span class=\"line\">mov 寄存器, 内存单元    # mov ax,  [0]</span><br><span class=\"line\">mov 内存单元, 寄存器    # mov [0], ax</span><br><span class=\"line\">mov 段寄存器, 寄存器    # mov ds,  ax</span><br><span class=\"line\">mov 寄存器, 段寄存器    # mov ax,  ds</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据段\"><a href=\"#数据段\" class=\"headerlink\" title=\"数据段\"></a>数据段</h4><p>对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 123BH</span><br><span class=\"line\">mov ds, ax          ;将123BH送入DS中，作为数据段的段地址</span><br><span class=\"line\">mov al, 0           ;用al存放累加结果</span><br><span class=\"line\">add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中</span><br><span class=\"line\">add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中</span><br><span class=\"line\">add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。</p>\n<h4 id=\"CPU提供的栈机制\"><a href=\"#CPU提供的栈机制\" class=\"headerlink\" title=\"CPU提供的栈机制\"></a>CPU提供的栈机制</h4><p>当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。</p>\n<p>8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>\n<p>8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>\n<p>执行push ax时，分以下两步完成：</p>\n<ul>\n<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>\n<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>\n</ul>\n<p>执行pop ax时，分以下两步完成：</p>\n<ul>\n<li>将SS:SP指向的内存单元送入ax中</li>\n<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>\n</ul>\n<h4 id=\"栈顶超界问题\"><a href=\"#栈顶超界问题\" class=\"headerlink\" title=\"栈顶超界问题\"></a>栈顶超界问题</h4><p>8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。</p>\n<p>我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。</p>\n<h4 id=\"push、pop指令\"><a href=\"#push、pop指令\" class=\"headerlink\" title=\"push、pop指令\"></a>push、pop指令</h4><p>push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 寄存器&#x2F;段寄存器&#x2F;内存单元     ;可以将一个寄存器&#x2F;段寄存器&#x2F;内存单元中的数据入栈</span><br><span class=\"line\">pop 寄存器&#x2F;段寄存器&#x2F;内存单元      ;出栈，用一个寄存器&#x2F;段寄存器&#x2F;内存单元收出栈的数据</span><br></pre></td></tr></table></figure>\n<p>指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p>\n<p>push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。</p>\n<p>push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。</p>\n<p>push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</p>\n<h4 id=\"栈段\"><a href=\"#栈段\" class=\"headerlink\" title=\"栈段\"></a>栈段</h4><p>8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段</p>\n<h4 id=\"段的描述\"><a href=\"#段的描述\" class=\"headerlink\" title=\"段的描述\"></a>段的描述</h4><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。</p>\n<ul>\n<li>用一个段存放数据，则将它定义为“数据段”</li>\n<li>用一个段存放代码，则将它定义为“代码段”</li>\n<li>用一个段存放栈，则将它定义为“栈段”</li>\n</ul>\n<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问</p>\n<p>对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>\n<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li><p>字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>\n</li>\n<li><p>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</p>\n</li>\n<li><p>[address]表示一个偏移地址为address的内存单元</p>\n</li>\n<li><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应</p>\n</li>\n<li><p>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p>\n</li>\n<li><p>8086CPU提供了栈操作机制，方案如下：</p>\n<ul>\n<li>在SS、SP中存放栈顶的段地址和偏移地址</li>\n<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>\n</ul>\n</li>\n<li><p>push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据</p>\n</li>\n<li><p>pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2</p>\n</li>\n<li><p>任意时刻，SS:SP指向栈顶元素</p>\n</li>\n<li><p>8086CPU只记录栈顶，栈空间大小需要我们自己管理</p>\n</li>\n<li><p>用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反</p>\n</li>\n<li><p>push、pop实质上是一种内存传送指令</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"第三章-寄存器（内存访问）\"><a href=\"#第三章-寄存器（内存访问）\" class=\"headerlink\" title=\"第三章 寄存器（内存访问）\"></a>第三章 寄存器（内存访问）</h3><h4 id=\"内存中字的存储\"><a href=\"#内存中字的存储\" class=\"headerlink\" title=\"内存中字的存储\"></a>内存中字的存储</h4><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>\n<p>字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>\n<h4 id=\"DS和-address\"><a href=\"#DS和-address\" class=\"headerlink\" title=\"DS和[address]\"></a>DS和[address]</h4><p>8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx, 1000H</span><br><span class=\"line\">mov ds, bx</span><br><span class=\"line\">mov al, [0]</span><br></pre></td></tr></table></figure>\n\n<p>上面三条指令将10000H(1000:0)中的数据读到al中。</p>\n<p><code>mov al [0]</code>中“[…]”表示一个内存单元，”[…]”中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。</p>\n<p>8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。</p>","more":"<h4 id=\"字的传送\"><a href=\"#字的传送\" class=\"headerlink\" title=\"字的传送\"></a>字的传送</h4><p>因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。</p>\n<h4 id=\"mov、add、sub指令\"><a href=\"#mov、add、sub指令\" class=\"headerlink\" title=\"mov、add、sub指令\"></a>mov、add、sub指令</h4><p>mov指令可以有以下几种形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov 寄存器, 数据        # mov ax,  8</span><br><span class=\"line\">mov 寄存器, 寄存器      # mov ax,  bx</span><br><span class=\"line\">mov 寄存器, 内存单元    # mov ax,  [0]</span><br><span class=\"line\">mov 内存单元, 寄存器    # mov [0], ax</span><br><span class=\"line\">mov 段寄存器, 寄存器    # mov ds,  ax</span><br><span class=\"line\">mov 寄存器, 段寄存器    # mov ax,  ds</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据段\"><a href=\"#数据段\" class=\"headerlink\" title=\"数据段\"></a>数据段</h4><p>对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 123BH</span><br><span class=\"line\">mov ds, ax          ;将123BH送入DS中，作为数据段的段地址</span><br><span class=\"line\">mov al, 0           ;用al存放累加结果</span><br><span class=\"line\">add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中</span><br><span class=\"line\">add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中</span><br><span class=\"line\">add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。</p>\n<h4 id=\"CPU提供的栈机制\"><a href=\"#CPU提供的栈机制\" class=\"headerlink\" title=\"CPU提供的栈机制\"></a>CPU提供的栈机制</h4><p>当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。</p>\n<p>8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>\n<p>8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>\n<p>执行push ax时，分以下两步完成：</p>\n<ul>\n<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>\n<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>\n</ul>\n<p>执行pop ax时，分以下两步完成：</p>\n<ul>\n<li>将SS:SP指向的内存单元送入ax中</li>\n<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>\n</ul>\n<h4 id=\"栈顶超界问题\"><a href=\"#栈顶超界问题\" class=\"headerlink\" title=\"栈顶超界问题\"></a>栈顶超界问题</h4><p>8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。</p>\n<p>我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。</p>\n<h4 id=\"push、pop指令\"><a href=\"#push、pop指令\" class=\"headerlink\" title=\"push、pop指令\"></a>push、pop指令</h4><p>push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 寄存器&#x2F;段寄存器&#x2F;内存单元     ;可以将一个寄存器&#x2F;段寄存器&#x2F;内存单元中的数据入栈</span><br><span class=\"line\">pop 寄存器&#x2F;段寄存器&#x2F;内存单元      ;出栈，用一个寄存器&#x2F;段寄存器&#x2F;内存单元收出栈的数据</span><br></pre></td></tr></table></figure>\n<p>指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p>\n<p>push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。</p>\n<p>push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。</p>\n<p>push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</p>\n<h4 id=\"栈段\"><a href=\"#栈段\" class=\"headerlink\" title=\"栈段\"></a>栈段</h4><p>8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段</p>\n<h4 id=\"段的描述\"><a href=\"#段的描述\" class=\"headerlink\" title=\"段的描述\"></a>段的描述</h4><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。</p>\n<ul>\n<li>用一个段存放数据，则将它定义为“数据段”</li>\n<li>用一个段存放代码，则将它定义为“代码段”</li>\n<li>用一个段存放栈，则将它定义为“栈段”</li>\n</ul>\n<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问</p>\n<p>对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>\n<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ul>\n<li><p>字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>\n</li>\n<li><p>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</p>\n</li>\n<li><p>[address]表示一个偏移地址为address的内存单元</p>\n</li>\n<li><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应</p>\n</li>\n<li><p>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p>\n</li>\n<li><p>8086CPU提供了栈操作机制，方案如下：</p>\n<ul>\n<li>在SS、SP中存放栈顶的段地址和偏移地址</li>\n<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>\n</ul>\n</li>\n<li><p>push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据</p>\n</li>\n<li><p>pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2</p>\n</li>\n<li><p>任意时刻，SS:SP指向栈顶元素</p>\n</li>\n<li><p>8086CPU只记录栈顶，栈空间大小需要我们自己管理</p>\n</li>\n<li><p>用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反</p>\n</li>\n<li><p>push、pop实质上是一种内存传送指令</p>\n</li>\n</ul>"},{"title":"汇编语言-第一个程序","data":"2020-08-01T12:30:00.000Z","updated":"2020-08-01T12:30:00.000Z","_content":"\n### 第四章 第1个程序\n\n#### 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行的简要过程如下：\n\n* 第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件\n* 第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容\n    * 程序和数据\n    * 相关的描述信息\n* 第三步 执行可执行文件中的程序\n\n#### 源程序\n\n程序4.1\n\n```\nassume cs:codesg\n\ncodesg segment\n\nstart: mov ax, 0123H\n       mov bx, 0456H\n       add ax, bx\n       add ax, ax\n\n       mov ax, 4c00H\n       int 21H\n\ncodesg ends\n\nend\n```\n\n<!-- more -->\n\n在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。\n\n（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：\n\n```\n# 其中XXX为段名\nXXX segment     ; 定义一个段，段名为XXX，这个段从此开始\nXXX ends        ; 名称为XXX的段到此结束\n```\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码\n\n（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 \n\n（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。\n\n| 目的 | 相关指令 | 指令性质 | 指令执行者 |\n| ------ | ------ | ------ | ------ |\n| 通知编译器一个段结束 | 段名ends | 伪指令 | 编译时，由编译器执行 |\n| 通知编译器程序结束   | end      | 伪指令 | 编译时，由编译器执行|\n| 程序返回            | mov ax, 4c00H int 21H | 汇编指令 | 执行时，由CPU执行|\n\n\n\n\n","source":"_posts/assembly/4-first-program.md","raw":"---\ntitle: 汇编语言-第一个程序\ndata: 2020-08-01 20:30:00\nupdated: 2020-08-01 20:30:00\ntags:\n  - 汇编\ncategories:  \n  - 汇编语言学习\n---\n\n### 第四章 第1个程序\n\n#### 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行的简要过程如下：\n\n* 第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件\n* 第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容\n    * 程序和数据\n    * 相关的描述信息\n* 第三步 执行可执行文件中的程序\n\n#### 源程序\n\n程序4.1\n\n```\nassume cs:codesg\n\ncodesg segment\n\nstart: mov ax, 0123H\n       mov bx, 0456H\n       add ax, bx\n       add ax, ax\n\n       mov ax, 4c00H\n       int 21H\n\ncodesg ends\n\nend\n```\n\n<!-- more -->\n\n在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。\n\n（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：\n\n```\n# 其中XXX为段名\nXXX segment     ; 定义一个段，段名为XXX，这个段从此开始\nXXX ends        ; 名称为XXX的段到此结束\n```\n\n一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码\n\n（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 \n\n（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。\n\n| 目的 | 相关指令 | 指令性质 | 指令执行者 |\n| ------ | ------ | ------ | ------ |\n| 通知编译器一个段结束 | 段名ends | 伪指令 | 编译时，由编译器执行 |\n| 通知编译器程序结束   | end      | 伪指令 | 编译时，由编译器执行|\n| 程序返回            | mov ax, 4c00H int 21H | 汇编指令 | 执行时，由CPU执行|\n\n\n\n\n","slug":"assembly/4-first-program","published":1,"date":"2020-08-15T15:06:20.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8j000dq1fw4h0j4uz8","content":"<h3 id=\"第四章-第1个程序\"><a href=\"#第四章-第1个程序\" class=\"headerlink\" title=\"第四章 第1个程序\"></a>第四章 第1个程序</h3><h4 id=\"一个源程序从写出到执行的过程\"><a href=\"#一个源程序从写出到执行的过程\" class=\"headerlink\" title=\"一个源程序从写出到执行的过程\"></a>一个源程序从写出到执行的过程</h4><p>一个汇编语言程序从写出到最终执行的简要过程如下：</p>\n<ul>\n<li>第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件</li>\n<li>第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容<ul>\n<li>程序和数据</li>\n<li>相关的描述信息</li>\n</ul>\n</li>\n<li>第三步 执行可执行文件中的程序</li>\n</ul>\n<h4 id=\"源程序\"><a href=\"#源程序\" class=\"headerlink\" title=\"源程序\"></a>源程序</h4><p>程序4.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">start: mov ax, 0123H</span><br><span class=\"line\">       mov bx, 0456H</span><br><span class=\"line\">       add ax, bx</span><br><span class=\"line\">       add ax, ax</span><br><span class=\"line\"></span><br><span class=\"line\">       mov ax, 4c00H</span><br><span class=\"line\">       int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。</p>\n<p>（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中XXX为段名</span><br><span class=\"line\">XXX segment     ; 定义一个段，段名为XXX，这个段从此开始</span><br><span class=\"line\">XXX ends        ; 名称为XXX的段到此结束</span><br></pre></td></tr></table></figure>\n\n<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中</p>\n<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</p>\n<p>（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 </p>\n<p>（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p>\n<table>\n<thead>\n<tr>\n<th>目的</th>\n<th>相关指令</th>\n<th>指令性质</th>\n<th>指令执行者</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知编译器一个段结束</td>\n<td>段名ends</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>通知编译器程序结束</td>\n<td>end</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>程序返回</td>\n<td>mov ax, 4c00H int 21H</td>\n<td>汇编指令</td>\n<td>执行时，由CPU执行</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h3 id=\"第四章-第1个程序\"><a href=\"#第四章-第1个程序\" class=\"headerlink\" title=\"第四章 第1个程序\"></a>第四章 第1个程序</h3><h4 id=\"一个源程序从写出到执行的过程\"><a href=\"#一个源程序从写出到执行的过程\" class=\"headerlink\" title=\"一个源程序从写出到执行的过程\"></a>一个源程序从写出到执行的过程</h4><p>一个汇编语言程序从写出到最终执行的简要过程如下：</p>\n<ul>\n<li>第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件</li>\n<li>第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容<ul>\n<li>程序和数据</li>\n<li>相关的描述信息</li>\n</ul>\n</li>\n<li>第三步 执行可执行文件中的程序</li>\n</ul>\n<h4 id=\"源程序\"><a href=\"#源程序\" class=\"headerlink\" title=\"源程序\"></a>源程序</h4><p>程序4.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\"></span><br><span class=\"line\">start: mov ax, 0123H</span><br><span class=\"line\">       mov bx, 0456H</span><br><span class=\"line\">       add ax, bx</span><br><span class=\"line\">       add ax, ax</span><br><span class=\"line\"></span><br><span class=\"line\">       mov ax, 4c00H</span><br><span class=\"line\">       int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">codesg ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>","more":"<p>在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。</p>\n<p>（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 其中XXX为段名</span><br><span class=\"line\">XXX segment     ; 定义一个段，段名为XXX，这个段从此开始</span><br><span class=\"line\">XXX ends        ; 名称为XXX的段到此结束</span><br></pre></td></tr></table></figure>\n\n<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中</p>\n<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</p>\n<p>（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 </p>\n<p>（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p>\n<table>\n<thead>\n<tr>\n<th>目的</th>\n<th>相关指令</th>\n<th>指令性质</th>\n<th>指令执行者</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知编译器一个段结束</td>\n<td>段名ends</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>通知编译器程序结束</td>\n<td>end</td>\n<td>伪指令</td>\n<td>编译时，由编译器执行</td>\n</tr>\n<tr>\n<td>程序返回</td>\n<td>mov ax, 4c00H int 21H</td>\n<td>汇编指令</td>\n<td>执行时，由CPU执行</td>\n</tr>\n</tbody></table>"},{"title":"汇编语言-[bx]和loop指令","data":"2020-08-01T12:50:00.000Z","updated":"2020-08-01T12:50:00.000Z","_content":"\n### 第五章 [bx]和loop指令\n\n[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0。要完整的描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。[bx]可以表示一个内存单元，它的偏移地址在bx中，比如以下指令：\n\n```\nmov ax, [bx]    # 将一个内存单元的内容送入ax，这个内存单元的长度为2（字单元），存放一个字，偏移地址在bx中，段地址在ds中。\n```\n\n后续课程中：用“()”表示一个寄存器或一个内存单元中的内容：\n\n```\n(ax)            # 表示ax中的内容\n(al)            # 表示al中的内容\n(20000H)        # 表示内存20000H单元的内容\n((ds)*16+(bx))  # 表示ds中的内容为ADRR1，bx中的内容为ADRR2，ADRR1x16+ADRR2表示内存ADRR1:ADRR2单元的内容\n```\n\n<!-- more -->\n\n#### [bx]\n\n```\nmov ax, [bx]\n```\n功能：bx中存放偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)=((ds)*16+(bx))\n\n```\nmov [bx], ax\n```\n功能：bx中存放偏移地址EA，段地址SA默认在ds中，将ax处的数据送入SA:EA中。即：((ds)*16+(bx))=(ax)\n\n#### Loop指令\n\nloop指令的格式：loop标号，CPU执行loop指令时，要进行两步操作：（1）`(cx)=(cx)-1`；（2）判断cx中的值，不为零则转至标号处执行指令，如果为零则向下执行。**通常**用loop指令来实现循环功能，cx中存放循环次数。\n\n#### 在Debug中跟踪用loop指令实现的循环程序\n\n#### Debug和汇编编译器masm对指令的不同处理\n\n在Debug中，`mov ax [0]`表示将ds:0处的数据送入ax中，在汇编源程序中，`mov ax, [0]`被编译器当作指令`mov ax, 0`处理。\n\n源程序中可使用的方式：\n\n```\nmov ax, 2000h\nmov ds, ax      ;段地址2000h送入ds\nmov bx, 0       ;偏移地址0送入bx\nmov al, [bx]    ;ds:bx单元中的数据送入al\n```\n\n或者\n\n```\nmov ax, 2000h\nmov ds, ax\nmov al, ds:[0]\n```\n\n在汇编源程序中，指令访问一个内存单元，则在指令中必须用`[...]`表示内存单元，如果在`[]`里用一个常量`idata`直接给出内存单元的偏移地址，则在`[]`的前面需要显示的给出段地址所在的寄存器，否则masm将把指令中的`[idata]`解释为`idata`\n\n如果在`[]`里使用寄存器，比如bx，间接的给出内存单元的偏移地址，则段地址默认在ds中。当然，也可以显式的给出段地址所在的段寄存器。\n\n#### loop和[bx]的联合应用\n\n问题：计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中。\n\n思考：\n* 运算后的结果是否会超出dx的表示范围？\n* 是否能将ffff:0-ffff:b中的数据直接累加到dx中？\n* 能否将ffff:0-ffff:b中的数据累加到dl中，并设置(dh)=0，从而实现累加到dx中的目标？\n* 到底怎样将ffff:0-ffff:b中的8位数据累加到16位寄存器dx中？\n\n方法：\n* (dx)=(dx)+内存中的8位数据\n* (dl)=(dl)+内存中的8位数据\n\n第一种方法的问题是：运算对象的类型不匹配，第二种方法的问题是：运算结果有可能越界\n\n```\nassume cs:code\ncode segment\n\n    mov ax, 0ffffh\n    mov ds, ax\n\n    mov bx, 0\n    mov dx, 0\n    mov cx, 0\n\ns:  mov al, [bx]\n    mov ah, 0\n    add dx, ax\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend\n```\n\n#### 段前缀\n\n指令`mov ax, [bx]`中内存单元的偏移地址由bx给出，而段地址默认在ds中，可以在访问内存单元的指令中显示的给出内存单元的段地址所在的段寄存器。比如：\n\n```\nmov ax, ds:[bx]\nmov ax, cs:[bx]\nmov ax, ss:[bx]\nmov ax, es:[bx]\nmov ax, cs:[0]\n```\n\n这些出现在访问内存单元指令中，用于显示指明内存单元段寄存器，在汇编语言中被称为**段前缀**\n\n#### 一段安全的空间\n\n在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或者代码。所以在不能确定一段内存空间中是否存在着重要的数据或代码的时候，不能随意向其中写入数据。\n\n#### 段前缀的使用\n\n问题：将内存单元ffff:0-ffff:b中的数据拷贝到0:200-020b单元中\n\n思考：\n* 0:200-0:20b单元等同于0020:0-0020:b单元，它们描述的是同一段内存空间\n\n```\nassume cs:code\ncode segment\n\n    mov ax, 0ffffh\n    mov ds, ax\n    mov ax, 0020h\n    mov es, ax\n\n    mov bx, 0\n    mov cx 12\n\ns:  mov dl, [bx]\n    mov es:[bx], dl\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend\n```\n\n","source":"_posts/assembly/5-[bx]-and-loop.md","raw":"---\ntitle: 汇编语言-[bx]和loop指令\ndata: 2020-08-01 20:50:00\nupdated: 2020-08-01 20:50:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第五章 [bx]和loop指令\n\n[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0。要完整的描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。[bx]可以表示一个内存单元，它的偏移地址在bx中，比如以下指令：\n\n```\nmov ax, [bx]    # 将一个内存单元的内容送入ax，这个内存单元的长度为2（字单元），存放一个字，偏移地址在bx中，段地址在ds中。\n```\n\n后续课程中：用“()”表示一个寄存器或一个内存单元中的内容：\n\n```\n(ax)            # 表示ax中的内容\n(al)            # 表示al中的内容\n(20000H)        # 表示内存20000H单元的内容\n((ds)*16+(bx))  # 表示ds中的内容为ADRR1，bx中的内容为ADRR2，ADRR1x16+ADRR2表示内存ADRR1:ADRR2单元的内容\n```\n\n<!-- more -->\n\n#### [bx]\n\n```\nmov ax, [bx]\n```\n功能：bx中存放偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)=((ds)*16+(bx))\n\n```\nmov [bx], ax\n```\n功能：bx中存放偏移地址EA，段地址SA默认在ds中，将ax处的数据送入SA:EA中。即：((ds)*16+(bx))=(ax)\n\n#### Loop指令\n\nloop指令的格式：loop标号，CPU执行loop指令时，要进行两步操作：（1）`(cx)=(cx)-1`；（2）判断cx中的值，不为零则转至标号处执行指令，如果为零则向下执行。**通常**用loop指令来实现循环功能，cx中存放循环次数。\n\n#### 在Debug中跟踪用loop指令实现的循环程序\n\n#### Debug和汇编编译器masm对指令的不同处理\n\n在Debug中，`mov ax [0]`表示将ds:0处的数据送入ax中，在汇编源程序中，`mov ax, [0]`被编译器当作指令`mov ax, 0`处理。\n\n源程序中可使用的方式：\n\n```\nmov ax, 2000h\nmov ds, ax      ;段地址2000h送入ds\nmov bx, 0       ;偏移地址0送入bx\nmov al, [bx]    ;ds:bx单元中的数据送入al\n```\n\n或者\n\n```\nmov ax, 2000h\nmov ds, ax\nmov al, ds:[0]\n```\n\n在汇编源程序中，指令访问一个内存单元，则在指令中必须用`[...]`表示内存单元，如果在`[]`里用一个常量`idata`直接给出内存单元的偏移地址，则在`[]`的前面需要显示的给出段地址所在的寄存器，否则masm将把指令中的`[idata]`解释为`idata`\n\n如果在`[]`里使用寄存器，比如bx，间接的给出内存单元的偏移地址，则段地址默认在ds中。当然，也可以显式的给出段地址所在的段寄存器。\n\n#### loop和[bx]的联合应用\n\n问题：计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中。\n\n思考：\n* 运算后的结果是否会超出dx的表示范围？\n* 是否能将ffff:0-ffff:b中的数据直接累加到dx中？\n* 能否将ffff:0-ffff:b中的数据累加到dl中，并设置(dh)=0，从而实现累加到dx中的目标？\n* 到底怎样将ffff:0-ffff:b中的8位数据累加到16位寄存器dx中？\n\n方法：\n* (dx)=(dx)+内存中的8位数据\n* (dl)=(dl)+内存中的8位数据\n\n第一种方法的问题是：运算对象的类型不匹配，第二种方法的问题是：运算结果有可能越界\n\n```\nassume cs:code\ncode segment\n\n    mov ax, 0ffffh\n    mov ds, ax\n\n    mov bx, 0\n    mov dx, 0\n    mov cx, 0\n\ns:  mov al, [bx]\n    mov ah, 0\n    add dx, ax\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend\n```\n\n#### 段前缀\n\n指令`mov ax, [bx]`中内存单元的偏移地址由bx给出，而段地址默认在ds中，可以在访问内存单元的指令中显示的给出内存单元的段地址所在的段寄存器。比如：\n\n```\nmov ax, ds:[bx]\nmov ax, cs:[bx]\nmov ax, ss:[bx]\nmov ax, es:[bx]\nmov ax, cs:[0]\n```\n\n这些出现在访问内存单元指令中，用于显示指明内存单元段寄存器，在汇编语言中被称为**段前缀**\n\n#### 一段安全的空间\n\n在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或者代码。所以在不能确定一段内存空间中是否存在着重要的数据或代码的时候，不能随意向其中写入数据。\n\n#### 段前缀的使用\n\n问题：将内存单元ffff:0-ffff:b中的数据拷贝到0:200-020b单元中\n\n思考：\n* 0:200-0:20b单元等同于0020:0-0020:b单元，它们描述的是同一段内存空间\n\n```\nassume cs:code\ncode segment\n\n    mov ax, 0ffffh\n    mov ds, ax\n    mov ax, 0020h\n    mov es, ax\n\n    mov bx, 0\n    mov cx 12\n\ns:  mov dl, [bx]\n    mov es:[bx], dl\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend\n```\n\n","slug":"assembly/5-[bx]-and-loop","published":1,"date":"2020-08-15T15:06:20.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8j000eq1fw5bkzbc0v","content":"<h3 id=\"第五章-bx-和loop指令\"><a href=\"#第五章-bx-和loop指令\" class=\"headerlink\" title=\"第五章 [bx]和loop指令\"></a>第五章 [bx]和loop指令</h3><p>[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0。要完整的描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。[bx]可以表示一个内存单元，它的偏移地址在bx中，比如以下指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx]    # 将一个内存单元的内容送入ax，这个内存单元的长度为2（字单元），存放一个字，偏移地址在bx中，段地址在ds中。</span><br></pre></td></tr></table></figure>\n\n<p>后续课程中：用“()”表示一个寄存器或一个内存单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ax)            # 表示ax中的内容</span><br><span class=\"line\">(al)            # 表示al中的内容</span><br><span class=\"line\">(20000H)        # 表示内存20000H单元的内容</span><br><span class=\"line\">((ds)*16+(bx))  # 表示ds中的内容为ADRR1，bx中的内容为ADRR2，ADRR1x16+ADRR2表示内存ADRR1:ADRR2单元的内容</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"bx\"><a href=\"#bx\" class=\"headerlink\" title=\"[bx]\"></a>[bx]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx]</span><br></pre></td></tr></table></figure>\n<p>功能：bx中存放偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)=((ds)*16+(bx))</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov [bx], ax</span><br></pre></td></tr></table></figure>\n<p>功能：bx中存放偏移地址EA，段地址SA默认在ds中，将ax处的数据送入SA:EA中。即：((ds)*16+(bx))=(ax)</p>\n<h4 id=\"Loop指令\"><a href=\"#Loop指令\" class=\"headerlink\" title=\"Loop指令\"></a>Loop指令</h4><p>loop指令的格式：loop标号，CPU执行loop指令时，要进行两步操作：（1）<code>(cx)=(cx)-1</code>；（2）判断cx中的值，不为零则转至标号处执行指令，如果为零则向下执行。<strong>通常</strong>用loop指令来实现循环功能，cx中存放循环次数。</p>\n<h4 id=\"在Debug中跟踪用loop指令实现的循环程序\"><a href=\"#在Debug中跟踪用loop指令实现的循环程序\" class=\"headerlink\" title=\"在Debug中跟踪用loop指令实现的循环程序\"></a>在Debug中跟踪用loop指令实现的循环程序</h4><h4 id=\"Debug和汇编编译器masm对指令的不同处理\"><a href=\"#Debug和汇编编译器masm对指令的不同处理\" class=\"headerlink\" title=\"Debug和汇编编译器masm对指令的不同处理\"></a>Debug和汇编编译器masm对指令的不同处理</h4><p>在Debug中，<code>mov ax [0]</code>表示将ds:0处的数据送入ax中，在汇编源程序中，<code>mov ax, [0]</code>被编译器当作指令<code>mov ax, 0</code>处理。</p>\n<p>源程序中可使用的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 2000h</span><br><span class=\"line\">mov ds, ax      ;段地址2000h送入ds</span><br><span class=\"line\">mov bx, 0       ;偏移地址0送入bx</span><br><span class=\"line\">mov al, [bx]    ;ds:bx单元中的数据送入al</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 2000h</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov al, ds:[0]</span><br></pre></td></tr></table></figure>\n\n<p>在汇编源程序中，指令访问一个内存单元，则在指令中必须用<code>[...]</code>表示内存单元，如果在<code>[]</code>里用一个常量<code>idata</code>直接给出内存单元的偏移地址，则在<code>[]</code>的前面需要显示的给出段地址所在的寄存器，否则masm将把指令中的<code>[idata]</code>解释为<code>idata</code></p>\n<p>如果在<code>[]</code>里使用寄存器，比如bx，间接的给出内存单元的偏移地址，则段地址默认在ds中。当然，也可以显式的给出段地址所在的段寄存器。</p>\n<h4 id=\"loop和-bx-的联合应用\"><a href=\"#loop和-bx-的联合应用\" class=\"headerlink\" title=\"loop和[bx]的联合应用\"></a>loop和[bx]的联合应用</h4><p>问题：计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中。</p>\n<p>思考：</p>\n<ul>\n<li>运算后的结果是否会超出dx的表示范围？</li>\n<li>是否能将ffff:0-ffff:b中的数据直接累加到dx中？</li>\n<li>能否将ffff:0-ffff:b中的数据累加到dl中，并设置(dh)=0，从而实现累加到dx中的目标？</li>\n<li>到底怎样将ffff:0-ffff:b中的8位数据累加到16位寄存器dx中？</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>(dx)=(dx)+内存中的8位数据</li>\n<li>(dl)=(dl)+内存中的8位数据</li>\n</ul>\n<p>第一种方法的问题是：运算对象的类型不匹配，第二种方法的问题是：运算结果有可能越界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0ffffh</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov dx, 0</span><br><span class=\"line\">    mov cx, 0</span><br><span class=\"line\"></span><br><span class=\"line\">s:  mov al, [bx]</span><br><span class=\"line\">    mov ah, 0</span><br><span class=\"line\">    add dx, ax</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"段前缀\"><a href=\"#段前缀\" class=\"headerlink\" title=\"段前缀\"></a>段前缀</h4><p>指令<code>mov ax, [bx]</code>中内存单元的偏移地址由bx给出，而段地址默认在ds中，可以在访问内存单元的指令中显示的给出内存单元的段地址所在的段寄存器。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, ds:[bx]</span><br><span class=\"line\">mov ax, cs:[bx]</span><br><span class=\"line\">mov ax, ss:[bx]</span><br><span class=\"line\">mov ax, es:[bx]</span><br><span class=\"line\">mov ax, cs:[0]</span><br></pre></td></tr></table></figure>\n\n<p>这些出现在访问内存单元指令中，用于显示指明内存单元段寄存器，在汇编语言中被称为<strong>段前缀</strong></p>\n<h4 id=\"一段安全的空间\"><a href=\"#一段安全的空间\" class=\"headerlink\" title=\"一段安全的空间\"></a>一段安全的空间</h4><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或者代码。所以在不能确定一段内存空间中是否存在着重要的数据或代码的时候，不能随意向其中写入数据。</p>\n<h4 id=\"段前缀的使用\"><a href=\"#段前缀的使用\" class=\"headerlink\" title=\"段前缀的使用\"></a>段前缀的使用</h4><p>问题：将内存单元ffff:0-ffff:b中的数据拷贝到0:200-020b单元中</p>\n<p>思考：</p>\n<ul>\n<li>0:200-0:20b单元等同于0020:0-0020:b单元，它们描述的是同一段内存空间</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0ffffh</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\">    mov ax, 0020h</span><br><span class=\"line\">    mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov cx 12</span><br><span class=\"line\"></span><br><span class=\"line\">s:  mov dl, [bx]</span><br><span class=\"line\">    mov es:[bx], dl</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"第五章-bx-和loop指令\"><a href=\"#第五章-bx-和loop指令\" class=\"headerlink\" title=\"第五章 [bx]和loop指令\"></a>第五章 [bx]和loop指令</h3><p>[bx]和[0]有些类似，[0]表示内存单元，它的偏移地址是0。要完整的描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。[bx]可以表示一个内存单元，它的偏移地址在bx中，比如以下指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx]    # 将一个内存单元的内容送入ax，这个内存单元的长度为2（字单元），存放一个字，偏移地址在bx中，段地址在ds中。</span><br></pre></td></tr></table></figure>\n\n<p>后续课程中：用“()”表示一个寄存器或一个内存单元中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ax)            # 表示ax中的内容</span><br><span class=\"line\">(al)            # 表示al中的内容</span><br><span class=\"line\">(20000H)        # 表示内存20000H单元的内容</span><br><span class=\"line\">((ds)*16+(bx))  # 表示ds中的内容为ADRR1，bx中的内容为ADRR2，ADRR1x16+ADRR2表示内存ADRR1:ADRR2单元的内容</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"bx\"><a href=\"#bx\" class=\"headerlink\" title=\"[bx]\"></a>[bx]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx]</span><br></pre></td></tr></table></figure>\n<p>功能：bx中存放偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即：(ax)=((ds)*16+(bx))</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov [bx], ax</span><br></pre></td></tr></table></figure>\n<p>功能：bx中存放偏移地址EA，段地址SA默认在ds中，将ax处的数据送入SA:EA中。即：((ds)*16+(bx))=(ax)</p>\n<h4 id=\"Loop指令\"><a href=\"#Loop指令\" class=\"headerlink\" title=\"Loop指令\"></a>Loop指令</h4><p>loop指令的格式：loop标号，CPU执行loop指令时，要进行两步操作：（1）<code>(cx)=(cx)-1</code>；（2）判断cx中的值，不为零则转至标号处执行指令，如果为零则向下执行。<strong>通常</strong>用loop指令来实现循环功能，cx中存放循环次数。</p>\n<h4 id=\"在Debug中跟踪用loop指令实现的循环程序\"><a href=\"#在Debug中跟踪用loop指令实现的循环程序\" class=\"headerlink\" title=\"在Debug中跟踪用loop指令实现的循环程序\"></a>在Debug中跟踪用loop指令实现的循环程序</h4><h4 id=\"Debug和汇编编译器masm对指令的不同处理\"><a href=\"#Debug和汇编编译器masm对指令的不同处理\" class=\"headerlink\" title=\"Debug和汇编编译器masm对指令的不同处理\"></a>Debug和汇编编译器masm对指令的不同处理</h4><p>在Debug中，<code>mov ax [0]</code>表示将ds:0处的数据送入ax中，在汇编源程序中，<code>mov ax, [0]</code>被编译器当作指令<code>mov ax, 0</code>处理。</p>\n<p>源程序中可使用的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 2000h</span><br><span class=\"line\">mov ds, ax      ;段地址2000h送入ds</span><br><span class=\"line\">mov bx, 0       ;偏移地址0送入bx</span><br><span class=\"line\">mov al, [bx]    ;ds:bx单元中的数据送入al</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 2000h</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov al, ds:[0]</span><br></pre></td></tr></table></figure>\n\n<p>在汇编源程序中，指令访问一个内存单元，则在指令中必须用<code>[...]</code>表示内存单元，如果在<code>[]</code>里用一个常量<code>idata</code>直接给出内存单元的偏移地址，则在<code>[]</code>的前面需要显示的给出段地址所在的寄存器，否则masm将把指令中的<code>[idata]</code>解释为<code>idata</code></p>\n<p>如果在<code>[]</code>里使用寄存器，比如bx，间接的给出内存单元的偏移地址，则段地址默认在ds中。当然，也可以显式的给出段地址所在的段寄存器。</p>\n<h4 id=\"loop和-bx-的联合应用\"><a href=\"#loop和-bx-的联合应用\" class=\"headerlink\" title=\"loop和[bx]的联合应用\"></a>loop和[bx]的联合应用</h4><p>问题：计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中。</p>\n<p>思考：</p>\n<ul>\n<li>运算后的结果是否会超出dx的表示范围？</li>\n<li>是否能将ffff:0-ffff:b中的数据直接累加到dx中？</li>\n<li>能否将ffff:0-ffff:b中的数据累加到dl中，并设置(dh)=0，从而实现累加到dx中的目标？</li>\n<li>到底怎样将ffff:0-ffff:b中的8位数据累加到16位寄存器dx中？</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>(dx)=(dx)+内存中的8位数据</li>\n<li>(dl)=(dl)+内存中的8位数据</li>\n</ul>\n<p>第一种方法的问题是：运算对象的类型不匹配，第二种方法的问题是：运算结果有可能越界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0ffffh</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\"></span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov dx, 0</span><br><span class=\"line\">    mov cx, 0</span><br><span class=\"line\"></span><br><span class=\"line\">s:  mov al, [bx]</span><br><span class=\"line\">    mov ah, 0</span><br><span class=\"line\">    add dx, ax</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"段前缀\"><a href=\"#段前缀\" class=\"headerlink\" title=\"段前缀\"></a>段前缀</h4><p>指令<code>mov ax, [bx]</code>中内存单元的偏移地址由bx给出，而段地址默认在ds中，可以在访问内存单元的指令中显示的给出内存单元的段地址所在的段寄存器。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, ds:[bx]</span><br><span class=\"line\">mov ax, cs:[bx]</span><br><span class=\"line\">mov ax, ss:[bx]</span><br><span class=\"line\">mov ax, es:[bx]</span><br><span class=\"line\">mov ax, cs:[0]</span><br></pre></td></tr></table></figure>\n\n<p>这些出现在访问内存单元指令中，用于显示指明内存单元段寄存器，在汇编语言中被称为<strong>段前缀</strong></p>\n<h4 id=\"一段安全的空间\"><a href=\"#一段安全的空间\" class=\"headerlink\" title=\"一段安全的空间\"></a>一段安全的空间</h4><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或者代码。所以在不能确定一段内存空间中是否存在着重要的数据或代码的时候，不能随意向其中写入数据。</p>\n<h4 id=\"段前缀的使用\"><a href=\"#段前缀的使用\" class=\"headerlink\" title=\"段前缀的使用\"></a>段前缀的使用</h4><p>问题：将内存单元ffff:0-ffff:b中的数据拷贝到0:200-020b单元中</p>\n<p>思考：</p>\n<ul>\n<li>0:200-0:20b单元等同于0020:0-0020:b单元，它们描述的是同一段内存空间</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0ffffh</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\">    mov ax, 0020h</span><br><span class=\"line\">    mov es, ax</span><br><span class=\"line\"></span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov cx 12</span><br><span class=\"line\"></span><br><span class=\"line\">s:  mov dl, [bx]</span><br><span class=\"line\">    mov es:[bx], dl</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>"},{"title":"汇编语言-包含多个段的程序","data":"2020-08-11T12:50:00.000Z","updated":"2020-08-11T12:50:00.000Z","_content":"\n### 第六章 包含多个段的程序\n\n在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所在的空间和其他程序以及系统自己的空间相冲突。操作系统允许的情况下，程序可以取得任意容量的空间。\n\n程序取得所需空间的方法有两种：加载程序时为程序分配，程序执行过程中向系统申请。\n\n#### 6.1 在代码段中使用数据\n\n从规范的角度讲，是不能自己随便决定使用哪段空间的，应该让系统来分配空间。我们可以在程序中定义希望处理的数据，这些数据就会被编译、链接而作为程序的一部分被写入到可执行文件中，这样程序被加载到内存时，数据也被加载到内存中，此时就获得了空间。\n\nend除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。\n\n可执行文件中的描述信息指明CPU的CS:IP指向程序的哪一条执行指令。程序来源于源程序中的汇编指令和定义的数据：描述信息则主要是编译、链接程序对源程序中相关伪指令进行处理所得到的信息。\n\n程序框架：\n\n```\nassume cs:code\ncode segment\n    ; 数据\n\nstart:\n    ; 代码\n\ncode ends\nend start\n```\n\n例如：\n\n```\nasssume cs:code\ncode segment\n\n    dw 0123H, 0456H, 0789H, 0abcH, 0fedH, 0cbaH, 0987H\n\nstart:\n    mov bx, 0\n    mov ax, 0\n    mov cx, 8\n\ns:  add ax, cs:[bx]\n    add bx, 2\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend start\n\n```\n\n#### 6.2 在代码段中使用栈\n\n利用栈将程序中定义的数据逆序存放：\n\n```\nassume cs:codeseg\ncodeseg segment\n    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H\n    dw 0, 0, 0, 0, 0, 0, 0, 0   ;用dw定义8个字型数据，\n                                ;程序加载后，将取得8个字的内存空间，存放这8个数据\n                                ;后面的程序中将这段空间当作栈来使用\n\nstart:  mov ax, cs\n        mov ss, ax\n        mov sp, 32              ;将设置栈顶ss:sp指向cs:32\n        mov bx, 0\n        mov cx, 8\n\ns0:     push cs:[bx]            ;将代码段0-16单元中的8个字型数据以此入栈\n        add bx, 2\n        loop s0\n\n        mov bx, 0\n        mov cx, 8\n\ns1:     pop cs:[bx]\n        add bx, 2\n        loop s1\n\n        mov ax, 4c00h\n        int 21h\ncodeseg ends\nend start                       ;指明程序的入口地址在start处\n```\n\n#### 将数据、代码、栈放入不同的段\n\n首先看一段代码\n\n```\nassume cs:code, ds:data, ss:stack\ndata segment\n    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H\ndata ends\n\nstack segment\n    dw 0, 0, 0, 0, 0, 0, 0, 0\nstack ends\n\ncode segment\nstart:  mov ax, stack\n        mov ss, ax\n        mov sp, 16      ;设置栈顶ss:sp指向stack:16\n\n        mov ax, data\n        mov ds, ax      ;ds指向data段\n\n        mov bx, 0       ;ds:bx指向data段的第一个单元\n        mov cx, 8\n\ns0:     push [bx]\n        add bx, 2\n        loop s1\n\n        mov bx, 0\n        mov cx, 8\n\ns1:     pop [bx]\n        add bx, 2\n        loop s1\n\n        mov ax, 4c00h\n        int 21h\n    \ncode ends\nend start\n```\n\n定义多个段的方法：与之前定义代码段的方法没有区别，只是对于不同的段，要有不同的段名\n\n对段地址的引用：在程序中，段名就相当于一个标号，代表了段地址。所以指令`mov ax, data`的含义就是将名称为`data`的段的段地址送入`ax`。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。注意：8086CPU不允许将一个数值直接送入段寄存器，所以对段名的引用：如指令`mov ds, data`中的`data`将被编译器处理为一个表示段地址的数值。\n\n```\nmov ax, data\nmov ds, ax\nmov ax, ds:[6]\n```\n\nCPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。\n\n","source":"_posts/assembly/6-multi-segment.md","raw":"---\ntitle: 汇编语言-包含多个段的程序\ndata: 2020-08-11 20:50:00\nupdated: 2020-08-11 20:50:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第六章 包含多个段的程序\n\n在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所在的空间和其他程序以及系统自己的空间相冲突。操作系统允许的情况下，程序可以取得任意容量的空间。\n\n程序取得所需空间的方法有两种：加载程序时为程序分配，程序执行过程中向系统申请。\n\n#### 6.1 在代码段中使用数据\n\n从规范的角度讲，是不能自己随便决定使用哪段空间的，应该让系统来分配空间。我们可以在程序中定义希望处理的数据，这些数据就会被编译、链接而作为程序的一部分被写入到可执行文件中，这样程序被加载到内存时，数据也被加载到内存中，此时就获得了空间。\n\nend除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。\n\n可执行文件中的描述信息指明CPU的CS:IP指向程序的哪一条执行指令。程序来源于源程序中的汇编指令和定义的数据：描述信息则主要是编译、链接程序对源程序中相关伪指令进行处理所得到的信息。\n\n程序框架：\n\n```\nassume cs:code\ncode segment\n    ; 数据\n\nstart:\n    ; 代码\n\ncode ends\nend start\n```\n\n例如：\n\n```\nasssume cs:code\ncode segment\n\n    dw 0123H, 0456H, 0789H, 0abcH, 0fedH, 0cbaH, 0987H\n\nstart:\n    mov bx, 0\n    mov ax, 0\n    mov cx, 8\n\ns:  add ax, cs:[bx]\n    add bx, 2\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend start\n\n```\n\n#### 6.2 在代码段中使用栈\n\n利用栈将程序中定义的数据逆序存放：\n\n```\nassume cs:codeseg\ncodeseg segment\n    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H\n    dw 0, 0, 0, 0, 0, 0, 0, 0   ;用dw定义8个字型数据，\n                                ;程序加载后，将取得8个字的内存空间，存放这8个数据\n                                ;后面的程序中将这段空间当作栈来使用\n\nstart:  mov ax, cs\n        mov ss, ax\n        mov sp, 32              ;将设置栈顶ss:sp指向cs:32\n        mov bx, 0\n        mov cx, 8\n\ns0:     push cs:[bx]            ;将代码段0-16单元中的8个字型数据以此入栈\n        add bx, 2\n        loop s0\n\n        mov bx, 0\n        mov cx, 8\n\ns1:     pop cs:[bx]\n        add bx, 2\n        loop s1\n\n        mov ax, 4c00h\n        int 21h\ncodeseg ends\nend start                       ;指明程序的入口地址在start处\n```\n\n#### 将数据、代码、栈放入不同的段\n\n首先看一段代码\n\n```\nassume cs:code, ds:data, ss:stack\ndata segment\n    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H\ndata ends\n\nstack segment\n    dw 0, 0, 0, 0, 0, 0, 0, 0\nstack ends\n\ncode segment\nstart:  mov ax, stack\n        mov ss, ax\n        mov sp, 16      ;设置栈顶ss:sp指向stack:16\n\n        mov ax, data\n        mov ds, ax      ;ds指向data段\n\n        mov bx, 0       ;ds:bx指向data段的第一个单元\n        mov cx, 8\n\ns0:     push [bx]\n        add bx, 2\n        loop s1\n\n        mov bx, 0\n        mov cx, 8\n\ns1:     pop [bx]\n        add bx, 2\n        loop s1\n\n        mov ax, 4c00h\n        int 21h\n    \ncode ends\nend start\n```\n\n定义多个段的方法：与之前定义代码段的方法没有区别，只是对于不同的段，要有不同的段名\n\n对段地址的引用：在程序中，段名就相当于一个标号，代表了段地址。所以指令`mov ax, data`的含义就是将名称为`data`的段的段地址送入`ax`。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。注意：8086CPU不允许将一个数值直接送入段寄存器，所以对段名的引用：如指令`mov ds, data`中的`data`将被编译器处理为一个表示段地址的数值。\n\n```\nmov ax, data\nmov ds, ax\nmov ax, ds:[6]\n```\n\nCPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。\n\n","slug":"assembly/6-multi-segment","published":1,"date":"2020-08-15T15:06:20.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8l000iq1fwfvlkbeqb","content":"<h3 id=\"第六章-包含多个段的程序\"><a href=\"#第六章-包含多个段的程序\" class=\"headerlink\" title=\"第六章 包含多个段的程序\"></a>第六章 包含多个段的程序</h3><p>在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所在的空间和其他程序以及系统自己的空间相冲突。操作系统允许的情况下，程序可以取得任意容量的空间。</p>\n<p>程序取得所需空间的方法有两种：加载程序时为程序分配，程序执行过程中向系统申请。</p>\n<h4 id=\"6-1-在代码段中使用数据\"><a href=\"#6-1-在代码段中使用数据\" class=\"headerlink\" title=\"6.1 在代码段中使用数据\"></a>6.1 在代码段中使用数据</h4><p>从规范的角度讲，是不能自己随便决定使用哪段空间的，应该让系统来分配空间。我们可以在程序中定义希望处理的数据，这些数据就会被编译、链接而作为程序的一部分被写入到可执行文件中，这样程序被加载到内存时，数据也被加载到内存中，此时就获得了空间。</p>\n<p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p>\n<p>可执行文件中的描述信息指明CPU的CS:IP指向程序的哪一条执行指令。程序来源于源程序中的汇编指令和定义的数据：描述信息则主要是编译、链接程序对源程序中相关伪指令进行处理所得到的信息。</p>\n<p>程序框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">    ; 数据</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    ; 代码</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asssume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0fedH, 0cbaH, 0987H</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:  add ax, cs:[bx]</span><br><span class=\"line\">    add bx, 2</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-在代码段中使用栈\"><a href=\"#6-2-在代码段中使用栈\" class=\"headerlink\" title=\"6.2 在代码段中使用栈\"></a>6.2 在代码段中使用栈</h4><p>利用栈将程序中定义的数据逆序存放：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codeseg</span><br><span class=\"line\">codeseg segment</span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H</span><br><span class=\"line\">    dw 0, 0, 0, 0, 0, 0, 0, 0   ;用dw定义8个字型数据，</span><br><span class=\"line\">                                ;程序加载后，将取得8个字的内存空间，存放这8个数据</span><br><span class=\"line\">                                ;后面的程序中将这段空间当作栈来使用</span><br><span class=\"line\"></span><br><span class=\"line\">start:  mov ax, cs</span><br><span class=\"line\">        mov ss, ax</span><br><span class=\"line\">        mov sp, 32              ;将设置栈顶ss:sp指向cs:32</span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     push cs:[bx]            ;将代码段0-16单元中的8个字型数据以此入栈</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s1:     pop cs:[bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">codeseg ends</span><br><span class=\"line\">end start                       ;指明程序的入口地址在start处</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数据、代码、栈放入不同的段\"><a href=\"#将数据、代码、栈放入不同的段\" class=\"headerlink\" title=\"将数据、代码、栈放入不同的段\"></a>将数据、代码、栈放入不同的段</h4><p>首先看一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data, ss:stack</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    dw 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov ax, stack</span><br><span class=\"line\">        mov ss, ax</span><br><span class=\"line\">        mov sp, 16      ;设置栈顶ss:sp指向stack:16</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, data</span><br><span class=\"line\">        mov ds, ax      ;ds指向data段</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0       ;ds:bx指向data段的第一个单元</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     push [bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s1:     pop [bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">    </span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>定义多个段的方法：与之前定义代码段的方法没有区别，只是对于不同的段，要有不同的段名</p>\n<p>对段地址的引用：在程序中，段名就相当于一个标号，代表了段地址。所以指令<code>mov ax, data</code>的含义就是将名称为<code>data</code>的段的段地址送入<code>ax</code>。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。注意：8086CPU不允许将一个数值直接送入段寄存器，所以对段名的引用：如指令<code>mov ds, data</code>中的<code>data</code>将被编译器处理为一个表示段地址的数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, ds:[6]</span><br></pre></td></tr></table></figure>\n\n<p>CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第六章-包含多个段的程序\"><a href=\"#第六章-包含多个段的程序\" class=\"headerlink\" title=\"第六章 包含多个段的程序\"></a>第六章 包含多个段的程序</h3><p>在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所在的空间和其他程序以及系统自己的空间相冲突。操作系统允许的情况下，程序可以取得任意容量的空间。</p>\n<p>程序取得所需空间的方法有两种：加载程序时为程序分配，程序执行过程中向系统申请。</p>\n<h4 id=\"6-1-在代码段中使用数据\"><a href=\"#6-1-在代码段中使用数据\" class=\"headerlink\" title=\"6.1 在代码段中使用数据\"></a>6.1 在代码段中使用数据</h4><p>从规范的角度讲，是不能自己随便决定使用哪段空间的，应该让系统来分配空间。我们可以在程序中定义希望处理的数据，这些数据就会被编译、链接而作为程序的一部分被写入到可执行文件中，这样程序被加载到内存时，数据也被加载到内存中，此时就获得了空间。</p>\n<p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p>\n<p>可执行文件中的描述信息指明CPU的CS:IP指向程序的哪一条执行指令。程序来源于源程序中的汇编指令和定义的数据：描述信息则主要是编译、链接程序对源程序中相关伪指令进行处理所得到的信息。</p>\n<p>程序框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">    ; 数据</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    ; 代码</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asssume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0fedH, 0cbaH, 0987H</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s:  add ax, cs:[bx]</span><br><span class=\"line\">    add bx, 2</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-在代码段中使用栈\"><a href=\"#6-2-在代码段中使用栈\" class=\"headerlink\" title=\"6.2 在代码段中使用栈\"></a>6.2 在代码段中使用栈</h4><p>利用栈将程序中定义的数据逆序存放：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codeseg</span><br><span class=\"line\">codeseg segment</span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H</span><br><span class=\"line\">    dw 0, 0, 0, 0, 0, 0, 0, 0   ;用dw定义8个字型数据，</span><br><span class=\"line\">                                ;程序加载后，将取得8个字的内存空间，存放这8个数据</span><br><span class=\"line\">                                ;后面的程序中将这段空间当作栈来使用</span><br><span class=\"line\"></span><br><span class=\"line\">start:  mov ax, cs</span><br><span class=\"line\">        mov ss, ax</span><br><span class=\"line\">        mov sp, 32              ;将设置栈顶ss:sp指向cs:32</span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     push cs:[bx]            ;将代码段0-16单元中的8个字型数据以此入栈</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s1:     pop cs:[bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">codeseg ends</span><br><span class=\"line\">end start                       ;指明程序的入口地址在start处</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将数据、代码、栈放入不同的段\"><a href=\"#将数据、代码、栈放入不同的段\" class=\"headerlink\" title=\"将数据、代码、栈放入不同的段\"></a>将数据、代码、栈放入不同的段</h4><p>首先看一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data, ss:stack</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0cbaH, 0987H</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    dw 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov ax, stack</span><br><span class=\"line\">        mov ss, ax</span><br><span class=\"line\">        mov sp, 16      ;设置栈顶ss:sp指向stack:16</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, data</span><br><span class=\"line\">        mov ds, ax      ;ds指向data段</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0       ;ds:bx指向data段的第一个单元</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     push [bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 8</span><br><span class=\"line\"></span><br><span class=\"line\">s1:     pop [bx]</span><br><span class=\"line\">        add bx, 2</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">    </span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>定义多个段的方法：与之前定义代码段的方法没有区别，只是对于不同的段，要有不同的段名</p>\n<p>对段地址的引用：在程序中，段名就相当于一个标号，代表了段地址。所以指令<code>mov ax, data</code>的含义就是将名称为<code>data</code>的段的段地址送入<code>ax</code>。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。注意：8086CPU不允许将一个数值直接送入段寄存器，所以对段名的引用：如指令<code>mov ds, data</code>中的<code>data</code>将被编译器处理为一个表示段地址的数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, data</span><br><span class=\"line\">mov ds, ax</span><br><span class=\"line\">mov ax, ds:[6]</span><br></pre></td></tr></table></figure>\n\n<p>CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>\n"},{"title":"汇编语言-更灵活的定位内存地址的方法","data":"2020-08-11T13:50:00.000Z","updated":"2020-08-11T13:50:00.000Z","_content":"\n### 第七章 更灵活的定位内存地址的方法\n\n#### and和or指令\n\nand指令：逻辑与指令，按位进行与运算；or指令：逻辑或指令，按位进行或运算\n\n#### 关于ASCII码\n\n![ASCII](../images/app-encoding.ascii.png)\n\n#### 以字符形式给出的数据\n\n汇编中用'……'的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。\n\n```\nassume ds:data\ndata segment\n    db 'unix'\n    db 'fork'\ndata ends\n\ncode segment\nstart:  mov al, 'a'\n        mov bl, 'b'\n        mov ax, 4c00H\n        int 21H\ncode ends\nend start\n```\n\n上面源代码中：`db 'unix'`相当于`db 75H, 6EH, 49H, 58H`，`mov al, 'a'`相当于`mov al, 64H`\n\n#### 大小写转化的问题\n\n```\nassume cs:code, ds:data\ndata segment\n    db 'BaSic'\n    db 'iNfOrMaTiOn'\ndata ends\n\ncode segment\nstart:  mov ax, data\n        mov ds, ax\n        mov bx, 0\n        mov cx, 5\n\ns0:     mov al, [bx]\n        and al, 11011111B\n        mov [bx], al\n        inc bx\n        loop s0\n\n        mov bx, 5\n        mov cx, 11\n\ns1      mov al, [bx]\n        or al, 00100000B\n        mov [bx], al\n        inc bx\n        loop s1\n\n        mov ax, 4c00H\n        int 21H\n\ncode ends\nend start\n```\n\n#### [bx+idata]\n\n[bx+idata]表示一个内存单元，它的偏移地址为`(bx)+idata`(bx中的数值加上idata)\n\n例如：`mov ax, [bx+100]`表示偏移地址为`bx`中的数值加上200，段地址在ds中，数学化的描述为：`(ax)=((ds)*16+(bx)+200)`，该指令也可以写成如下格式\n\n```\nmov ax, [200+bx]\nmov ax, 100[bx]\nmov ax, [bx].200\n```\n\n#### 用[bx+idata]的方式进行数组的处理\n\n```\nassume cs:code, ds:data\ndata segment\n    db 'BaSiC'\n    db 'MinIX'\ndata ends\n\ncode segment\nstart:\n    mov ax, data\n    mov ds, ax\n    \n    mov bx, 0\n    mov cx, 5\n\ns:\n    mov al, [bx]\n    and al, 11011111B\n    mov [bx], al\n    mov al, [bx+5]\n    or al, 00100000B\n    mov [bx+5], al\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend start\n```\n\n#### SI和DI\n\nSI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。\n\n#### [bx+si]和[bx+di]\n\n前面用`[bx(si/di)]`和`[bx(si/di)+idata]`的方式来指明一个内存单元，而`[bx+si]`和`[bx+di]`的方式更加灵活\n\n`[bx+si]`表示一个内存单元，它的偏移地址为`(bx)+(si)`，即`bx`中的数值加上`si`上的数值。\n\n`mov ax, [bx+si]`的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中；数学描述为：`(ax)=((ds)*16+(bx)+(si))`；该指令也可以写成以下格式：\n\n```\nmov ax, [bx][si]\n```\n\n#### [bx+si+idata]和[bx+di+idata]\n\n`[bx+si+idata]`和`[bx+di+idata]`的含义类似，都表示一个内存单元，它的偏移地址为`(bx)+(si)+idata`（即bx中的数值加上si中的数值再加上idata）\n\n`mov ax, [bx+si+idata]`的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中；数学描述为：`(ax)=((ds)*16+(bx)+(si)+idata)`；该指令也可以写成以下格式：\n\n```\nmov ax, [bx+200+si]\nmov ax, [200+bx+si]\nmov ax, 200[bx][si]\nmov ax, [bx].200[si]\nmov ax, [bx][si].200\n```\n\n#### 不同寻址方式的灵活应用\n\n对比几种定位内存地址的方式（可称为寻址方式），有以下几种形式：\n\n* `[idata]`用一个常量来表示地址，可用于直接定位一个内存单元\n* `[bx]`用一个变量来标识内存地址，可用于间接定位一个内存单元\n* `[bx+idata]`用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元\n* `[bx+si]`用两个变量表示地址\n* `[bx+si+idata]`用两个变量和一个常量表示地址\n\n**问题7.6-7.8**\n\n\n","source":"_posts/assembly/7-address-locate.md","raw":"---\ntitle: 汇编语言-更灵活的定位内存地址的方法\ndata: 2020-08-11 21:50:00\nupdated: 2020-08-11 21:50:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第七章 更灵活的定位内存地址的方法\n\n#### and和or指令\n\nand指令：逻辑与指令，按位进行与运算；or指令：逻辑或指令，按位进行或运算\n\n#### 关于ASCII码\n\n![ASCII](../images/app-encoding.ascii.png)\n\n#### 以字符形式给出的数据\n\n汇编中用'……'的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。\n\n```\nassume ds:data\ndata segment\n    db 'unix'\n    db 'fork'\ndata ends\n\ncode segment\nstart:  mov al, 'a'\n        mov bl, 'b'\n        mov ax, 4c00H\n        int 21H\ncode ends\nend start\n```\n\n上面源代码中：`db 'unix'`相当于`db 75H, 6EH, 49H, 58H`，`mov al, 'a'`相当于`mov al, 64H`\n\n#### 大小写转化的问题\n\n```\nassume cs:code, ds:data\ndata segment\n    db 'BaSic'\n    db 'iNfOrMaTiOn'\ndata ends\n\ncode segment\nstart:  mov ax, data\n        mov ds, ax\n        mov bx, 0\n        mov cx, 5\n\ns0:     mov al, [bx]\n        and al, 11011111B\n        mov [bx], al\n        inc bx\n        loop s0\n\n        mov bx, 5\n        mov cx, 11\n\ns1      mov al, [bx]\n        or al, 00100000B\n        mov [bx], al\n        inc bx\n        loop s1\n\n        mov ax, 4c00H\n        int 21H\n\ncode ends\nend start\n```\n\n#### [bx+idata]\n\n[bx+idata]表示一个内存单元，它的偏移地址为`(bx)+idata`(bx中的数值加上idata)\n\n例如：`mov ax, [bx+100]`表示偏移地址为`bx`中的数值加上200，段地址在ds中，数学化的描述为：`(ax)=((ds)*16+(bx)+200)`，该指令也可以写成如下格式\n\n```\nmov ax, [200+bx]\nmov ax, 100[bx]\nmov ax, [bx].200\n```\n\n#### 用[bx+idata]的方式进行数组的处理\n\n```\nassume cs:code, ds:data\ndata segment\n    db 'BaSiC'\n    db 'MinIX'\ndata ends\n\ncode segment\nstart:\n    mov ax, data\n    mov ds, ax\n    \n    mov bx, 0\n    mov cx, 5\n\ns:\n    mov al, [bx]\n    and al, 11011111B\n    mov [bx], al\n    mov al, [bx+5]\n    or al, 00100000B\n    mov [bx+5], al\n    inc bx\n    loop s\n\n    mov ax, 4c00h\n    int 21h\n\ncode ends\nend start\n```\n\n#### SI和DI\n\nSI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。\n\n#### [bx+si]和[bx+di]\n\n前面用`[bx(si/di)]`和`[bx(si/di)+idata]`的方式来指明一个内存单元，而`[bx+si]`和`[bx+di]`的方式更加灵活\n\n`[bx+si]`表示一个内存单元，它的偏移地址为`(bx)+(si)`，即`bx`中的数值加上`si`上的数值。\n\n`mov ax, [bx+si]`的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中；数学描述为：`(ax)=((ds)*16+(bx)+(si))`；该指令也可以写成以下格式：\n\n```\nmov ax, [bx][si]\n```\n\n#### [bx+si+idata]和[bx+di+idata]\n\n`[bx+si+idata]`和`[bx+di+idata]`的含义类似，都表示一个内存单元，它的偏移地址为`(bx)+(si)+idata`（即bx中的数值加上si中的数值再加上idata）\n\n`mov ax, [bx+si+idata]`的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中；数学描述为：`(ax)=((ds)*16+(bx)+(si)+idata)`；该指令也可以写成以下格式：\n\n```\nmov ax, [bx+200+si]\nmov ax, [200+bx+si]\nmov ax, 200[bx][si]\nmov ax, [bx].200[si]\nmov ax, [bx][si].200\n```\n\n#### 不同寻址方式的灵活应用\n\n对比几种定位内存地址的方式（可称为寻址方式），有以下几种形式：\n\n* `[idata]`用一个常量来表示地址，可用于直接定位一个内存单元\n* `[bx]`用一个变量来标识内存地址，可用于间接定位一个内存单元\n* `[bx+idata]`用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元\n* `[bx+si]`用两个变量表示地址\n* `[bx+si+idata]`用两个变量和一个常量表示地址\n\n**问题7.6-7.8**\n\n\n","slug":"assembly/7-address-locate","published":1,"date":"2020-08-15T15:06:21.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8m000kq1fw7p6lcpc5","content":"<h3 id=\"第七章-更灵活的定位内存地址的方法\"><a href=\"#第七章-更灵活的定位内存地址的方法\" class=\"headerlink\" title=\"第七章 更灵活的定位内存地址的方法\"></a>第七章 更灵活的定位内存地址的方法</h3><h4 id=\"and和or指令\"><a href=\"#and和or指令\" class=\"headerlink\" title=\"and和or指令\"></a>and和or指令</h4><p>and指令：逻辑与指令，按位进行与运算；or指令：逻辑或指令，按位进行或运算</p>\n<h4 id=\"关于ASCII码\"><a href=\"#关于ASCII码\" class=\"headerlink\" title=\"关于ASCII码\"></a>关于ASCII码</h4><p><img src=\"../images/app-encoding.ascii.png\" alt=\"ASCII\"></p>\n<h4 id=\"以字符形式给出的数据\"><a href=\"#以字符形式给出的数据\" class=\"headerlink\" title=\"以字符形式给出的数据\"></a>以字符形式给出的数据</h4><p>汇编中用’……’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;unix&#39;</span><br><span class=\"line\">    db &#39;fork&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov al, &#39;a&#39;</span><br><span class=\"line\">        mov bl, &#39;b&#39;</span><br><span class=\"line\">        mov ax, 4c00H</span><br><span class=\"line\">        int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>上面源代码中：<code>db &#39;unix&#39;</code>相当于<code>db 75H, 6EH, 49H, 58H</code>，<code>mov al, &#39;a&#39;</code>相当于<code>mov al, 64H</code></p>\n<h4 id=\"大小写转化的问题\"><a href=\"#大小写转化的问题\" class=\"headerlink\" title=\"大小写转化的问题\"></a>大小写转化的问题</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;BaSic&#39;</span><br><span class=\"line\">    db &#39;iNfOrMaTiOn&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov ax, data</span><br><span class=\"line\">        mov ds, ax</span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 5</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     mov al, [bx]</span><br><span class=\"line\">        and al, 11011111B</span><br><span class=\"line\">        mov [bx], al</span><br><span class=\"line\">        inc bx</span><br><span class=\"line\">        loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 5</span><br><span class=\"line\">        mov cx, 11</span><br><span class=\"line\"></span><br><span class=\"line\">s1      mov al, [bx]</span><br><span class=\"line\">        or al, 00100000B</span><br><span class=\"line\">        mov [bx], al</span><br><span class=\"line\">        inc bx</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00H</span><br><span class=\"line\">        int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bx-idata\"><a href=\"#bx-idata\" class=\"headerlink\" title=\"[bx+idata]\"></a>[bx+idata]</h4><p>[bx+idata]表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>(bx中的数值加上idata)</p>\n<p>例如：<code>mov ax, [bx+100]</code>表示偏移地址为<code>bx</code>中的数值加上200，段地址在ds中，数学化的描述为：<code>(ax)=((ds)*16+(bx)+200)</code>，该指令也可以写成如下格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [200+bx]</span><br><span class=\"line\">mov ax, 100[bx]</span><br><span class=\"line\">mov ax, [bx].200</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用-bx-idata-的方式进行数组的处理\"><a href=\"#用-bx-idata-的方式进行数组的处理\" class=\"headerlink\" title=\"用[bx+idata]的方式进行数组的处理\"></a>用[bx+idata]的方式进行数组的处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;BaSiC&#39;</span><br><span class=\"line\">    db &#39;MinIX&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, data</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\">    </span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov cx, 5</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">    mov al, [bx]</span><br><span class=\"line\">    and al, 11011111B</span><br><span class=\"line\">    mov [bx], al</span><br><span class=\"line\">    mov al, [bx+5]</span><br><span class=\"line\">    or al, 00100000B</span><br><span class=\"line\">    mov [bx+5], al</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SI和DI\"><a href=\"#SI和DI\" class=\"headerlink\" title=\"SI和DI\"></a>SI和DI</h4><p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。</p>\n<h4 id=\"bx-si-和-bx-di\"><a href=\"#bx-si-和-bx-di\" class=\"headerlink\" title=\"[bx+si]和[bx+di]\"></a>[bx+si]和[bx+di]</h4><p>前面用<code>[bx(si/di)]</code>和<code>[bx(si/di)+idata]</code>的方式来指明一个内存单元，而<code>[bx+si]</code>和<code>[bx+di]</code>的方式更加灵活</p>\n<p><code>[bx+si]</code>表示一个内存单元，它的偏移地址为<code>(bx)+(si)</code>，即<code>bx</code>中的数值加上<code>si</code>上的数值。</p>\n<p><code>mov ax, [bx+si]</code>的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中；数学描述为：<code>(ax)=((ds)*16+(bx)+(si))</code>；该指令也可以写成以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx][si]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bx-si-idata-和-bx-di-idata\"><a href=\"#bx-si-idata-和-bx-di-idata\" class=\"headerlink\" title=\"[bx+si+idata]和[bx+di+idata]\"></a>[bx+si+idata]和[bx+di+idata]</h4><p><code>[bx+si+idata]</code>和<code>[bx+di+idata]</code>的含义类似，都表示一个内存单元，它的偏移地址为<code>(bx)+(si)+idata</code>（即bx中的数值加上si中的数值再加上idata）</p>\n<p><code>mov ax, [bx+si+idata]</code>的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中；数学描述为：<code>(ax)=((ds)*16+(bx)+(si)+idata)</code>；该指令也可以写成以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx+200+si]</span><br><span class=\"line\">mov ax, [200+bx+si]</span><br><span class=\"line\">mov ax, 200[bx][si]</span><br><span class=\"line\">mov ax, [bx].200[si]</span><br><span class=\"line\">mov ax, [bx][si].200</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不同寻址方式的灵活应用\"><a href=\"#不同寻址方式的灵活应用\" class=\"headerlink\" title=\"不同寻址方式的灵活应用\"></a>不同寻址方式的灵活应用</h4><p>对比几种定位内存地址的方式（可称为寻址方式），有以下几种形式：</p>\n<ul>\n<li><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元</li>\n<li><code>[bx]</code>用一个变量来标识内存地址，可用于间接定位一个内存单元</li>\n<li><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li>\n<li><code>[bx+si]</code>用两个变量表示地址</li>\n<li><code>[bx+si+idata]</code>用两个变量和一个常量表示地址</li>\n</ul>\n<p><strong>问题7.6-7.8</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第七章-更灵活的定位内存地址的方法\"><a href=\"#第七章-更灵活的定位内存地址的方法\" class=\"headerlink\" title=\"第七章 更灵活的定位内存地址的方法\"></a>第七章 更灵活的定位内存地址的方法</h3><h4 id=\"and和or指令\"><a href=\"#and和or指令\" class=\"headerlink\" title=\"and和or指令\"></a>and和or指令</h4><p>and指令：逻辑与指令，按位进行与运算；or指令：逻辑或指令，按位进行或运算</p>\n<h4 id=\"关于ASCII码\"><a href=\"#关于ASCII码\" class=\"headerlink\" title=\"关于ASCII码\"></a>关于ASCII码</h4><p><img src=\"../images/app-encoding.ascii.png\" alt=\"ASCII\"></p>\n<h4 id=\"以字符形式给出的数据\"><a href=\"#以字符形式给出的数据\" class=\"headerlink\" title=\"以字符形式给出的数据\"></a>以字符形式给出的数据</h4><p>汇编中用’……’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;unix&#39;</span><br><span class=\"line\">    db &#39;fork&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov al, &#39;a&#39;</span><br><span class=\"line\">        mov bl, &#39;b&#39;</span><br><span class=\"line\">        mov ax, 4c00H</span><br><span class=\"line\">        int 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>上面源代码中：<code>db &#39;unix&#39;</code>相当于<code>db 75H, 6EH, 49H, 58H</code>，<code>mov al, &#39;a&#39;</code>相当于<code>mov al, 64H</code></p>\n<h4 id=\"大小写转化的问题\"><a href=\"#大小写转化的问题\" class=\"headerlink\" title=\"大小写转化的问题\"></a>大小写转化的问题</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;BaSic&#39;</span><br><span class=\"line\">    db &#39;iNfOrMaTiOn&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:  mov ax, data</span><br><span class=\"line\">        mov ds, ax</span><br><span class=\"line\">        mov bx, 0</span><br><span class=\"line\">        mov cx, 5</span><br><span class=\"line\"></span><br><span class=\"line\">s0:     mov al, [bx]</span><br><span class=\"line\">        and al, 11011111B</span><br><span class=\"line\">        mov [bx], al</span><br><span class=\"line\">        inc bx</span><br><span class=\"line\">        loop s0</span><br><span class=\"line\"></span><br><span class=\"line\">        mov bx, 5</span><br><span class=\"line\">        mov cx, 11</span><br><span class=\"line\"></span><br><span class=\"line\">s1      mov al, [bx]</span><br><span class=\"line\">        or al, 00100000B</span><br><span class=\"line\">        mov [bx], al</span><br><span class=\"line\">        inc bx</span><br><span class=\"line\">        loop s1</span><br><span class=\"line\"></span><br><span class=\"line\">        mov ax, 4c00H</span><br><span class=\"line\">        int 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bx-idata\"><a href=\"#bx-idata\" class=\"headerlink\" title=\"[bx+idata]\"></a>[bx+idata]</h4><p>[bx+idata]表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>(bx中的数值加上idata)</p>\n<p>例如：<code>mov ax, [bx+100]</code>表示偏移地址为<code>bx</code>中的数值加上200，段地址在ds中，数学化的描述为：<code>(ax)=((ds)*16+(bx)+200)</code>，该指令也可以写成如下格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [200+bx]</span><br><span class=\"line\">mov ax, 100[bx]</span><br><span class=\"line\">mov ax, [bx].200</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用-bx-idata-的方式进行数组的处理\"><a href=\"#用-bx-idata-的方式进行数组的处理\" class=\"headerlink\" title=\"用[bx+idata]的方式进行数组的处理\"></a>用[bx+idata]的方式进行数组的处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code, ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">    db &#39;BaSiC&#39;</span><br><span class=\"line\">    db &#39;MinIX&#39;</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, data</span><br><span class=\"line\">    mov ds, ax</span><br><span class=\"line\">    </span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    mov cx, 5</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">    mov al, [bx]</span><br><span class=\"line\">    and al, 11011111B</span><br><span class=\"line\">    mov [bx], al</span><br><span class=\"line\">    mov al, [bx+5]</span><br><span class=\"line\">    or al, 00100000B</span><br><span class=\"line\">    mov [bx+5], al</span><br><span class=\"line\">    inc bx</span><br><span class=\"line\">    loop s</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SI和DI\"><a href=\"#SI和DI\" class=\"headerlink\" title=\"SI和DI\"></a>SI和DI</h4><p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。</p>\n<h4 id=\"bx-si-和-bx-di\"><a href=\"#bx-si-和-bx-di\" class=\"headerlink\" title=\"[bx+si]和[bx+di]\"></a>[bx+si]和[bx+di]</h4><p>前面用<code>[bx(si/di)]</code>和<code>[bx(si/di)+idata]</code>的方式来指明一个内存单元，而<code>[bx+si]</code>和<code>[bx+di]</code>的方式更加灵活</p>\n<p><code>[bx+si]</code>表示一个内存单元，它的偏移地址为<code>(bx)+(si)</code>，即<code>bx</code>中的数值加上<code>si</code>上的数值。</p>\n<p><code>mov ax, [bx+si]</code>的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中；数学描述为：<code>(ax)=((ds)*16+(bx)+(si))</code>；该指令也可以写成以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx][si]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bx-si-idata-和-bx-di-idata\"><a href=\"#bx-si-idata-和-bx-di-idata\" class=\"headerlink\" title=\"[bx+si+idata]和[bx+di+idata]\"></a>[bx+si+idata]和[bx+di+idata]</h4><p><code>[bx+si+idata]</code>和<code>[bx+di+idata]</code>的含义类似，都表示一个内存单元，它的偏移地址为<code>(bx)+(si)+idata</code>（即bx中的数值加上si中的数值再加上idata）</p>\n<p><code>mov ax, [bx+si+idata]</code>的含义为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中；数学描述为：<code>(ax)=((ds)*16+(bx)+(si)+idata)</code>；该指令也可以写成以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, [bx+200+si]</span><br><span class=\"line\">mov ax, [200+bx+si]</span><br><span class=\"line\">mov ax, 200[bx][si]</span><br><span class=\"line\">mov ax, [bx].200[si]</span><br><span class=\"line\">mov ax, [bx][si].200</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不同寻址方式的灵活应用\"><a href=\"#不同寻址方式的灵活应用\" class=\"headerlink\" title=\"不同寻址方式的灵活应用\"></a>不同寻址方式的灵活应用</h4><p>对比几种定位内存地址的方式（可称为寻址方式），有以下几种形式：</p>\n<ul>\n<li><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元</li>\n<li><code>[bx]</code>用一个变量来标识内存地址，可用于间接定位一个内存单元</li>\n<li><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li>\n<li><code>[bx+si]</code>用两个变量表示地址</li>\n<li><code>[bx+si+idata]</code>用两个变量和一个常量表示地址</li>\n</ul>\n<p><strong>问题7.6-7.8</strong></p>\n"},{"title":"汇编语言-转移指令的原理","data":"2020-08-12T14:44:00.000Z","updated":"2020-08-15T13:44:00.000Z","_content":"\n### 第九章 转移指令的原理\n\n可以修改IP，或同事修改CS和IP的指令统称为转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处的代码的指令。\n\n8086 CPU的转移行为有以下几类：\n\n* 只修改IP时，称为段内转移，比如：`jmp ax`\n* 同时修改CS和IP时，称为段间转移，比如：`jmp 1000:0`\n\n由于转移指令对IP修改范围不同，段内转移又分为：短转移和近转移\n\n* 短转移IP的修改范围为-128~127.\n* 近转移IP的修改范围为-32768~32767.\n\n8086 CPU的转移指令分为以下几类：\n\n* 无条件转移指令（如：jmp）\n* 条件转移指令\n* 循环指令（如：loop）\n* 过程\n* 中断\n\n#### 操作符offset\n\n操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。例如：\n\n```\nassume cs:code\ncode segment\nstart:\n    mov ax, offset start;   ;相当于mov ax, 0\n\ns:\n    mov ax, offset s        ;相当于mov ax, 3\ncode ends\nend start\n```\n\n`mov ax, offset start`相当于指令`mov ax, 0`，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；`mov ax, offset s`相当于`mov ax, 3`，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令的长度为3字节，则s的偏移地址为3\n\n#### jmp指令\n\njmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP\n\njmp指令要给出两种信息：\n\n* 转移的目的地址\n* 转移的举例（段间转移、段内短转移、段内近转移）\n\n不同的给出目的地址的方法，和不同的转移位置，对应不同格式的jmp指令。\n\n#### 依据位移进行转移的jmp指令\n\n```\njmp short 标号 ;(转移标号处执行指令) \n```\n\n这种格式的jmp指令实现的是段内短转移，它对IP的修改范围在-128~127，也就是说，它向前转移时可以最多越过128字节，向后转移最多越过127字节。jmp指令中的short符号说明指令进行的是短转移。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。\n\n`jmp short 标号`指令对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的标号计算出来的。\n\n实际上，指令`jmp short 标号`的功能为：`(IP)=(IP)+8位位移`\n\n* 8位位移 = 标号处的地址-jmp指令后的第一个字节的地址\n* short指明此处的位移为8位位移\n* 8位位移的范围为-128~127，用补码表示\n* 8位位移由编译程序在编译时算出\n\n还有一种指令与`jmp short 标号`类似：`jmp near ptr标号`，它实现的是段内近转移，只不过是16位的位移长度\n\n#### 转移的目的地址在指令中的jmp指令\n\n`jmp far ptr 标号`实现的是段间转移，又称为远转移，功能如下：\n\n* (CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址\n* far ptr指令用标号的段地址和偏移地址修改CS:IP\n\n#### 转移地址在寄存器中的jmp指令\n\n指令格式：jmp 16位寄存器\n功能：(IP)=(16位寄存器)\n\n#### 转移地址在内存中的jmp指令\n\n转移地址在内存中的jmp指令有两种格式：\n\n* jmp word ptr 内存单元地址(段内转移)；功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址\n\n例如：\n\n```\nmov ax, 0123H\nmov ds:[0], ax\njmp word ptr ds:[0]\n;或者\nmov ax, 0123H\nmov [bx], ax\njmp word ptr [bx]\n```\n\n执行后：(IP)=0123H\n\n* jmp dword ptr 内存单元地址(段间转移)；功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址\n* (CS)=(内存单元+2)；(IP)=(内存单元地址)\n\n内存单元地址可用寻址方式的任一格式给出，例如：\n\n```\nmov ax, 0123H\nmov ds:[0], ax\nmov word ptr ds:[2], 0\njmp dword ptr ds:[0]\n;或者\nmov ax, 0123H\nmov [bx], ax\nmov word ptr [bx+2], 0\njmp dword ptr [bx]\n```\n\n执行后，(CS)=0, (IP)=123H，CS:IP指向0000:0123\n\n#### jczx指令\n\njcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127\n\n指令格式：jcxz 标号 （如果(cx)=0，转移到标号处执行）；\n操作：当(cx)=0时，(IP)=(IP)+8位位移。\n\n* 8位位移=标号处的地址-jcxz指令后的第一个字节的地址；\n* 8位位移的范围为-128~127，用补码表示；\n* 8位位移由编译程序在编译时算出\n\n当(cx)!=0时，什么也不做（程序向下执行）\n\n`jcxz 标号` 功能相当于 `if((cx)==0) jmp short 标号`;\n\n#### loop指令\n\nloop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对应IP的修改范围都为-128~127\n\n指令格式：loop 标号（(cx)=(cx)-1,如果(cx)!=0，转移到标号处执行）；\n操作：(cx)=(cx-1)；如果(cx)!=0，(IP)=(IP)+8位位移。\n\n* 8位位移=标号处的地址-loop指令后的第一个字节的地址；\n* 8位位移的范围为-128~127，用补码表示；\n* 8位位移由编译程序在编译时算出\n\n当(cx)!=0时，什么也不做（程序向下执行）\n\n`jcxz 标号` 功能相当于 `(cx)--; if((cx)!=0) jmp short 标号`;\n\n#### 根据位移进行转移的意义\n\n```\njmp short 标号\njmp near ptr 标号\njcxz 标号\nloop 标号\n```\n\n它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，方便了程序段在内存中的浮动装配。\n\n#### 编译器对转移位移超界的检测\n\n根据位移进行转移的指令，转移范围受到转移位移的限制。如果程序转移范围超界的问题，编译时，编译器将报错。\n","source":"_posts/assembly/9-jmp.md","raw":"---\ntitle: 汇编语言-转移指令的原理\ndata: 2020-08-12 22:44:00\nupdated: 2020-08-15 21:44:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第九章 转移指令的原理\n\n可以修改IP，或同事修改CS和IP的指令统称为转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处的代码的指令。\n\n8086 CPU的转移行为有以下几类：\n\n* 只修改IP时，称为段内转移，比如：`jmp ax`\n* 同时修改CS和IP时，称为段间转移，比如：`jmp 1000:0`\n\n由于转移指令对IP修改范围不同，段内转移又分为：短转移和近转移\n\n* 短转移IP的修改范围为-128~127.\n* 近转移IP的修改范围为-32768~32767.\n\n8086 CPU的转移指令分为以下几类：\n\n* 无条件转移指令（如：jmp）\n* 条件转移指令\n* 循环指令（如：loop）\n* 过程\n* 中断\n\n#### 操作符offset\n\n操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。例如：\n\n```\nassume cs:code\ncode segment\nstart:\n    mov ax, offset start;   ;相当于mov ax, 0\n\ns:\n    mov ax, offset s        ;相当于mov ax, 3\ncode ends\nend start\n```\n\n`mov ax, offset start`相当于指令`mov ax, 0`，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；`mov ax, offset s`相当于`mov ax, 3`，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令的长度为3字节，则s的偏移地址为3\n\n#### jmp指令\n\njmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP\n\njmp指令要给出两种信息：\n\n* 转移的目的地址\n* 转移的举例（段间转移、段内短转移、段内近转移）\n\n不同的给出目的地址的方法，和不同的转移位置，对应不同格式的jmp指令。\n\n#### 依据位移进行转移的jmp指令\n\n```\njmp short 标号 ;(转移标号处执行指令) \n```\n\n这种格式的jmp指令实现的是段内短转移，它对IP的修改范围在-128~127，也就是说，它向前转移时可以最多越过128字节，向后转移最多越过127字节。jmp指令中的short符号说明指令进行的是短转移。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。\n\n`jmp short 标号`指令对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的标号计算出来的。\n\n实际上，指令`jmp short 标号`的功能为：`(IP)=(IP)+8位位移`\n\n* 8位位移 = 标号处的地址-jmp指令后的第一个字节的地址\n* short指明此处的位移为8位位移\n* 8位位移的范围为-128~127，用补码表示\n* 8位位移由编译程序在编译时算出\n\n还有一种指令与`jmp short 标号`类似：`jmp near ptr标号`，它实现的是段内近转移，只不过是16位的位移长度\n\n#### 转移的目的地址在指令中的jmp指令\n\n`jmp far ptr 标号`实现的是段间转移，又称为远转移，功能如下：\n\n* (CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址\n* far ptr指令用标号的段地址和偏移地址修改CS:IP\n\n#### 转移地址在寄存器中的jmp指令\n\n指令格式：jmp 16位寄存器\n功能：(IP)=(16位寄存器)\n\n#### 转移地址在内存中的jmp指令\n\n转移地址在内存中的jmp指令有两种格式：\n\n* jmp word ptr 内存单元地址(段内转移)；功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址\n\n例如：\n\n```\nmov ax, 0123H\nmov ds:[0], ax\njmp word ptr ds:[0]\n;或者\nmov ax, 0123H\nmov [bx], ax\njmp word ptr [bx]\n```\n\n执行后：(IP)=0123H\n\n* jmp dword ptr 内存单元地址(段间转移)；功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址\n* (CS)=(内存单元+2)；(IP)=(内存单元地址)\n\n内存单元地址可用寻址方式的任一格式给出，例如：\n\n```\nmov ax, 0123H\nmov ds:[0], ax\nmov word ptr ds:[2], 0\njmp dword ptr ds:[0]\n;或者\nmov ax, 0123H\nmov [bx], ax\nmov word ptr [bx+2], 0\njmp dword ptr [bx]\n```\n\n执行后，(CS)=0, (IP)=123H，CS:IP指向0000:0123\n\n#### jczx指令\n\njcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127\n\n指令格式：jcxz 标号 （如果(cx)=0，转移到标号处执行）；\n操作：当(cx)=0时，(IP)=(IP)+8位位移。\n\n* 8位位移=标号处的地址-jcxz指令后的第一个字节的地址；\n* 8位位移的范围为-128~127，用补码表示；\n* 8位位移由编译程序在编译时算出\n\n当(cx)!=0时，什么也不做（程序向下执行）\n\n`jcxz 标号` 功能相当于 `if((cx)==0) jmp short 标号`;\n\n#### loop指令\n\nloop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对应IP的修改范围都为-128~127\n\n指令格式：loop 标号（(cx)=(cx)-1,如果(cx)!=0，转移到标号处执行）；\n操作：(cx)=(cx-1)；如果(cx)!=0，(IP)=(IP)+8位位移。\n\n* 8位位移=标号处的地址-loop指令后的第一个字节的地址；\n* 8位位移的范围为-128~127，用补码表示；\n* 8位位移由编译程序在编译时算出\n\n当(cx)!=0时，什么也不做（程序向下执行）\n\n`jcxz 标号` 功能相当于 `(cx)--; if((cx)!=0) jmp short 标号`;\n\n#### 根据位移进行转移的意义\n\n```\njmp short 标号\njmp near ptr 标号\njcxz 标号\nloop 标号\n```\n\n它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，方便了程序段在内存中的浮动装配。\n\n#### 编译器对转移位移超界的检测\n\n根据位移进行转移的指令，转移范围受到转移位移的限制。如果程序转移范围超界的问题，编译时，编译器将报错。\n","slug":"assembly/9-jmp","published":1,"date":"2020-08-15T15:06:21.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8n000pq1fwf0jp56mi","content":"<h3 id=\"第九章-转移指令的原理\"><a href=\"#第九章-转移指令的原理\" class=\"headerlink\" title=\"第九章 转移指令的原理\"></a>第九章 转移指令的原理</h3><p>可以修改IP，或同事修改CS和IP的指令统称为转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处的代码的指令。</p>\n<p>8086 CPU的转移行为有以下几类：</p>\n<ul>\n<li>只修改IP时，称为段内转移，比如：<code>jmp ax</code></li>\n<li>同时修改CS和IP时，称为段间转移，比如：<code>jmp 1000:0</code></li>\n</ul>\n<p>由于转移指令对IP修改范围不同，段内转移又分为：短转移和近转移</p>\n<ul>\n<li>短转移IP的修改范围为-128~127.</li>\n<li>近转移IP的修改范围为-32768~32767.</li>\n</ul>\n<p>8086 CPU的转移指令分为以下几类：</p>\n<ul>\n<li>无条件转移指令（如：jmp）</li>\n<li>条件转移指令</li>\n<li>循环指令（如：loop）</li>\n<li>过程</li>\n<li>中断</li>\n</ul>\n<h4 id=\"操作符offset\"><a href=\"#操作符offset\" class=\"headerlink\" title=\"操作符offset\"></a>操作符offset</h4><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, offset start;   ;相当于mov ax, 0</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">    mov ax, offset s        ;相当于mov ax, 3</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p><code>mov ax, offset start</code>相当于指令<code>mov ax, 0</code>，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；<code>mov ax, offset s</code>相当于<code>mov ax, 3</code>，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令的长度为3字节，则s的偏移地址为3</p>\n<h4 id=\"jmp指令\"><a href=\"#jmp指令\" class=\"headerlink\" title=\"jmp指令\"></a>jmp指令</h4><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p>\n<p>jmp指令要给出两种信息：</p>\n<ul>\n<li>转移的目的地址</li>\n<li>转移的举例（段间转移、段内短转移、段内近转移）</li>\n</ul>\n<p>不同的给出目的地址的方法，和不同的转移位置，对应不同格式的jmp指令。</p>\n<h4 id=\"依据位移进行转移的jmp指令\"><a href=\"#依据位移进行转移的jmp指令\" class=\"headerlink\" title=\"依据位移进行转移的jmp指令\"></a>依据位移进行转移的jmp指令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp short 标号 ;(转移标号处执行指令)</span><br></pre></td></tr></table></figure>\n\n<p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围在-128~127，也就是说，它向前转移时可以最多越过128字节，向后转移最多越过127字节。jmp指令中的short符号说明指令进行的是短转移。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。</p>\n<p><code>jmp short 标号</code>指令对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的标号计算出来的。</p>\n<p>实际上，指令<code>jmp short 标号</code>的功能为：<code>(IP)=(IP)+8位位移</code></p>\n<ul>\n<li>8位位移 = 标号处的地址-jmp指令后的第一个字节的地址</li>\n<li>short指明此处的位移为8位位移</li>\n<li>8位位移的范围为-128~127，用补码表示</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>还有一种指令与<code>jmp short 标号</code>类似：<code>jmp near ptr标号</code>，它实现的是段内近转移，只不过是16位的位移长度</p>\n<h4 id=\"转移的目的地址在指令中的jmp指令\"><a href=\"#转移的目的地址在指令中的jmp指令\" class=\"headerlink\" title=\"转移的目的地址在指令中的jmp指令\"></a>转移的目的地址在指令中的jmp指令</h4><p><code>jmp far ptr 标号</code>实现的是段间转移，又称为远转移，功能如下：</p>\n<ul>\n<li>(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</li>\n<li>far ptr指令用标号的段地址和偏移地址修改CS:IP</li>\n</ul>\n<h4 id=\"转移地址在寄存器中的jmp指令\"><a href=\"#转移地址在寄存器中的jmp指令\" class=\"headerlink\" title=\"转移地址在寄存器中的jmp指令\"></a>转移地址在寄存器中的jmp指令</h4><p>指令格式：jmp 16位寄存器<br>功能：(IP)=(16位寄存器)</p>\n<h4 id=\"转移地址在内存中的jmp指令\"><a href=\"#转移地址在内存中的jmp指令\" class=\"headerlink\" title=\"转移地址在内存中的jmp指令\"></a>转移地址在内存中的jmp指令</h4><p>转移地址在内存中的jmp指令有两种格式：</p>\n<ul>\n<li>jmp word ptr 内存单元地址(段内转移)；功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">jmp word ptr ds:[0]</span><br><span class=\"line\">;或者</span><br><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">jmp word ptr [bx]</span><br></pre></td></tr></table></figure>\n\n<p>执行后：(IP)=0123H</p>\n<ul>\n<li>jmp dword ptr 内存单元地址(段间转移)；功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</li>\n<li>(CS)=(内存单元+2)；(IP)=(内存单元地址)</li>\n</ul>\n<p>内存单元地址可用寻址方式的任一格式给出，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">mov word ptr ds:[2], 0</span><br><span class=\"line\">jmp dword ptr ds:[0]</span><br><span class=\"line\">;或者</span><br><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">mov word ptr [bx+2], 0</span><br><span class=\"line\">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>\n\n<p>执行后，(CS)=0, (IP)=123H，CS:IP指向0000:0123</p>\n<h4 id=\"jczx指令\"><a href=\"#jczx指令\" class=\"headerlink\" title=\"jczx指令\"></a>jczx指令</h4><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127</p>\n<p>指令格式：jcxz 标号 （如果(cx)=0，转移到标号处执行）；<br>操作：当(cx)=0时，(IP)=(IP)+8位位移。</p>\n<ul>\n<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>当(cx)!=0时，什么也不做（程序向下执行）</p>\n<p><code>jcxz 标号</code> 功能相当于 <code>if((cx)==0) jmp short 标号</code>;</p>\n<h4 id=\"loop指令\"><a href=\"#loop指令\" class=\"headerlink\" title=\"loop指令\"></a>loop指令</h4><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对应IP的修改范围都为-128~127</p>\n<p>指令格式：loop 标号（(cx)=(cx)-1,如果(cx)!=0，转移到标号处执行）；<br>操作：(cx)=(cx-1)；如果(cx)!=0，(IP)=(IP)+8位位移。</p>\n<ul>\n<li>8位位移=标号处的地址-loop指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>当(cx)!=0时，什么也不做（程序向下执行）</p>\n<p><code>jcxz 标号</code> 功能相当于 <code>(cx)--; if((cx)!=0) jmp short 标号</code>;</p>\n<h4 id=\"根据位移进行转移的意义\"><a href=\"#根据位移进行转移的意义\" class=\"headerlink\" title=\"根据位移进行转移的意义\"></a>根据位移进行转移的意义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp short 标号</span><br><span class=\"line\">jmp near ptr 标号</span><br><span class=\"line\">jcxz 标号</span><br><span class=\"line\">loop 标号</span><br></pre></td></tr></table></figure>\n\n<p>它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，方便了程序段在内存中的浮动装配。</p>\n<h4 id=\"编译器对转移位移超界的检测\"><a href=\"#编译器对转移位移超界的检测\" class=\"headerlink\" title=\"编译器对转移位移超界的检测\"></a>编译器对转移位移超界的检测</h4><p>根据位移进行转移的指令，转移范围受到转移位移的限制。如果程序转移范围超界的问题，编译时，编译器将报错。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第九章-转移指令的原理\"><a href=\"#第九章-转移指令的原理\" class=\"headerlink\" title=\"第九章 转移指令的原理\"></a>第九章 转移指令的原理</h3><p>可以修改IP，或同事修改CS和IP的指令统称为转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处的代码的指令。</p>\n<p>8086 CPU的转移行为有以下几类：</p>\n<ul>\n<li>只修改IP时，称为段内转移，比如：<code>jmp ax</code></li>\n<li>同时修改CS和IP时，称为段间转移，比如：<code>jmp 1000:0</code></li>\n</ul>\n<p>由于转移指令对IP修改范围不同，段内转移又分为：短转移和近转移</p>\n<ul>\n<li>短转移IP的修改范围为-128~127.</li>\n<li>近转移IP的修改范围为-32768~32767.</li>\n</ul>\n<p>8086 CPU的转移指令分为以下几类：</p>\n<ul>\n<li>无条件转移指令（如：jmp）</li>\n<li>条件转移指令</li>\n<li>循环指令（如：loop）</li>\n<li>过程</li>\n<li>中断</li>\n</ul>\n<h4 id=\"操作符offset\"><a href=\"#操作符offset\" class=\"headerlink\" title=\"操作符offset\"></a>操作符offset</h4><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, offset start;   ;相当于mov ax, 0</span><br><span class=\"line\"></span><br><span class=\"line\">s:</span><br><span class=\"line\">    mov ax, offset s        ;相当于mov ax, 3</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p><code>mov ax, offset start</code>相当于指令<code>mov ax, 0</code>，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；<code>mov ax, offset s</code>相当于<code>mov ax, 3</code>，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令的长度为3字节，则s的偏移地址为3</p>\n<h4 id=\"jmp指令\"><a href=\"#jmp指令\" class=\"headerlink\" title=\"jmp指令\"></a>jmp指令</h4><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p>\n<p>jmp指令要给出两种信息：</p>\n<ul>\n<li>转移的目的地址</li>\n<li>转移的举例（段间转移、段内短转移、段内近转移）</li>\n</ul>\n<p>不同的给出目的地址的方法，和不同的转移位置，对应不同格式的jmp指令。</p>\n<h4 id=\"依据位移进行转移的jmp指令\"><a href=\"#依据位移进行转移的jmp指令\" class=\"headerlink\" title=\"依据位移进行转移的jmp指令\"></a>依据位移进行转移的jmp指令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp short 标号 ;(转移标号处执行指令)</span><br></pre></td></tr></table></figure>\n\n<p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围在-128~127，也就是说，它向前转移时可以最多越过128字节，向后转移最多越过127字节。jmp指令中的short符号说明指令进行的是短转移。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。</p>\n<p><code>jmp short 标号</code>指令对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的标号计算出来的。</p>\n<p>实际上，指令<code>jmp short 标号</code>的功能为：<code>(IP)=(IP)+8位位移</code></p>\n<ul>\n<li>8位位移 = 标号处的地址-jmp指令后的第一个字节的地址</li>\n<li>short指明此处的位移为8位位移</li>\n<li>8位位移的范围为-128~127，用补码表示</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>还有一种指令与<code>jmp short 标号</code>类似：<code>jmp near ptr标号</code>，它实现的是段内近转移，只不过是16位的位移长度</p>\n<h4 id=\"转移的目的地址在指令中的jmp指令\"><a href=\"#转移的目的地址在指令中的jmp指令\" class=\"headerlink\" title=\"转移的目的地址在指令中的jmp指令\"></a>转移的目的地址在指令中的jmp指令</h4><p><code>jmp far ptr 标号</code>实现的是段间转移，又称为远转移，功能如下：</p>\n<ul>\n<li>(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</li>\n<li>far ptr指令用标号的段地址和偏移地址修改CS:IP</li>\n</ul>\n<h4 id=\"转移地址在寄存器中的jmp指令\"><a href=\"#转移地址在寄存器中的jmp指令\" class=\"headerlink\" title=\"转移地址在寄存器中的jmp指令\"></a>转移地址在寄存器中的jmp指令</h4><p>指令格式：jmp 16位寄存器<br>功能：(IP)=(16位寄存器)</p>\n<h4 id=\"转移地址在内存中的jmp指令\"><a href=\"#转移地址在内存中的jmp指令\" class=\"headerlink\" title=\"转移地址在内存中的jmp指令\"></a>转移地址在内存中的jmp指令</h4><p>转移地址在内存中的jmp指令有两种格式：</p>\n<ul>\n<li>jmp word ptr 内存单元地址(段内转移)；功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">jmp word ptr ds:[0]</span><br><span class=\"line\">;或者</span><br><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">jmp word ptr [bx]</span><br></pre></td></tr></table></figure>\n\n<p>执行后：(IP)=0123H</p>\n<ul>\n<li>jmp dword ptr 内存单元地址(段间转移)；功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</li>\n<li>(CS)=(内存单元+2)；(IP)=(内存单元地址)</li>\n</ul>\n<p>内存单元地址可用寻址方式的任一格式给出，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">mov word ptr ds:[2], 0</span><br><span class=\"line\">jmp dword ptr ds:[0]</span><br><span class=\"line\">;或者</span><br><span class=\"line\">mov ax, 0123H</span><br><span class=\"line\">mov [bx], ax</span><br><span class=\"line\">mov word ptr [bx+2], 0</span><br><span class=\"line\">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>\n\n<p>执行后，(CS)=0, (IP)=123H，CS:IP指向0000:0123</p>\n<h4 id=\"jczx指令\"><a href=\"#jczx指令\" class=\"headerlink\" title=\"jczx指令\"></a>jczx指令</h4><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127</p>\n<p>指令格式：jcxz 标号 （如果(cx)=0，转移到标号处执行）；<br>操作：当(cx)=0时，(IP)=(IP)+8位位移。</p>\n<ul>\n<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>当(cx)!=0时，什么也不做（程序向下执行）</p>\n<p><code>jcxz 标号</code> 功能相当于 <code>if((cx)==0) jmp short 标号</code>;</p>\n<h4 id=\"loop指令\"><a href=\"#loop指令\" class=\"headerlink\" title=\"loop指令\"></a>loop指令</h4><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对应IP的修改范围都为-128~127</p>\n<p>指令格式：loop 标号（(cx)=(cx)-1,如果(cx)!=0，转移到标号处执行）；<br>操作：(cx)=(cx-1)；如果(cx)!=0，(IP)=(IP)+8位位移。</p>\n<ul>\n<li>8位位移=标号处的地址-loop指令后的第一个字节的地址；</li>\n<li>8位位移的范围为-128~127，用补码表示；</li>\n<li>8位位移由编译程序在编译时算出</li>\n</ul>\n<p>当(cx)!=0时，什么也不做（程序向下执行）</p>\n<p><code>jcxz 标号</code> 功能相当于 <code>(cx)--; if((cx)!=0) jmp short 标号</code>;</p>\n<h4 id=\"根据位移进行转移的意义\"><a href=\"#根据位移进行转移的意义\" class=\"headerlink\" title=\"根据位移进行转移的意义\"></a>根据位移进行转移的意义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp short 标号</span><br><span class=\"line\">jmp near ptr 标号</span><br><span class=\"line\">jcxz 标号</span><br><span class=\"line\">loop 标号</span><br></pre></td></tr></table></figure>\n\n<p>它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，方便了程序段在内存中的浮动装配。</p>\n<h4 id=\"编译器对转移位移超界的检测\"><a href=\"#编译器对转移位移超界的检测\" class=\"headerlink\" title=\"编译器对转移位移超界的检测\"></a>编译器对转移位移超界的检测</h4><p>根据位移进行转移的指令，转移范围受到转移位移的限制。如果程序转移范围超界的问题，编译时，编译器将报错。</p>\n"},{"title":"汇编语言-数据处理的两个基本问题","data":"2020-08-12T13:50:00.000Z","updated":"2020-08-12T13:50:00.000Z","_content":"\n### 第八章 数据处理的两个基本问题\n\n计算机处理数据的两个基本问题：\n\n* 处理的数据在什么地方？\n* 要处理的数据有多长？\n\n机器指令必须给这两个问题以说明，否则机器就无法工作。\n\n#### bx、si、di、bp\n\n* 在8086CPU中，只有这4个寄存器可以用在`[...]`中来进行内存单元的寻址。\n* 在`[...]`中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di，bp和si、bp和di。\n* 只要在`[...]`中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中\n\n#### 机器指令处理的数据所在位置\n\n处理数据的指令大致可分为三类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前，索要处理的数据可以在三个地方：CPU内部、内存、端口\n\n#### 汇编语言中数据位置的表达\n\n汇编语言中用三个概念来表达数据的位置。\n\n**立即数(idata)**\n\n对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。\n\n**寄存器**\n\n指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。\n\n**段地址(SA)和偏移地址(EA)**\n\n指令要处理的数据在内存中，在汇编指令中可用`[X]`的格式各处EA，SA在某个段寄存器中。\n\n#### 寻址方式\n\n8086 CPU有多种寻址方式，总结如下：\n\n![寻址方式](../images/assembly_8_2.png)\n\n#### 指令要处理的数据有多长？\n\n8086 CPU的指令可以处理两种长度的数据，byte和word。所以机器指令中要指明进行的是字操作还是字节操作。\n\n* 通过寄存器名指明要处理的数据尺寸\n* 在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度，X在汇编指令中可以为word或byte\n* 其他方法，比如：push指令只进行字操作\n\n#### 寻址方式的综合应用\n\n#### div指令\n\ndiv是除法指令，使用div做除法的时候：\n\n* 除数：有8位和16位两种，在一个寄存器或内存单元中\n* 被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位\n* 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数\n\n```\ndiv byte ptr ds:[0]\n```\n含义为：\n`(al)=(ax)/((ds)*16+0)` 的商\n`(ah)=(ax)/((ds)*16+0)` 的余数\n\n```\ndiv word ptr es:[0]\n```\n含义为：\n`(ax)=[(ds)*10000H+(ax)]/((es)*16+0)` 的商\n`(dx)=[(ds)*10000H+(ax)]/((es)*16+0)` 的余数\n\n```\ndiv byte ptr [bx+si+8]\n```\n含义为：\n`(al)=(ax)/((ds)*16+bx+si+8)` 的商\n`(ah)=(ax)/((ds)*16+bx+si+8)` 的余数\n\n```\ndiv word ptr [bx+si+8]\n```\n含义为：\n`(ax)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)` 的商\n`(dx)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)` 的余数\n\n#### 伪指令dd\n\n前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字)型数据的。\n\n#### dup\n\ndup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。\n\n`db 3 dup (0)`相当于`db 0,0,0`\n`db 3 dup (0, 1, 2)`相当于`db 0, 1, 2, 0, 1, 2, 0, 1, 2`\n`db 3 dup ('abc', 'ABC')`相当于`db 'abcABCabcABCabcABC'`\n\ndup的使用格式如下：\n\n* db 重复的次数 dup (重复的字节型数据)\n* dw 重复的次数 dup (重复的字型数据)\n* dd 重复的次数 dup (重复的双字型数据)\n\n#### 寻址方式在结构化数据访问中的应用\n","source":"_posts/assembly/8-two-question-about-data-handle.md","raw":"---\ntitle: 汇编语言-数据处理的两个基本问题\ndata: 2020-08-12 21:50:00\nupdated: 2020-08-12 21:50:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第八章 数据处理的两个基本问题\n\n计算机处理数据的两个基本问题：\n\n* 处理的数据在什么地方？\n* 要处理的数据有多长？\n\n机器指令必须给这两个问题以说明，否则机器就无法工作。\n\n#### bx、si、di、bp\n\n* 在8086CPU中，只有这4个寄存器可以用在`[...]`中来进行内存单元的寻址。\n* 在`[...]`中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di，bp和si、bp和di。\n* 只要在`[...]`中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中\n\n#### 机器指令处理的数据所在位置\n\n处理数据的指令大致可分为三类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前，索要处理的数据可以在三个地方：CPU内部、内存、端口\n\n#### 汇编语言中数据位置的表达\n\n汇编语言中用三个概念来表达数据的位置。\n\n**立即数(idata)**\n\n对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。\n\n**寄存器**\n\n指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。\n\n**段地址(SA)和偏移地址(EA)**\n\n指令要处理的数据在内存中，在汇编指令中可用`[X]`的格式各处EA，SA在某个段寄存器中。\n\n#### 寻址方式\n\n8086 CPU有多种寻址方式，总结如下：\n\n![寻址方式](../images/assembly_8_2.png)\n\n#### 指令要处理的数据有多长？\n\n8086 CPU的指令可以处理两种长度的数据，byte和word。所以机器指令中要指明进行的是字操作还是字节操作。\n\n* 通过寄存器名指明要处理的数据尺寸\n* 在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度，X在汇编指令中可以为word或byte\n* 其他方法，比如：push指令只进行字操作\n\n#### 寻址方式的综合应用\n\n#### div指令\n\ndiv是除法指令，使用div做除法的时候：\n\n* 除数：有8位和16位两种，在一个寄存器或内存单元中\n* 被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位\n* 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数\n\n```\ndiv byte ptr ds:[0]\n```\n含义为：\n`(al)=(ax)/((ds)*16+0)` 的商\n`(ah)=(ax)/((ds)*16+0)` 的余数\n\n```\ndiv word ptr es:[0]\n```\n含义为：\n`(ax)=[(ds)*10000H+(ax)]/((es)*16+0)` 的商\n`(dx)=[(ds)*10000H+(ax)]/((es)*16+0)` 的余数\n\n```\ndiv byte ptr [bx+si+8]\n```\n含义为：\n`(al)=(ax)/((ds)*16+bx+si+8)` 的商\n`(ah)=(ax)/((ds)*16+bx+si+8)` 的余数\n\n```\ndiv word ptr [bx+si+8]\n```\n含义为：\n`(ax)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)` 的商\n`(dx)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)` 的余数\n\n#### 伪指令dd\n\n前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字)型数据的。\n\n#### dup\n\ndup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。\n\n`db 3 dup (0)`相当于`db 0,0,0`\n`db 3 dup (0, 1, 2)`相当于`db 0, 1, 2, 0, 1, 2, 0, 1, 2`\n`db 3 dup ('abc', 'ABC')`相当于`db 'abcABCabcABCabcABC'`\n\ndup的使用格式如下：\n\n* db 重复的次数 dup (重复的字节型数据)\n* dw 重复的次数 dup (重复的字型数据)\n* dd 重复的次数 dup (重复的双字型数据)\n\n#### 寻址方式在结构化数据访问中的应用\n","slug":"assembly/8-two-question-about-data-handle","published":1,"date":"2020-08-15T15:06:21.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdvsps8o000sq1fw2r378d20","content":"<h3 id=\"第八章-数据处理的两个基本问题\"><a href=\"#第八章-数据处理的两个基本问题\" class=\"headerlink\" title=\"第八章 数据处理的两个基本问题\"></a>第八章 数据处理的两个基本问题</h3><p>计算机处理数据的两个基本问题：</p>\n<ul>\n<li>处理的数据在什么地方？</li>\n<li>要处理的数据有多长？</li>\n</ul>\n<p>机器指令必须给这两个问题以说明，否则机器就无法工作。</p>\n<h4 id=\"bx、si、di、bp\"><a href=\"#bx、si、di、bp\" class=\"headerlink\" title=\"bx、si、di、bp\"></a>bx、si、di、bp</h4><ul>\n<li>在8086CPU中，只有这4个寄存器可以用在<code>[...]</code>中来进行内存单元的寻址。</li>\n<li>在<code>[...]</code>中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di，bp和si、bp和di。</li>\n<li>只要在<code>[...]</code>中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</li>\n</ul>\n<h4 id=\"机器指令处理的数据所在位置\"><a href=\"#机器指令处理的数据所在位置\" class=\"headerlink\" title=\"机器指令处理的数据所在位置\"></a>机器指令处理的数据所在位置</h4><p>处理数据的指令大致可分为三类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前，索要处理的数据可以在三个地方：CPU内部、内存、端口</p>\n<h4 id=\"汇编语言中数据位置的表达\"><a href=\"#汇编语言中数据位置的表达\" class=\"headerlink\" title=\"汇编语言中数据位置的表达\"></a>汇编语言中数据位置的表达</h4><p>汇编语言中用三个概念来表达数据的位置。</p>\n<p><strong>立即数(idata)</strong></p>\n<p>对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。</p>\n<p><strong>寄存器</strong></p>\n<p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p>\n<p><strong>段地址(SA)和偏移地址(EA)</strong></p>\n<p>指令要处理的数据在内存中，在汇编指令中可用<code>[X]</code>的格式各处EA，SA在某个段寄存器中。</p>\n<h4 id=\"寻址方式\"><a href=\"#寻址方式\" class=\"headerlink\" title=\"寻址方式\"></a>寻址方式</h4><p>8086 CPU有多种寻址方式，总结如下：</p>\n<p><img src=\"../images/assembly_8_2.png\" alt=\"寻址方式\"></p>\n<h4 id=\"指令要处理的数据有多长？\"><a href=\"#指令要处理的数据有多长？\" class=\"headerlink\" title=\"指令要处理的数据有多长？\"></a>指令要处理的数据有多长？</h4><p>8086 CPU的指令可以处理两种长度的数据，byte和word。所以机器指令中要指明进行的是字操作还是字节操作。</p>\n<ul>\n<li>通过寄存器名指明要处理的数据尺寸</li>\n<li>在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li>\n<li>其他方法，比如：push指令只进行字操作</li>\n</ul>\n<h4 id=\"寻址方式的综合应用\"><a href=\"#寻址方式的综合应用\" class=\"headerlink\" title=\"寻址方式的综合应用\"></a>寻址方式的综合应用</h4><h4 id=\"div指令\"><a href=\"#div指令\" class=\"headerlink\" title=\"div指令\"></a>div指令</h4><p>div是除法指令，使用div做除法的时候：</p>\n<ul>\n<li>除数：有8位和16位两种，在一个寄存器或内存单元中</li>\n<li>被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位</li>\n<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div byte ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(al)=(ax)/((ds)*16+0)</code> 的商<br><code>(ah)=(ax)/((ds)*16+0)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div word ptr es:[0]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(ax)=[(ds)*10000H+(ax)]/((es)*16+0)</code> 的商<br><code>(dx)=[(ds)*10000H+(ax)]/((es)*16+0)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div byte ptr [bx+si+8]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(al)=(ax)/((ds)*16+bx+si+8)</code> 的商<br><code>(ah)=(ax)/((ds)*16+bx+si+8)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(ax)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)</code> 的商<br><code>(dx)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)</code> 的余数</p>\n<h4 id=\"伪指令dd\"><a href=\"#伪指令dd\" class=\"headerlink\" title=\"伪指令dd\"></a>伪指令dd</h4><p>前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字)型数据的。</p>\n<h4 id=\"dup\"><a href=\"#dup\" class=\"headerlink\" title=\"dup\"></a>dup</h4><p>dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p>\n<p><code>db 3 dup (0)</code>相当于<code>db 0,0,0</code><br><code>db 3 dup (0, 1, 2)</code>相当于<code>db 0, 1, 2, 0, 1, 2, 0, 1, 2</code><br><code>db 3 dup (&#39;abc&#39;, &#39;ABC&#39;)</code>相当于<code>db &#39;abcABCabcABCabcABC&#39;</code></p>\n<p>dup的使用格式如下：</p>\n<ul>\n<li>db 重复的次数 dup (重复的字节型数据)</li>\n<li>dw 重复的次数 dup (重复的字型数据)</li>\n<li>dd 重复的次数 dup (重复的双字型数据)</li>\n</ul>\n<h4 id=\"寻址方式在结构化数据访问中的应用\"><a href=\"#寻址方式在结构化数据访问中的应用\" class=\"headerlink\" title=\"寻址方式在结构化数据访问中的应用\"></a>寻址方式在结构化数据访问中的应用</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第八章-数据处理的两个基本问题\"><a href=\"#第八章-数据处理的两个基本问题\" class=\"headerlink\" title=\"第八章 数据处理的两个基本问题\"></a>第八章 数据处理的两个基本问题</h3><p>计算机处理数据的两个基本问题：</p>\n<ul>\n<li>处理的数据在什么地方？</li>\n<li>要处理的数据有多长？</li>\n</ul>\n<p>机器指令必须给这两个问题以说明，否则机器就无法工作。</p>\n<h4 id=\"bx、si、di、bp\"><a href=\"#bx、si、di、bp\" class=\"headerlink\" title=\"bx、si、di、bp\"></a>bx、si、di、bp</h4><ul>\n<li>在8086CPU中，只有这4个寄存器可以用在<code>[...]</code>中来进行内存单元的寻址。</li>\n<li>在<code>[...]</code>中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di，bp和si、bp和di。</li>\n<li>只要在<code>[...]</code>中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</li>\n</ul>\n<h4 id=\"机器指令处理的数据所在位置\"><a href=\"#机器指令处理的数据所在位置\" class=\"headerlink\" title=\"机器指令处理的数据所在位置\"></a>机器指令处理的数据所在位置</h4><p>处理数据的指令大致可分为三类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前，索要处理的数据可以在三个地方：CPU内部、内存、端口</p>\n<h4 id=\"汇编语言中数据位置的表达\"><a href=\"#汇编语言中数据位置的表达\" class=\"headerlink\" title=\"汇编语言中数据位置的表达\"></a>汇编语言中数据位置的表达</h4><p>汇编语言中用三个概念来表达数据的位置。</p>\n<p><strong>立即数(idata)</strong></p>\n<p>对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。</p>\n<p><strong>寄存器</strong></p>\n<p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p>\n<p><strong>段地址(SA)和偏移地址(EA)</strong></p>\n<p>指令要处理的数据在内存中，在汇编指令中可用<code>[X]</code>的格式各处EA，SA在某个段寄存器中。</p>\n<h4 id=\"寻址方式\"><a href=\"#寻址方式\" class=\"headerlink\" title=\"寻址方式\"></a>寻址方式</h4><p>8086 CPU有多种寻址方式，总结如下：</p>\n<p><img src=\"../images/assembly_8_2.png\" alt=\"寻址方式\"></p>\n<h4 id=\"指令要处理的数据有多长？\"><a href=\"#指令要处理的数据有多长？\" class=\"headerlink\" title=\"指令要处理的数据有多长？\"></a>指令要处理的数据有多长？</h4><p>8086 CPU的指令可以处理两种长度的数据，byte和word。所以机器指令中要指明进行的是字操作还是字节操作。</p>\n<ul>\n<li>通过寄存器名指明要处理的数据尺寸</li>\n<li>在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li>\n<li>其他方法，比如：push指令只进行字操作</li>\n</ul>\n<h4 id=\"寻址方式的综合应用\"><a href=\"#寻址方式的综合应用\" class=\"headerlink\" title=\"寻址方式的综合应用\"></a>寻址方式的综合应用</h4><h4 id=\"div指令\"><a href=\"#div指令\" class=\"headerlink\" title=\"div指令\"></a>div指令</h4><p>div是除法指令，使用div做除法的时候：</p>\n<ul>\n<li>除数：有8位和16位两种，在一个寄存器或内存单元中</li>\n<li>被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位</li>\n<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div byte ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(al)=(ax)/((ds)*16+0)</code> 的商<br><code>(ah)=(ax)/((ds)*16+0)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div word ptr es:[0]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(ax)=[(ds)*10000H+(ax)]/((es)*16+0)</code> 的商<br><code>(dx)=[(ds)*10000H+(ax)]/((es)*16+0)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div byte ptr [bx+si+8]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(al)=(ax)/((ds)*16+bx+si+8)</code> 的商<br><code>(ah)=(ax)/((ds)*16+bx+si+8)</code> 的余数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>\n<p>含义为：<br><code>(ax)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)</code> 的商<br><code>(dx)=[(ds)*10000H+(ax)]/((ds)*16+bx+si+8)</code> 的余数</p>\n<h4 id=\"伪指令dd\"><a href=\"#伪指令dd\" class=\"headerlink\" title=\"伪指令dd\"></a>伪指令dd</h4><p>前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字)型数据的。</p>\n<h4 id=\"dup\"><a href=\"#dup\" class=\"headerlink\" title=\"dup\"></a>dup</h4><p>dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p>\n<p><code>db 3 dup (0)</code>相当于<code>db 0,0,0</code><br><code>db 3 dup (0, 1, 2)</code>相当于<code>db 0, 1, 2, 0, 1, 2, 0, 1, 2</code><br><code>db 3 dup (&#39;abc&#39;, &#39;ABC&#39;)</code>相当于<code>db &#39;abcABCabcABCabcABC&#39;</code></p>\n<p>dup的使用格式如下：</p>\n<ul>\n<li>db 重复的次数 dup (重复的字节型数据)</li>\n<li>dw 重复的次数 dup (重复的字型数据)</li>\n<li>dd 重复的次数 dup (重复的双字型数据)</li>\n</ul>\n<h4 id=\"寻址方式在结构化数据访问中的应用\"><a href=\"#寻址方式在结构化数据访问中的应用\" class=\"headerlink\" title=\"寻址方式在结构化数据访问中的应用\"></a>寻址方式在结构化数据访问中的应用</h4>"},{"_content":"","source":"_posts/index.md","raw":"","slug":"index","published":1,"date":"2020-08-15T15:13:49.380Z","updated":"2020-08-15T15:13:49.380Z","title":"index","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdyli9su0000qofw9whg6wwh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Linux-nc命令详解","data":"2020-08-10T12:00:00.000Z","updated":"2020-08-10T12:00:00.000Z","_content":"\n### Linux命令详解-netcat\n\nnetcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。以下是常用nc命令的示例\n\n#### 端口扫描\n\nnetcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞\n\n```shell\n$nc -z -v -n 192.168.63.35 21-25\n```\n这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。\n-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换\n-v 表示详细输出\n-n 表示netcat不使用DNS反向查询IP地址的域名\n\n#### 文件传输\n\nLinux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。\n\n```shell\n# A--->B\n$ nc -l 8000 < file.txt            # 机器A，server端\n$ nc -n 192.168.63.35 > file.txt   # 机器B，client端\n```\n\n以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。\n\n也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。\n\n```shell\n# A<---B\n$ nc -l 8000 > file.txt             # 机器A，server端\n$ nc 192.168.63.35 8000 < file.txt  # 机器B，client端\n```\n\n#### 目录传输\n\n发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。\n\n```shell\n# A--->B\n$ tar -cvf - dirname | nc -l 8000           # 机器A，server端\n$ nc -n 192.168.63.35 8000 | tar -xvf -     # 机器B，client端\n```\n\n在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。\n\n如果想要节省带宽，可以通过压缩工具压缩后再进行发送\n\n```shell\n$ tar -cvf - dirname | bzip2 -z | nc -l 8000         # 机器A，server端\n$ nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   # 机器B，client端\n```\n\n使用tar归档和bzip2压缩和解压\n\n#### 网络加密传输\n\n在发送数据之前，可以使用mcrypt工具保证数据安全\n\n```shell\n$ nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb > file.txt    # 客户端\n$ mcrypt --flush --bare -F -q -m ecb < file.txt | nc -l 8000   #服务端\n```\n\n以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。\n\n（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）\n\n#### 视频流\n\n个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法\n\n```shell\n$ cat video.mp4 | nc -l 8000\n$ nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -\n```\n\n以上命令netcat从socket中读取数据并重定向到mplayer中\n\n#### 克隆一个设备\n\n如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下\n\n```shell\n$ dd if=/dev/sda | nc -l 8000            # server端\n$ nc -n 192.168.63.35 | dd of=/dev/sda   # client端\n```\n\ndd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。\n\n#### 打开一个shell\n\n如果没有安装telnet或ssh，可以使用netcat创建远程shell\n\n```sh\n$ nc -v -c /bin/bash -lp 8000\n$ nc -v 192.168.63.35 8000\n```\n\n#### nc常用参数选项\n\nnc -h查看\n\n```\n\n[v1.10-41.1]\nconnect to somewhere:   nc [-options] hostname port[s] [ports] ... \nlisten for inbound:     nc -l -p port [-options] [hostname] [port]\noptions:\n        -c shell commands       as `-e'; use /bin/sh to exec [dangerous!!]\n        -e filename             program to exec after connect [dangerous!!]\n        -b                      allow broadcasts\n        -g gateway              source-routing hop point[s], up to 8\n        -G num                  source-routing pointer: 4, 8, 12, ...\n        -h                      this cruft\n        -i secs                 delay interval for lines sent, ports scanned\n        -k                      set keepalive option on socket\n        -l                      listen mode, for inbound connects\n        -n                      numeric-only IP addresses, no DNS\n        -o file                 hex dump of traffic\n        -p port                 local port number\n        -r                      randomize local and remote ports\n        -q secs                 quit after EOF on stdin and delay of secs\n        -s addr                 local source address\n        -T tos                  set Type Of Service\n        -t                      answer TELNET negotiation\n        -u                      UDP mode\n        -v                      verbose [use twice to be more verbose]\n        -w secs                 timeout for connects and final net reads\n        -C                      Send CRLF as line-ending\n        -z                      zero-I/O mode [used for scanning]\nport numbers can be individual or ranges: lo-hi [inclusive];\nhyphens in port names must be backslash escaped (e.g. 'ftp\\-data').\n\n```\n","source":"_posts/linux/linux-nc.md","raw":"---\ntitle: Linux-nc命令详解\ndata: 2020-08-10 20:00:00\nupdated: 2020-08-10 20:00:00\ntags:\n  - Linux\ncategories: \n  - Linux命令详解\n---\n\n### Linux命令详解-netcat\n\nnetcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。以下是常用nc命令的示例\n\n#### 端口扫描\n\nnetcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞\n\n```shell\n$nc -z -v -n 192.168.63.35 21-25\n```\n这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。\n-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换\n-v 表示详细输出\n-n 表示netcat不使用DNS反向查询IP地址的域名\n\n#### 文件传输\n\nLinux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。\n\n```shell\n# A--->B\n$ nc -l 8000 < file.txt            # 机器A，server端\n$ nc -n 192.168.63.35 > file.txt   # 机器B，client端\n```\n\n以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。\n\n也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。\n\n```shell\n# A<---B\n$ nc -l 8000 > file.txt             # 机器A，server端\n$ nc 192.168.63.35 8000 < file.txt  # 机器B，client端\n```\n\n#### 目录传输\n\n发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。\n\n```shell\n# A--->B\n$ tar -cvf - dirname | nc -l 8000           # 机器A，server端\n$ nc -n 192.168.63.35 8000 | tar -xvf -     # 机器B，client端\n```\n\n在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。\n\n如果想要节省带宽，可以通过压缩工具压缩后再进行发送\n\n```shell\n$ tar -cvf - dirname | bzip2 -z | nc -l 8000         # 机器A，server端\n$ nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   # 机器B，client端\n```\n\n使用tar归档和bzip2压缩和解压\n\n#### 网络加密传输\n\n在发送数据之前，可以使用mcrypt工具保证数据安全\n\n```shell\n$ nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb > file.txt    # 客户端\n$ mcrypt --flush --bare -F -q -m ecb < file.txt | nc -l 8000   #服务端\n```\n\n以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。\n\n（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）\n\n#### 视频流\n\n个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法\n\n```shell\n$ cat video.mp4 | nc -l 8000\n$ nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -\n```\n\n以上命令netcat从socket中读取数据并重定向到mplayer中\n\n#### 克隆一个设备\n\n如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下\n\n```shell\n$ dd if=/dev/sda | nc -l 8000            # server端\n$ nc -n 192.168.63.35 | dd of=/dev/sda   # client端\n```\n\ndd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。\n\n#### 打开一个shell\n\n如果没有安装telnet或ssh，可以使用netcat创建远程shell\n\n```sh\n$ nc -v -c /bin/bash -lp 8000\n$ nc -v 192.168.63.35 8000\n```\n\n#### nc常用参数选项\n\nnc -h查看\n\n```\n\n[v1.10-41.1]\nconnect to somewhere:   nc [-options] hostname port[s] [ports] ... \nlisten for inbound:     nc -l -p port [-options] [hostname] [port]\noptions:\n        -c shell commands       as `-e'; use /bin/sh to exec [dangerous!!]\n        -e filename             program to exec after connect [dangerous!!]\n        -b                      allow broadcasts\n        -g gateway              source-routing hop point[s], up to 8\n        -G num                  source-routing pointer: 4, 8, 12, ...\n        -h                      this cruft\n        -i secs                 delay interval for lines sent, ports scanned\n        -k                      set keepalive option on socket\n        -l                      listen mode, for inbound connects\n        -n                      numeric-only IP addresses, no DNS\n        -o file                 hex dump of traffic\n        -p port                 local port number\n        -r                      randomize local and remote ports\n        -q secs                 quit after EOF on stdin and delay of secs\n        -s addr                 local source address\n        -T tos                  set Type Of Service\n        -t                      answer TELNET negotiation\n        -u                      UDP mode\n        -v                      verbose [use twice to be more verbose]\n        -w secs                 timeout for connects and final net reads\n        -C                      Send CRLF as line-ending\n        -z                      zero-I/O mode [used for scanning]\nport numbers can be individual or ranges: lo-hi [inclusive];\nhyphens in port names must be backslash escaped (e.g. 'ftp\\-data').\n\n```\n","slug":"linux/linux-nc","published":1,"date":"2020-08-15T15:14:06.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdyli9tr0001qofw1h726xds","content":"<h3 id=\"Linux命令详解-netcat\"><a href=\"#Linux命令详解-netcat\" class=\"headerlink\" title=\"Linux命令详解-netcat\"></a>Linux命令详解-netcat</h3><p>netcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。以下是常用nc命令的示例</p>\n<h4 id=\"端口扫描\"><a href=\"#端口扫描\" class=\"headerlink\" title=\"端口扫描\"></a>端口扫描</h4><p>netcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">nc -z -v -n 192.168.63.35 21-25</span></span><br></pre></td></tr></table></figure>\n<p>这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。<br>-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换<br>-v 表示详细输出<br>-n 表示netcat不使用DNS反向查询IP地址的域名</p>\n<h4 id=\"文件传输\"><a href=\"#文件传输\" class=\"headerlink\" title=\"文件传输\"></a>文件传输</h4><p>Linux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &lt; file.txt            <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 &gt; file.txt   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。</p>\n<p>也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A&lt;---B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &gt; file.txt             <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 &lt; file.txt  <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目录传输\"><a href=\"#目录传输\" class=\"headerlink\" title=\"目录传输\"></a>目录传输</h4><p>发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | nc -l 8000           <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | tar -xvf -     <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。</p>\n<p>如果想要节省带宽，可以通过压缩工具压缩后再进行发送</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | bzip2 -z | nc -l 8000         <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用tar归档和bzip2压缩和解压</p>\n<h4 id=\"网络加密传输\"><a href=\"#网络加密传输\" class=\"headerlink\" title=\"网络加密传输\"></a>网络加密传输</h4><p>在发送数据之前，可以使用mcrypt工具保证数据安全</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb &gt; file.txt    <span class=\"comment\"># 客户端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mcrypt --flush --bare -F -q -m ecb &lt; file.txt | nc -l 8000   <span class=\"comment\">#服务端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。</p>\n<p>（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）</p>\n<h4 id=\"视频流\"><a href=\"#视频流\" class=\"headerlink\" title=\"视频流\"></a>视频流</h4><p>个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat video.mp4 | nc -l 8000</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令netcat从socket中读取数据并重定向到mplayer中</p>\n<h4 id=\"克隆一个设备\"><a href=\"#克隆一个设备\" class=\"headerlink\" title=\"克隆一个设备\"></a>克隆一个设备</h4><p>如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/sda | nc -l 8000            <span class=\"comment\"># server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 | dd of=/dev/sda   <span class=\"comment\"># client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>dd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>\n<h4 id=\"打开一个shell\"><a href=\"#打开一个shell\" class=\"headerlink\" title=\"打开一个shell\"></a>打开一个shell</h4><p>如果没有安装telnet或ssh，可以使用netcat创建远程shell</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nc -v -c /bin/bash -lp 8000</span><br><span class=\"line\">$ nc -v 192.168.63.35 8000</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nc常用参数选项\"><a href=\"#nc常用参数选项\" class=\"headerlink\" title=\"nc常用参数选项\"></a>nc常用参数选项</h4><p>nc -h查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[v1.10-41.1]</span><br><span class=\"line\">connect to somewhere:   nc [-options] hostname port[s] [ports] ... </span><br><span class=\"line\">listen for inbound:     nc -l -p port [-options] [hostname] [port]</span><br><span class=\"line\">options:</span><br><span class=\"line\">        -c shell commands       as &#96;-e&#39;; use &#x2F;bin&#x2F;sh to exec [dangerous!!]</span><br><span class=\"line\">        -e filename             program to exec after connect [dangerous!!]</span><br><span class=\"line\">        -b                      allow broadcasts</span><br><span class=\"line\">        -g gateway              source-routing hop point[s], up to 8</span><br><span class=\"line\">        -G num                  source-routing pointer: 4, 8, 12, ...</span><br><span class=\"line\">        -h                      this cruft</span><br><span class=\"line\">        -i secs                 delay interval for lines sent, ports scanned</span><br><span class=\"line\">        -k                      set keepalive option on socket</span><br><span class=\"line\">        -l                      listen mode, for inbound connects</span><br><span class=\"line\">        -n                      numeric-only IP addresses, no DNS</span><br><span class=\"line\">        -o file                 hex dump of traffic</span><br><span class=\"line\">        -p port                 local port number</span><br><span class=\"line\">        -r                      randomize local and remote ports</span><br><span class=\"line\">        -q secs                 quit after EOF on stdin and delay of secs</span><br><span class=\"line\">        -s addr                 local source address</span><br><span class=\"line\">        -T tos                  set Type Of Service</span><br><span class=\"line\">        -t                      answer TELNET negotiation</span><br><span class=\"line\">        -u                      UDP mode</span><br><span class=\"line\">        -v                      verbose [use twice to be more verbose]</span><br><span class=\"line\">        -w secs                 timeout for connects and final net reads</span><br><span class=\"line\">        -C                      Send CRLF as line-ending</span><br><span class=\"line\">        -z                      zero-I&#x2F;O mode [used for scanning]</span><br><span class=\"line\">port numbers can be individual or ranges: lo-hi [inclusive];</span><br><span class=\"line\">hyphens in port names must be backslash escaped (e.g. &#39;ftp\\-data&#39;).</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Linux命令详解-netcat\"><a href=\"#Linux命令详解-netcat\" class=\"headerlink\" title=\"Linux命令详解-netcat\"></a>Linux命令详解-netcat</h3><p>netcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。以下是常用nc命令的示例</p>\n<h4 id=\"端口扫描\"><a href=\"#端口扫描\" class=\"headerlink\" title=\"端口扫描\"></a>端口扫描</h4><p>netcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">nc -z -v -n 192.168.63.35 21-25</span></span><br></pre></td></tr></table></figure>\n<p>这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。<br>-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换<br>-v 表示详细输出<br>-n 表示netcat不使用DNS反向查询IP地址的域名</p>\n<h4 id=\"文件传输\"><a href=\"#文件传输\" class=\"headerlink\" title=\"文件传输\"></a>文件传输</h4><p>Linux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &lt; file.txt            <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 &gt; file.txt   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。</p>\n<p>也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A&lt;---B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -l 8000 &gt; file.txt             <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 &lt; file.txt  <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目录传输\"><a href=\"#目录传输\" class=\"headerlink\" title=\"目录传输\"></a>目录传输</h4><p>发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> A---&gt;B</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | nc -l 8000           <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | tar -xvf -     <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。</p>\n<p>如果想要节省带宽，可以通过压缩工具压缩后再进行发送</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar -cvf - dirname | bzip2 -z | nc -l 8000         <span class=\"comment\"># 机器A，server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   <span class=\"comment\"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用tar归档和bzip2压缩和解压</p>\n<h4 id=\"网络加密传输\"><a href=\"#网络加密传输\" class=\"headerlink\" title=\"网络加密传输\"></a>网络加密传输</h4><p>在发送数据之前，可以使用mcrypt工具保证数据安全</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb &gt; file.txt    <span class=\"comment\"># 客户端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mcrypt --flush --bare -F -q -m ecb &lt; file.txt | nc -l 8000   <span class=\"comment\">#服务端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。</p>\n<p>（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）</p>\n<h4 id=\"视频流\"><a href=\"#视频流\" class=\"headerlink\" title=\"视频流\"></a>视频流</h4><p>个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat video.mp4 | nc -l 8000</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令netcat从socket中读取数据并重定向到mplayer中</p>\n<h4 id=\"克隆一个设备\"><a href=\"#克隆一个设备\" class=\"headerlink\" title=\"克隆一个设备\"></a>克隆一个设备</h4><p>如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dd <span class=\"keyword\">if</span>=/dev/sda | nc -l 8000            <span class=\"comment\"># server端</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc -n 192.168.63.35 | dd of=/dev/sda   <span class=\"comment\"># client端</span></span></span><br></pre></td></tr></table></figure>\n\n<p>dd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>\n<h4 id=\"打开一个shell\"><a href=\"#打开一个shell\" class=\"headerlink\" title=\"打开一个shell\"></a>打开一个shell</h4><p>如果没有安装telnet或ssh，可以使用netcat创建远程shell</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nc -v -c /bin/bash -lp 8000</span><br><span class=\"line\">$ nc -v 192.168.63.35 8000</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nc常用参数选项\"><a href=\"#nc常用参数选项\" class=\"headerlink\" title=\"nc常用参数选项\"></a>nc常用参数选项</h4><p>nc -h查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[v1.10-41.1]</span><br><span class=\"line\">connect to somewhere:   nc [-options] hostname port[s] [ports] ... </span><br><span class=\"line\">listen for inbound:     nc -l -p port [-options] [hostname] [port]</span><br><span class=\"line\">options:</span><br><span class=\"line\">        -c shell commands       as &#96;-e&#39;; use &#x2F;bin&#x2F;sh to exec [dangerous!!]</span><br><span class=\"line\">        -e filename             program to exec after connect [dangerous!!]</span><br><span class=\"line\">        -b                      allow broadcasts</span><br><span class=\"line\">        -g gateway              source-routing hop point[s], up to 8</span><br><span class=\"line\">        -G num                  source-routing pointer: 4, 8, 12, ...</span><br><span class=\"line\">        -h                      this cruft</span><br><span class=\"line\">        -i secs                 delay interval for lines sent, ports scanned</span><br><span class=\"line\">        -k                      set keepalive option on socket</span><br><span class=\"line\">        -l                      listen mode, for inbound connects</span><br><span class=\"line\">        -n                      numeric-only IP addresses, no DNS</span><br><span class=\"line\">        -o file                 hex dump of traffic</span><br><span class=\"line\">        -p port                 local port number</span><br><span class=\"line\">        -r                      randomize local and remote ports</span><br><span class=\"line\">        -q secs                 quit after EOF on stdin and delay of secs</span><br><span class=\"line\">        -s addr                 local source address</span><br><span class=\"line\">        -T tos                  set Type Of Service</span><br><span class=\"line\">        -t                      answer TELNET negotiation</span><br><span class=\"line\">        -u                      UDP mode</span><br><span class=\"line\">        -v                      verbose [use twice to be more verbose]</span><br><span class=\"line\">        -w secs                 timeout for connects and final net reads</span><br><span class=\"line\">        -C                      Send CRLF as line-ending</span><br><span class=\"line\">        -z                      zero-I&#x2F;O mode [used for scanning]</span><br><span class=\"line\">port numbers can be individual or ranges: lo-hi [inclusive];</span><br><span class=\"line\">hyphens in port names must be backslash escaped (e.g. &#39;ftp\\-data&#39;).</span><br></pre></td></tr></table></figure>\n"},{"title":"汇编语言-call和ret指令","data":"2020-08-15T14:44:00.000Z","updated":"2020-08-17T13:44:00.000Z","_content":"\n### 第十章 call和ret指令\n\ncall和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。\n\n#### ret和retf\n\nret指令用栈中的数据，修改IP的内容，从而实现近转移\nretf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 \n\nCPU执行ret指令时，进行下面两步操作：\n\n* (IP)=((SS)*16+(SP))\n* (SP)=(SP)+2\n\nCPU执行retf指令时，进行下面四步操作：\n\n* (IP)=((SS)*16+(SP))\n* (SP)=(SP)+2\n* (CS)=((SS)*16+(SP))\n* (SP)=(SP)+2\n\n可以看出，如果用汇编语法来解释ret和retf指令，则：\nCPU执行ret指令时，相当于执行：\n\n```\npop IP\n```\n\nCPU执行retf指令时，相当于执行：\n\n```\npop IP\npop CS\n```\n\n下面的程序中，ret指令执行后，(IP)=0,CS:IP执行代码段的第一条指令\n\n```\nassume cs:code\nstack segment\n    db 16 dup (0)\nstack ends\n\ncode segment\n    mov ax, 4c00h\n    int 21h\n\nstart:\n    mov ax, stack\n    mov ss, ax\n    mov sp, 16\n    mov ax, 0\n    push ax\n    mov bx, 0\n    ret\ncode ends\nend start\n```\n\n下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令\n\n```\nassume cs:code\nstack segment\n    db 16 dup (0)\nstack ends\n\ncode segment\n    mov ax, 4c00h\n    int 21h\n\nstart:\n    mov ax, stack\n    mov ss, ax\n    mov sp, 16\n\n    mov ax, 0\n    push cs\n    push ax\n    mov bx, 0\n    retf\ncode ends\nend start\n```\n\n#### call指令\n\nCPU执行call指令时，进行两步操作：\n\n* 将当前的IP或CS和IP压入栈中\n* 转移\n\ncall指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同\n\n#### 依据位移进行转移的call指令\n\ncall 标号(将当前的IP压栈后，转到标号处执行指令)\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n* (SP)=(SP)-2\n  ((SS)*16+(SP))=(IP)\n* (IP)=(IP)+16位位移\n\n16位位移=“标号”处的地址-call指令后的第一字节的地址\n16位位移的范围为-32768~32767，用补码表示\n16位位移的编译程序在编译时算出\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp near ptr 标号\n```\n\n#### 转移的目的地址在指令中的call指令\n\n指令`call far ptr标号`实现的是段间转移，此种call指令操作如下：\n\n* (SP)=(SP)-2\n  ((SS)*16+(SP))=(CS)\n  (SP)=(SP)-2\n  ((SS)*16+(SP))=(IP)\n* (CS)=标号所在段的段地址\n  (IP)=标号所在段中的偏移地址\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush CS\npush IP\njmp far ptr 标号\n```\n\n#### 转移地址的寄存器中的call指令\n\n指令格式：`call 16为寄存器`\n功能：\n\n(SP)=(SP)-2\n((SS)*16+(SP))=(IP)\n(IP)=(16位寄存器)\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp 16位寄存器\n```\n\n#### 转移指令在内存中的call指令\n\n转移地址在内存中的call指令有两种格式：\n格式一\n\n```\ncall word ptr 内存单元地址\n```\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp word ptr 内存单元地址\n```\n\n比如下面的指令：\n\n```\nmov sp, 10h\nmov ax, 0123h\nmov ds[0], ax\ncall word ptr ds:[0]\n```\n执行后，(IP)=0123, (SP)=0EH\n\n\n格式二\n\n```\ncall dword ptr 内存单元地址\n```\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush CS\npush IP\njmp dword ptr 内存单元地址\n```\n\n比如下面的指令：\n\n```\nmov sp, 10h\nmov ax, 0123h\nmov ds:[0], ax\nmov word ptr ds:[2], 0\ncall dword ptr ds:[0]\n```\n执行后，(CS)=0，(IP)=0123H，(SP)=0CH\n\n#### call和ret配合使用\n\n下面程序返回前，bx中的值是多少\n\n```\nassume cs:code\ncode segment\nstart:\n    mov ax, 1\n    mov cx, 3\n    call s\n    mov bx, ax  ;(bx)=?\n    mov ax, 4c00h\n    int 21h\ns:\n    add ax, ax\n    loop s\n    ret\n\ncode ends\nend start\n```\n\n#### mul指令\n\nmul是乘法指令，使用mul做乘法的时候：\n\n* 两个想乘的数，要么都是8位，要是都是16位。如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存单元中\n* 结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中，低位在AX中\n\n格式如下：\n\n```\nmul reg\nmul 内存单元\n```\n\n#### 模块化程序设计\n\ncall和ret指令共同支持了汇编语言中的模块化设计。\n\n#### 参数和结果传递的问题\n\n讨论参数和返回值传递的问题，实际上是探讨如何存储子程序需要的参数和产生的返回值。用寄存器来存储参数和结果是最常使用的方法，对于存放参数和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取得返回值；子程序从参数寄存器中取得参数，将返回值送入结果寄存器\n\n#### 批量数据的传递\n\n批量传参和结果时，可以将批量数据存放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。\n\n#### 寄存器冲突问题\n\n在子程序的开始将子程序中所有用到的寄存器中的内容保持起来，在子程序返回前再回复。可以用栈来保持寄存器的内容。\n\n所以编写子程序的标志框架如下：\n\n```\n子程序开始:\n    子程序中使用的寄存器入栈\n    子程序内容\n    子程序中使用的寄存器出栈\n    返回(ret/retf)\n```","source":"_posts/assembly/10-call-and-ret.md","raw":"---\ntitle: 汇编语言-call和ret指令\ndata: 2020-08-15 22:44:00\nupdated: 2020-08-17 21:44:00\ntags:\n  - 汇编\ncategories: \n  - 汇编语言学习\n---\n\n### 第十章 call和ret指令\n\ncall和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。\n\n#### ret和retf\n\nret指令用栈中的数据，修改IP的内容，从而实现近转移\nretf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 \n\nCPU执行ret指令时，进行下面两步操作：\n\n* (IP)=((SS)*16+(SP))\n* (SP)=(SP)+2\n\nCPU执行retf指令时，进行下面四步操作：\n\n* (IP)=((SS)*16+(SP))\n* (SP)=(SP)+2\n* (CS)=((SS)*16+(SP))\n* (SP)=(SP)+2\n\n可以看出，如果用汇编语法来解释ret和retf指令，则：\nCPU执行ret指令时，相当于执行：\n\n```\npop IP\n```\n\nCPU执行retf指令时，相当于执行：\n\n```\npop IP\npop CS\n```\n\n下面的程序中，ret指令执行后，(IP)=0,CS:IP执行代码段的第一条指令\n\n```\nassume cs:code\nstack segment\n    db 16 dup (0)\nstack ends\n\ncode segment\n    mov ax, 4c00h\n    int 21h\n\nstart:\n    mov ax, stack\n    mov ss, ax\n    mov sp, 16\n    mov ax, 0\n    push ax\n    mov bx, 0\n    ret\ncode ends\nend start\n```\n\n下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令\n\n```\nassume cs:code\nstack segment\n    db 16 dup (0)\nstack ends\n\ncode segment\n    mov ax, 4c00h\n    int 21h\n\nstart:\n    mov ax, stack\n    mov ss, ax\n    mov sp, 16\n\n    mov ax, 0\n    push cs\n    push ax\n    mov bx, 0\n    retf\ncode ends\nend start\n```\n\n#### call指令\n\nCPU执行call指令时，进行两步操作：\n\n* 将当前的IP或CS和IP压入栈中\n* 转移\n\ncall指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同\n\n#### 依据位移进行转移的call指令\n\ncall 标号(将当前的IP压栈后，转到标号处执行指令)\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n* (SP)=(SP)-2\n  ((SS)*16+(SP))=(IP)\n* (IP)=(IP)+16位位移\n\n16位位移=“标号”处的地址-call指令后的第一字节的地址\n16位位移的范围为-32768~32767，用补码表示\n16位位移的编译程序在编译时算出\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp near ptr 标号\n```\n\n#### 转移的目的地址在指令中的call指令\n\n指令`call far ptr标号`实现的是段间转移，此种call指令操作如下：\n\n* (SP)=(SP)-2\n  ((SS)*16+(SP))=(CS)\n  (SP)=(SP)-2\n  ((SS)*16+(SP))=(IP)\n* (CS)=标号所在段的段地址\n  (IP)=标号所在段中的偏移地址\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush CS\npush IP\njmp far ptr 标号\n```\n\n#### 转移地址的寄存器中的call指令\n\n指令格式：`call 16为寄存器`\n功能：\n\n(SP)=(SP)-2\n((SS)*16+(SP))=(IP)\n(IP)=(16位寄存器)\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp 16位寄存器\n```\n\n#### 转移指令在内存中的call指令\n\n转移地址在内存中的call指令有两种格式：\n格式一\n\n```\ncall word ptr 内存单元地址\n```\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush IP\njmp word ptr 内存单元地址\n```\n\n比如下面的指令：\n\n```\nmov sp, 10h\nmov ax, 0123h\nmov ds[0], ax\ncall word ptr ds:[0]\n```\n执行后，(IP)=0123, (SP)=0EH\n\n\n格式二\n\n```\ncall dword ptr 内存单元地址\n```\n\n如果用汇编语法解释此种格式的call指令，则相当于\n\n```\npush CS\npush IP\njmp dword ptr 内存单元地址\n```\n\n比如下面的指令：\n\n```\nmov sp, 10h\nmov ax, 0123h\nmov ds:[0], ax\nmov word ptr ds:[2], 0\ncall dword ptr ds:[0]\n```\n执行后，(CS)=0，(IP)=0123H，(SP)=0CH\n\n#### call和ret配合使用\n\n下面程序返回前，bx中的值是多少\n\n```\nassume cs:code\ncode segment\nstart:\n    mov ax, 1\n    mov cx, 3\n    call s\n    mov bx, ax  ;(bx)=?\n    mov ax, 4c00h\n    int 21h\ns:\n    add ax, ax\n    loop s\n    ret\n\ncode ends\nend start\n```\n\n#### mul指令\n\nmul是乘法指令，使用mul做乘法的时候：\n\n* 两个想乘的数，要么都是8位，要是都是16位。如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存单元中\n* 结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中，低位在AX中\n\n格式如下：\n\n```\nmul reg\nmul 内存单元\n```\n\n#### 模块化程序设计\n\ncall和ret指令共同支持了汇编语言中的模块化设计。\n\n#### 参数和结果传递的问题\n\n讨论参数和返回值传递的问题，实际上是探讨如何存储子程序需要的参数和产生的返回值。用寄存器来存储参数和结果是最常使用的方法，对于存放参数和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取得返回值；子程序从参数寄存器中取得参数，将返回值送入结果寄存器\n\n#### 批量数据的传递\n\n批量传参和结果时，可以将批量数据存放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。\n\n#### 寄存器冲突问题\n\n在子程序的开始将子程序中所有用到的寄存器中的内容保持起来，在子程序返回前再回复。可以用栈来保持寄存器的内容。\n\n所以编写子程序的标志框架如下：\n\n```\n子程序开始:\n    子程序中使用的寄存器入栈\n    子程序内容\n    子程序中使用的寄存器出栈\n    返回(ret/retf)\n```","slug":"assembly/10-call-and-ret","published":1,"date":"2020-08-17T15:32:10.855Z","_id":"ckdyli9ts0002qofw272i4bls","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第十章-call和ret指令\"><a href=\"#第十章-call和ret指令\" class=\"headerlink\" title=\"第十章 call和ret指令\"></a>第十章 call和ret指令</h3><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p>\n<h4 id=\"ret和retf\"><a href=\"#ret和retf\" class=\"headerlink\" title=\"ret和retf\"></a>ret和retf</h4><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 </p>\n<p>CPU执行ret指令时，进行下面两步操作：</p>\n<ul>\n<li>(IP)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n</ul>\n<p>CPU执行retf指令时，进行下面四步操作：</p>\n<ul>\n<li>(IP)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n<li>(CS)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n</ul>\n<p>可以看出，如果用汇编语法来解释ret和retf指令，则：<br>CPU执行ret指令时，相当于执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop IP</span><br></pre></td></tr></table></figure>\n\n<p>CPU执行retf指令时，相当于执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop IP</span><br><span class=\"line\">pop CS</span><br></pre></td></tr></table></figure>\n\n<p>下面的程序中，ret指令执行后，(IP)=0,CS:IP执行代码段的第一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    db 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, stack</span><br><span class=\"line\">    mov ss, ax</span><br><span class=\"line\">    mov sp, 16</span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    push ax</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    ret</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    db 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, stack</span><br><span class=\"line\">    mov ss, ax</span><br><span class=\"line\">    mov sp, 16</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    push cs</span><br><span class=\"line\">    push ax</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    retf</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"call指令\"><a href=\"#call指令\" class=\"headerlink\" title=\"call指令\"></a>call指令</h4><p>CPU执行call指令时，进行两步操作：</p>\n<ul>\n<li>将当前的IP或CS和IP压入栈中</li>\n<li>转移</li>\n</ul>\n<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p>\n<h4 id=\"依据位移进行转移的call指令\"><a href=\"#依据位移进行转移的call指令\" class=\"headerlink\" title=\"依据位移进行转移的call指令\"></a>依据位移进行转移的call指令</h4><p>call 标号(将当前的IP压栈后，转到标号处执行指令)</p>\n<p>CPU执行此种格式的call指令时，进行如下操作：</p>\n<ul>\n<li>(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)</li>\n<li>(IP)=(IP)+16位位移</li>\n</ul>\n<p>16位位移=“标号”处的地址-call指令后的第一字节的地址<br>16位位移的范围为-32768~32767，用补码表示<br>16位位移的编译程序在编译时算出</p>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp near ptr 标号</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移的目的地址在指令中的call指令\"><a href=\"#转移的目的地址在指令中的call指令\" class=\"headerlink\" title=\"转移的目的地址在指令中的call指令\"></a>转移的目的地址在指令中的call指令</h4><p>指令<code>call far ptr标号</code>实现的是段间转移，此种call指令操作如下：</p>\n<ul>\n<li>(SP)=(SP)-2<br>((SS)<em>16+(SP))=(CS)<br>(SP)=(SP)-2<br>((SS)</em>16+(SP))=(IP)</li>\n<li>(CS)=标号所在段的段地址<br>(IP)=标号所在段中的偏移地址</li>\n</ul>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push CS</span><br><span class=\"line\">push IP</span><br><span class=\"line\">jmp far ptr 标号</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移地址的寄存器中的call指令\"><a href=\"#转移地址的寄存器中的call指令\" class=\"headerlink\" title=\"转移地址的寄存器中的call指令\"></a>转移地址的寄存器中的call指令</h4><p>指令格式：<code>call 16为寄存器</code><br>功能：</p>\n<p>(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)<br>(IP)=(16位寄存器)</p>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp 16位寄存器</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移指令在内存中的call指令\"><a href=\"#转移指令在内存中的call指令\" class=\"headerlink\" title=\"转移指令在内存中的call指令\"></a>转移指令在内存中的call指令</h4><p>转移地址在内存中的call指令有两种格式：<br>格式一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call word ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>比如下面的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov sp, 10h</span><br><span class=\"line\">mov ax, 0123h</span><br><span class=\"line\">mov ds[0], ax</span><br><span class=\"line\">call word ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>执行后，(IP)=0123, (SP)=0EH</p>\n<p>格式二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push CS</span><br><span class=\"line\">push IP</span><br><span class=\"line\">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>比如下面的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov sp, 10h</span><br><span class=\"line\">mov ax, 0123h</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">mov word ptr ds:[2], 0</span><br><span class=\"line\">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>执行后，(CS)=0，(IP)=0123H，(SP)=0CH</p>\n<h4 id=\"call和ret配合使用\"><a href=\"#call和ret配合使用\" class=\"headerlink\" title=\"call和ret配合使用\"></a>call和ret配合使用</h4><p>下面程序返回前，bx中的值是多少</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, 1</span><br><span class=\"line\">    mov cx, 3</span><br><span class=\"line\">    call s</span><br><span class=\"line\">    mov bx, ax  ;(bx)&#x3D;?</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\">s:</span><br><span class=\"line\">    add ax, ax</span><br><span class=\"line\">    loop s</span><br><span class=\"line\">    ret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mul指令\"><a href=\"#mul指令\" class=\"headerlink\" title=\"mul指令\"></a>mul指令</h4><p>mul是乘法指令，使用mul做乘法的时候：</p>\n<ul>\n<li>两个想乘的数，要么都是8位，要是都是16位。如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存单元中</li>\n<li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中，低位在AX中</li>\n</ul>\n<p>格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mul reg</span><br><span class=\"line\">mul 内存单元</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模块化程序设计\"><a href=\"#模块化程序设计\" class=\"headerlink\" title=\"模块化程序设计\"></a>模块化程序设计</h4><p>call和ret指令共同支持了汇编语言中的模块化设计。</p>\n<h4 id=\"参数和结果传递的问题\"><a href=\"#参数和结果传递的问题\" class=\"headerlink\" title=\"参数和结果传递的问题\"></a>参数和结果传递的问题</h4><p>讨论参数和返回值传递的问题，实际上是探讨如何存储子程序需要的参数和产生的返回值。用寄存器来存储参数和结果是最常使用的方法，对于存放参数和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取得返回值；子程序从参数寄存器中取得参数，将返回值送入结果寄存器</p>\n<h4 id=\"批量数据的传递\"><a href=\"#批量数据的传递\" class=\"headerlink\" title=\"批量数据的传递\"></a>批量数据的传递</h4><p>批量传参和结果时，可以将批量数据存放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。</p>\n<h4 id=\"寄存器冲突问题\"><a href=\"#寄存器冲突问题\" class=\"headerlink\" title=\"寄存器冲突问题\"></a>寄存器冲突问题</h4><p>在子程序的开始将子程序中所有用到的寄存器中的内容保持起来，在子程序返回前再回复。可以用栈来保持寄存器的内容。</p>\n<p>所以编写子程序的标志框架如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子程序开始:</span><br><span class=\"line\">    子程序中使用的寄存器入栈</span><br><span class=\"line\">    子程序内容</span><br><span class=\"line\">    子程序中使用的寄存器出栈</span><br><span class=\"line\">    返回(ret&#x2F;retf)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第十章-call和ret指令\"><a href=\"#第十章-call和ret指令\" class=\"headerlink\" title=\"第十章 call和ret指令\"></a>第十章 call和ret指令</h3><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p>\n<h4 id=\"ret和retf\"><a href=\"#ret和retf\" class=\"headerlink\" title=\"ret和retf\"></a>ret和retf</h4><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 </p>\n<p>CPU执行ret指令时，进行下面两步操作：</p>\n<ul>\n<li>(IP)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n</ul>\n<p>CPU执行retf指令时，进行下面四步操作：</p>\n<ul>\n<li>(IP)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n<li>(CS)=((SS)*16+(SP))</li>\n<li>(SP)=(SP)+2</li>\n</ul>\n<p>可以看出，如果用汇编语法来解释ret和retf指令，则：<br>CPU执行ret指令时，相当于执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop IP</span><br></pre></td></tr></table></figure>\n\n<p>CPU执行retf指令时，相当于执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop IP</span><br><span class=\"line\">pop CS</span><br></pre></td></tr></table></figure>\n\n<p>下面的程序中，ret指令执行后，(IP)=0,CS:IP执行代码段的第一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    db 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, stack</span><br><span class=\"line\">    mov ss, ax</span><br><span class=\"line\">    mov sp, 16</span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    push ax</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    ret</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<p>下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">stack segment</span><br><span class=\"line\">    db 16 dup (0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, stack</span><br><span class=\"line\">    mov ss, ax</span><br><span class=\"line\">    mov sp, 16</span><br><span class=\"line\"></span><br><span class=\"line\">    mov ax, 0</span><br><span class=\"line\">    push cs</span><br><span class=\"line\">    push ax</span><br><span class=\"line\">    mov bx, 0</span><br><span class=\"line\">    retf</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"call指令\"><a href=\"#call指令\" class=\"headerlink\" title=\"call指令\"></a>call指令</h4><p>CPU执行call指令时，进行两步操作：</p>\n<ul>\n<li>将当前的IP或CS和IP压入栈中</li>\n<li>转移</li>\n</ul>\n<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p>\n<h4 id=\"依据位移进行转移的call指令\"><a href=\"#依据位移进行转移的call指令\" class=\"headerlink\" title=\"依据位移进行转移的call指令\"></a>依据位移进行转移的call指令</h4><p>call 标号(将当前的IP压栈后，转到标号处执行指令)</p>\n<p>CPU执行此种格式的call指令时，进行如下操作：</p>\n<ul>\n<li>(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)</li>\n<li>(IP)=(IP)+16位位移</li>\n</ul>\n<p>16位位移=“标号”处的地址-call指令后的第一字节的地址<br>16位位移的范围为-32768~32767，用补码表示<br>16位位移的编译程序在编译时算出</p>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp near ptr 标号</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移的目的地址在指令中的call指令\"><a href=\"#转移的目的地址在指令中的call指令\" class=\"headerlink\" title=\"转移的目的地址在指令中的call指令\"></a>转移的目的地址在指令中的call指令</h4><p>指令<code>call far ptr标号</code>实现的是段间转移，此种call指令操作如下：</p>\n<ul>\n<li>(SP)=(SP)-2<br>((SS)<em>16+(SP))=(CS)<br>(SP)=(SP)-2<br>((SS)</em>16+(SP))=(IP)</li>\n<li>(CS)=标号所在段的段地址<br>(IP)=标号所在段中的偏移地址</li>\n</ul>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push CS</span><br><span class=\"line\">push IP</span><br><span class=\"line\">jmp far ptr 标号</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移地址的寄存器中的call指令\"><a href=\"#转移地址的寄存器中的call指令\" class=\"headerlink\" title=\"转移地址的寄存器中的call指令\"></a>转移地址的寄存器中的call指令</h4><p>指令格式：<code>call 16为寄存器</code><br>功能：</p>\n<p>(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)<br>(IP)=(16位寄存器)</p>\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp 16位寄存器</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转移指令在内存中的call指令\"><a href=\"#转移指令在内存中的call指令\" class=\"headerlink\" title=\"转移指令在内存中的call指令\"></a>转移指令在内存中的call指令</h4><p>转移地址在内存中的call指令有两种格式：<br>格式一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call word ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push IP</span><br><span class=\"line\">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>比如下面的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov sp, 10h</span><br><span class=\"line\">mov ax, 0123h</span><br><span class=\"line\">mov ds[0], ax</span><br><span class=\"line\">call word ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>执行后，(IP)=0123, (SP)=0EH</p>\n<p>格式二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>如果用汇编语法解释此种格式的call指令，则相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push CS</span><br><span class=\"line\">push IP</span><br><span class=\"line\">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>\n\n<p>比如下面的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov sp, 10h</span><br><span class=\"line\">mov ax, 0123h</span><br><span class=\"line\">mov ds:[0], ax</span><br><span class=\"line\">mov word ptr ds:[2], 0</span><br><span class=\"line\">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>\n<p>执行后，(CS)=0，(IP)=0123H，(SP)=0CH</p>\n<h4 id=\"call和ret配合使用\"><a href=\"#call和ret配合使用\" class=\"headerlink\" title=\"call和ret配合使用\"></a>call和ret配合使用</h4><p>下面程序返回前，bx中的值是多少</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:</span><br><span class=\"line\">    mov ax, 1</span><br><span class=\"line\">    mov cx, 3</span><br><span class=\"line\">    call s</span><br><span class=\"line\">    mov bx, ax  ;(bx)&#x3D;?</span><br><span class=\"line\">    mov ax, 4c00h</span><br><span class=\"line\">    int 21h</span><br><span class=\"line\">s:</span><br><span class=\"line\">    add ax, ax</span><br><span class=\"line\">    loop s</span><br><span class=\"line\">    ret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mul指令\"><a href=\"#mul指令\" class=\"headerlink\" title=\"mul指令\"></a>mul指令</h4><p>mul是乘法指令，使用mul做乘法的时候：</p>\n<ul>\n<li>两个想乘的数，要么都是8位，要是都是16位。如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存单元中</li>\n<li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中，低位在AX中</li>\n</ul>\n<p>格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mul reg</span><br><span class=\"line\">mul 内存单元</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模块化程序设计\"><a href=\"#模块化程序设计\" class=\"headerlink\" title=\"模块化程序设计\"></a>模块化程序设计</h4><p>call和ret指令共同支持了汇编语言中的模块化设计。</p>\n<h4 id=\"参数和结果传递的问题\"><a href=\"#参数和结果传递的问题\" class=\"headerlink\" title=\"参数和结果传递的问题\"></a>参数和结果传递的问题</h4><p>讨论参数和返回值传递的问题，实际上是探讨如何存储子程序需要的参数和产生的返回值。用寄存器来存储参数和结果是最常使用的方法，对于存放参数和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取得返回值；子程序从参数寄存器中取得参数，将返回值送入结果寄存器</p>\n<h4 id=\"批量数据的传递\"><a href=\"#批量数据的传递\" class=\"headerlink\" title=\"批量数据的传递\"></a>批量数据的传递</h4><p>批量传参和结果时，可以将批量数据存放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。</p>\n<h4 id=\"寄存器冲突问题\"><a href=\"#寄存器冲突问题\" class=\"headerlink\" title=\"寄存器冲突问题\"></a>寄存器冲突问题</h4><p>在子程序的开始将子程序中所有用到的寄存器中的内容保持起来，在子程序返回前再回复。可以用栈来保持寄存器的内容。</p>\n<p>所以编写子程序的标志框架如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子程序开始:</span><br><span class=\"line\">    子程序中使用的寄存器入栈</span><br><span class=\"line\">    子程序内容</span><br><span class=\"line\">    子程序中使用的寄存器出栈</span><br><span class=\"line\">    返回(ret&#x2F;retf)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckdvsps8j000dq1fw4h0j4uz8","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8m000lq1fw1axeaz4k"},{"post_id":"ckdvsps8g0008q1fw0v994c76","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8n000qq1fw3kd1a3zb"},{"post_id":"ckdvsps8j000eq1fw5bkzbc0v","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8o000tq1fwf41z8hoy"},{"post_id":"ckdvsps8l000iq1fwfvlkbeqb","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8o000vq1fw0rbo162s"},{"post_id":"ckdvsps8h0009q1fw6o7cfskf","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8p000xq1fw07j905ya"},{"post_id":"ckdvsps8m000kq1fw7p6lcpc5","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8p000zq1fw6f3k9vb2"},{"post_id":"ckdvsps8n000pq1fwf0jp56mi","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8p0011q1fwbr7ah954"},{"post_id":"ckdvsps8i000cq1fwei5lb1vb","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8p0013q1fw47b03tfu"},{"post_id":"ckdvsps8o000sq1fw2r378d20","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdvsps8p0014q1fweq2xf05g"},{"post_id":"ckdyli9tr0001qofw1h726xds","category_id":"ckdvsps6s0003q1fw3m02asa4","_id":"ckdyli9tu0005qofw13ed10iv"},{"post_id":"ckdyli9ts0002qofw272i4bls","category_id":"ckdvsps8i000aq1fway2jdbno","_id":"ckdyli9tu0006qofw9gcjgg7o"}],"PostTag":[{"post_id":"ckdvsps8j000dq1fw4h0j4uz8","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8l000hq1fwgzzidtkv"},{"post_id":"ckdvsps8g0008q1fw0v994c76","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8m000jq1fwa1a98lu5"},{"post_id":"ckdvsps8j000eq1fw5bkzbc0v","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8n000oq1fwbcysb4r5"},{"post_id":"ckdvsps8l000iq1fwfvlkbeqb","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8o000rq1fw2gfbddu4"},{"post_id":"ckdvsps8h0009q1fw6o7cfskf","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8o000uq1fwfndg0skz"},{"post_id":"ckdvsps8m000kq1fw7p6lcpc5","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8p000wq1fwgp9e6twe"},{"post_id":"ckdvsps8n000pq1fwf0jp56mi","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8p000yq1fwfsiv8gj1"},{"post_id":"ckdvsps8i000cq1fwei5lb1vb","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8p0010q1fwb5xn5s2s"},{"post_id":"ckdvsps8o000sq1fw2r378d20","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdvsps8p0012q1fw2zrrahue"},{"post_id":"ckdyli9tr0001qofw1h726xds","tag_id":"ckdvsps6t0004q1fwd0793d8s","_id":"ckdyli9tt0003qofwaysig6l1"},{"post_id":"ckdyli9ts0002qofw272i4bls","tag_id":"ckdvsps8i000bq1fwbo1a5jgb","_id":"ckdyli9tu0004qofwae9n133m"}],"Tag":[{"name":"Linux","_id":"ckdvsps6t0004q1fwd0793d8s"},{"name":"汇编","_id":"ckdvsps8i000bq1fwbo1a5jgb"}]}}